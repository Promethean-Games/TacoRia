<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Taco Ria</title>
  <style>
    :root{
      --bg:#050608;
      --bg2:#0a0c10;
      --text:#f3f4f6;
      --muted:rgba(243,244,246,.70);
      --muted2:rgba(243,244,246,.55);
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.14);
      --danger:#ff3b30;

      --accent:#00e5ff;
      --accentSoft: rgba(0,229,255,.14);

      --radius:20px;
      --pad:16px;
      --gap:12px;
      --shadow: 0 18px 45px rgba(0,0,0,.55);

      --navH:56px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(900px 380px at 18% 0%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(780px 360px at 85% 10%, rgba(255,255,255,.05), transparent 65%),
        radial-gradient(820px 420px at 50% 115%, rgba(0,0,0,.75), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow-x:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .shell{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      width:100%;
      margin:0 auto;
      max-width: 980px;
    }
    @media (max-width: 430px){ .shell{ max-width: 375px; } }
    @media (max-width: 390px){ .shell{ max-width: 360px; } }

    header{
      padding: 14px 14px 10px;
      min-height:56px;
    }
    main{
      flex:1;
      padding: 0 14px calc(var(--navH) + env(safe-area-inset-bottom) + 18px);
    }

    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ min-width:0; }
    .wrap{ flex-wrap:wrap; }
    .sp{ justify-content:space-between; }

    .pageTitle{
      font-weight:1000;
      letter-spacing:.2px;
      line-height:1.08;
      font-size: clamp(20px, 4.7vw, 28px);
    }
    .small{ font-size:12px; }
    .muted{ color:var(--muted); }
    .muted2{ color:var(--muted2); }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.065), rgba(255,255,255,.035));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: var(--shadow);
    }

    .heroPhase{
      position:relative;
      overflow:hidden;
    }
    .heroPhase::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(600px 240px at 20% 0%, rgba(255,255,255,.08), transparent 65%),
        radial-gradient(520px 240px at 85% 10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(540px 260px at 50% 120%, rgba(0,0,0,.60), transparent 55%);
      pointer-events:none;
    }
    .heroPhase > *{ position:relative; z-index:1; }

    .pills{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    button{
      border:1px solid var(--stroke2);
      background: rgba(0,0,0,.35);
      color:var(--text);
      border-radius: 18px;
      padding: 12px 14px;
      font-weight:1000;
      letter-spacing:.2px;
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .btnTiny{ padding:8px 10px; border-radius:14px; font-size:12px; }
    .ghost{ background: rgba(0,0,0,.20); }
    .primary{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border-color: rgba(255,255,255,.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 20px rgba(0,0,0,.55);
    }
    .danger{
      background: linear-gradient(180deg, rgba(255,59,48,.22), rgba(255,59,48,.10));
      border-color: rgba(255,59,48,.35);
    }

    /* Jumbo gameplay buttons */
    .jumbo{
      min-height: 64px;
      font-size: 18px;
      border-radius: 20px;
      width:100%;
    }
    @media (max-width: 430px){
      .jumbo{ min-height: 68px; font-size: 19px; }
    }

    @keyframes pulseGlow{
      0%   { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
      50%  { transform: translateY(-1px); box-shadow: 0 0 0 1px rgba(255,255,255,.10), 0 0 32px rgba(0,229,255,.35); }
      100% { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
    }
    .pulse{ animation: pulseGlow 1.35s ease-in-out infinite; }
    .pulseOrder{ animation: pulseGlow 1.15s ease-in-out infinite; }

    /* Sticky action tray above bottom nav */
    .actionsTray{
      position: sticky;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom));
      z-index: 30;
    }
    .actionsStack{ display:flex; flex-direction:column; gap:10px; }

    /* Tiles */
    .tiles{ display:flex; flex-wrap:wrap; gap:8px; }
    .tile{
      max-width:100%;
      overflow-wrap:anywhere;
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      font-weight: 900;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      --catTint: rgba(255,255,255,.06);
      background:
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.sel{
      outline: 2px solid rgba(0,229,255,.55);
      transform: translateY(-1px);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.wild{ border-color: rgba(255,255,255,.28); box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset; }
    .tile.wet{ border-color: rgba(0,229,255,.25); }

    /* Hand grouping */
    .handGroups{ display:flex; flex-direction:column; gap:12px; }
    .handGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(0,0,0,.22);
      padding:10px;
    }
    .handGroupTitle{
      font-weight:1000;
      font-size:12px;
      letter-spacing:.18px;
      color: var(--muted);
      margin-bottom:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .handGroupTitle .count{ opacity:.75; font-weight:1000; }

    /* Category tinting */
    .tile.cat-tortilla, .slotValue.cat-tortilla{ --catTint: rgba(255,204,0,.18); border-color: rgba(255,204,0,.30); }
    .tile.cat-protein,  .slotValue.cat-protein { --catTint: rgba(255,59,48,.16);  border-color: rgba(255,59,48,.28); }
    .tile.cat-cheese,   .slotValue.cat-cheese  { --catTint: rgba(255,245,200,.14); border-color: rgba(255,245,200,.24); }
    .tile.cat-wet,      .slotValue.cat-wet     { --catTint: rgba(255,43,214,.14); border-color: rgba(255,43,214,.24); }
    .tile.cat-drytop,   .slotValue.cat-drytop  { --catTint: rgba(163,255,18,.12); border-color: rgba(163,255,18,.22); }
    .tile.cat-wild,     .slotValue.cat-wild    { --catTint: rgba(255,255,255,.10); border-color: rgba(255,255,255,.26); }
    .tile.cat-other,    .slotValue.cat-other   { --catTint: rgba(179,107,255,.14); border-color: rgba(179,107,255,.24); }

    /* Public line */
    .pubGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      padding:12px;
      margin-bottom:12px;
    }
    .pubGroupTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
      margin-bottom: 8px;
    }
    .pubDishRow{
      border:1px solid var(--stroke);
      border-radius:16px;
      background: rgba(0,0,0,.45);
      padding:10px;
      margin-top:10px;
      position:relative;
      overflow:hidden;
    }
    .pubDishRow::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, var(--tintA), transparent 70%);
      opacity:.95;
      pointer-events:none;
    }
    .pubDishRow > *{ position:relative; z-index:1; }
    .pubDishMeta{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
    }

    /* Accordion */
    details.acc{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    details.acc + details.acc{ margin-top:10px; }
    details.acc summary{
      list-style:none;
      cursor:pointer;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:1000;
    }
    details.acc summary::-webkit-details-marker{ display:none; }
    .accBody{ padding: 0 14px 14px; }
    .field{ margin-top:10px; }
    .label{ font-size:12px; color:var(--muted); margin-bottom:6px; font-weight:900; }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; line-height:1.35; }

    :root{ color-scheme: dark; }
    select, input[type="number"]{
      width:100%;
      padding:12px 40px 12px 14px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background:#0b0b0b;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      appearance:none;
      -webkit-appearance:none;
      outline:none;
    }
    select option{ background:#0b0b0b; color: rgba(255,255,255,.92); }
    .selectWrap{ position:relative; }
    .selectWrap::after{
      content:"‚ñæ";
      position:absolute;
      right:14px; top:50%;
      transform: translateY(-50%);
      opacity:.75;
      pointer-events:none;
      font-weight:1000;
    }

    nav.footer{
      position:fixed;
      left:0; right:0; bottom:0;
      height: var(--navH);
      padding-bottom: env(safe-area-inset-bottom);
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      z-index: 40;
    }
    .navBtn{
      flex:1;
      min-height:56px;
      border:none;
      border-right: 1px solid rgba(255,255,255,.06);
      background: transparent;
      color: rgba(255,255,255,.86);
      font-weight:1000;
      border-radius: 0;
      padding: 8px 6px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:2px;
    }
    .navBtn:last-child{ border-right:none; }
    .navBtn.active{
      color:#fff;
      background: radial-gradient(320px 120px at 50% 0%, rgba(0,229,255,.20), transparent 60%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .navBtn .ic{ font-size:16px; }
    .navBtn .tx{ font-size:12px; }

    #toastWrap{
      position:fixed;
      left:0; right:0;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom) + 12px);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 80;
    }
    .toast{
      max-width:min(560px, calc(100% - 24px));
      background: rgba(0,0,0,.78);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,.65);
      font-weight: 900;
      pointer-events:none;
    }

    #modalWrap{
      position:fixed; inset:0;
      background: rgba(0,0,0,.65);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 90;
    }
    #modalWrap.on{ display:flex; }

    /* FIX: modal scroll + height containment (draw grid rendering) */
    .modal{
      width: min(560px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: 0 22px 60px rgba(0,0,0,.70);
      padding: 14px;
      max-height: 86vh;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .modal h3{ margin: 4px 0 8px; font-size: 18px; flex:0 0 auto; }
    .modal .body{
      color: var(--muted);
      font-weight: 900;
      line-height: 1.35;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 2px;
      flex:1 1 auto;
      min-height: 0;
    }
    .modal .foot{ margin-top: 12px; display:flex; gap:10px; justify-content:flex-end; flex:0 0 auto; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .page{ display:none; }
    .page.on{ display:block; }

    /* Dish slot carousel */
    .slotStrip{
      display:flex;
      gap:10px;
      overflow-x:auto;
      padding: 4px 2px 10px;
      -webkit-overflow-scrolling:touch;
      scroll-snap-type:x mandatory;
    }
    .slotCard{
      flex: 0 0 auto;
      width: min(150px, 44vw);
      scroll-snap-align:start;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.32);
      padding:12px;
      position:relative;
      overflow:hidden;
      user-select:none;
      cursor:pointer;
    }
    .slotCard::before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(320px 120px at 20% 0%, rgba(255,255,255,.07), transparent 60%);
      pointer-events:none;
    }
    .slotCard > *{ position:relative; z-index:1; }
    .slotLabel{
      font-weight:1000;
      font-size:12px;
      color: rgba(243,244,246,.70);
      margin-bottom:8px;
    }
    .slotValue{
      --catTint: rgba(255,255,255,.06);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:40px;
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      padding:10px 10px;
      font-weight:1000;
      text-align:center;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      background:
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .slotEmpty{
      background: rgba(255,255,255,.03);
      color: rgba(243,244,246,.45);
      border-style:dashed;
    }
    .slotFilled{
      border-color: rgba(255,255,255,.20);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }

    /* ===== Draw Tile Modal Grid ===== */
    .drawMeta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 10px;
    }
    .drawGrid{
      display:grid;
      gap:10px;
      margin-top: 10px;
    }
    .drawGrid.busy{ pointer-events:none; opacity:.95; }

    /* Tile back + reveal animation */
    .tileBack{
      position:relative;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      background:
        radial-gradient(340px 140px at 25% 0%, rgba(255,255,255,.08), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: 0 12px 28px rgba(0,0,0,.50);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      min-height: 78px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 10px 8px;
      transform: translateZ(0);
      --catTint: rgba(255,255,255,.06);
    }
    .tileBack:active{ transform: translateY(1px) scale(.99); }
    .tileBack::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(520px 240px at 10% 0%, rgba(0,229,255,.16), transparent 60%),
        radial-gradient(520px 240px at 90% 10%, rgba(255,255,255,.06), transparent 65%);
      opacity:.65;
      pointer-events:none;
    }
    .tileBack::after{
      content:"";
      position:absolute; inset:0;
      background:
        linear-gradient(135deg, rgba(0,0,0,.25), rgba(0,0,0,.55));
      opacity:.55;
      pointer-events:none;
    }
    .tileBackInner{ position:relative; z-index:1; width:100%; }
    .tileBackBrand{
      font-weight:1000;
      letter-spacing:.2px;
      color: rgba(243,244,246,.70);
      font-size: 12px;
      line-height:1.1;
    }
    .tileBackMark{
      margin-top:6px;
      font-weight:1000;
      font-size: 10px;
      color: rgba(243,244,246,.42);
      letter-spacing:.18px;
    }
    .tileBackNum{
      position:absolute;
      top:10px;
      left:10px;
      z-index:2;
      font-weight:1000;
      font-size:12px;
      color: rgba(243,244,246,.42);
      background: rgba(0,0,0,.24);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 4px 8px;
    }
    .tileBackSel{
      outline: 2px solid rgba(0,229,255,.55);
      box-shadow: 0 0 0 1px rgba(255,255,255,.08), 0 0 30px rgba(0,229,255,.30);
    }
    @keyframes tileSpinReveal{
      0%   { transform: rotateY(0deg) scale(1); }
      45%  { transform: rotateY(180deg) scale(1.03); }
      100% { transform: rotateY(360deg) scale(1); }
    }
    .tileBack.spin{ animation: tileSpinReveal .78s ease-in-out forwards; }

    .tileFrontName{
      font-weight:1000;
      font-size: 12px;
      color: rgba(255,255,255,.95);
      line-height:1.05;
      text-shadow: 0 8px 18px rgba(0,0,0,.45);
    }
    .tileFrontCat{
      margin-top:6px;
      font-weight:1000;
      font-size: 10px;
      color: rgba(243,244,246,.62);
      letter-spacing:.18px;
    }
    .tileBack.revealed{
      background:
        linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02)),
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.55));
      border-color: rgba(255,255,255,.22);
    }

    /* Apply category tints to tileBack too */
    .tileBack.cat-tortilla{ --catTint: rgba(255,204,0,.18); border-color: rgba(255,204,0,.30); }
    .tileBack.cat-protein { --catTint: rgba(255,59,48,.16);  border-color: rgba(255,59,48,.28); }
    .tileBack.cat-cheese  { --catTint: rgba(255,245,200,.14); border-color: rgba(255,245,200,.24); }
    .tileBack.cat-wet     { --catTint: rgba(255,43,214,.14); border-color: rgba(255,43,214,.24); }
    .tileBack.cat-drytop  { --catTint: rgba(163,255,18,.12); border-color: rgba(163,255,18,.22); }
    .tileBack.cat-wild    { --catTint: rgba(255,255,255,.10); border-color: rgba(255,255,255,.26); }
    .tileBack.cat-other   { --catTint: rgba(179,107,255,.14); border-color: rgba(179,107,255,.24); }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="row sp">
        <div>
          <div class="row" style="gap:10px;">
            <div class="pageTitle" id="appNameH">Taco Ria</div>
            <span class="pill"><span class="mono" id="verPill">v0.9.1.2.25</span></span>
          </div>
          <div class="muted small" id="subTitle">Private Prep ‚Ä¢ Public Line ‚Ä¢ Remix</div>
        </div>
        <button class="ghost btnTiny" id="btnNewMatchTop">New Match</button>
      </div>
    </header>

    <main>
      <!-- GAMEPLAY -->
      <section class="page on" id="pageGameplay">
        <div class="card heroPhase" style="margin-bottom:12px;">
          <div class="pills" style="margin-top:2px;">
            <span class="pill" id="tilesRemainBadge">Tiles Remaining 0</span>
            <span class="pill" id="kitchenBadge">Kitchen Closed</span>
            <span class="pill" id="handBadge">Hand 1/12</span>
            <span class="pill" id="turnBadge">Your Turn</span>
          </div>

          <div style="margin-top:12px;">
            <div style="font-weight:1000; font-size:16px;" id="phaseTitle">Not Seated Yet</div>
            <div class="muted" id="phaseDesc">Serve 10+ points in one turn to open the kitchen.</div>
          </div>
        </div>

        <!-- SIMPLE ACTIONS -->
        <div class="actionsTray">
          <div class="card">
            <div class="actionsStack">
              <button class="primary jumbo pulse" id="btnPrep">Prep a Dish</button>
              <button class="primary jumbo" id="btnOrderUp">Order Up!</button>
              <button class="danger jumbo" id="btnEndTurn">End Turn</button>
            </div>
            <div class="muted small" style="margin-top:10px;" id="actionHint">
              Draw happens on the Prep screen. One draw per turn.
            </div>
          </div>
        </div>

        <!-- PUBLIC LINE -->
        <div class="card" style="margin-top:12px;">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Public Line / Window</div>
            <span class="pill" id="lineSummary">0 dishes</span>
          </div>
          <div id="publicLine"></div>
        </div>
      </section>

      <!-- PREP -->
      <section class="page" id="pagePrep">
        <div class="card">
          <div class="row sp" style="margin-bottom:8px;">
            <div style="font-weight:1000;">Prep Table</div>
            <span class="badge" id="prepTurnBadge">Your Turn</span>
          </div>

          <div class="actionsStack" style="margin-bottom:12px;">
            <button class="primary jumbo" id="btnDraw">Draw Tile</button>
            <button class="primary jumbo" id="btnOrderUpFromPrep">Order Up!</button>
          </div>

          <details class="acc" open>
            <summary>
              <span>Your Hand</span>
              <span class="muted2 small" id="handCountHint">0 tiles</span>
            </summary>
            <div class="accBody">
              <div id="handTiles"></div>

              <div class="row wrap" style="margin-top:12px; justify-content:space-between;">
                <div class="row wrap" style="gap:10px;">
                  <button class="ghost btnTiny" id="btnNewDish">+ New Dish</button>
                  <button class="ghost btnTiny" id="btnClearDish">Clear Dish</button>
                </div>
              </div>

              <div class="hint" id="handHint" style="margin-top:10px;">
                Tap hand tiles to add/remove from your current dish.
              </div>
            </div>
          </details>

          <details class="acc" open>
            <summary>
              <span>Current Dish</span>
              <span class="muted2 small" id="dishMeta">‚Äî</span>
            </summary>
            <div class="accBody">
              <div class="field">
                <div class="label">Recipe</div>
                <div class="selectWrap">
                  <select id="selRecipe"></select>
                </div>
              </div>

              <div class="field">
                <div class="label">Ingredients (auto-placed)</div>
                <div class="slotStrip" id="dishCarousel"></div>
              </div>

              <div class="row wrap" style="margin-top:12px; justify-content:flex-end;">
                <button class="ghost btnTiny" id="btnRemoveDish">Remove Dish</button>
              </div>

              <div class="hint" id="dishHint"></div>
            </div>
          </details>
        </div>
      </section>

      <!-- SCORES -->
      <section class="page" id="pageScores">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Scores</div>
            <span class="badge" id="scoreModePill">Standard</span>
          </div>

          <div class="row wrap" style="gap:10px; margin-bottom:12px;">
            <span class="pill" id="scoreCurrent">Current: 0</span>
            <span class="pill muted" id="scoreServedMuted">Served this hand: 0</span>
          </div>

          <div id="scoreList"></div>

          <div class="hint" style="margin-top:10px;">
            Player panels are collapsed by default. Expand to see served dishes and remix net.
          </div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="page" id="pageSettings">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Settings</div>
            <span class="badge">v<span class="mono">0.9.1.2.25</span></span>
          </div>
          <div class="muted small">Primary theme stays black. Choose a high-contrast accent.</div>

          <details class="acc" open style="margin-top:12px;">
            <summary>
              <span>Match</span>
              <span class="muted2 small">Mode + Players</span>
            </summary>
            <div class="accBody">
              <div class="row wrap" style="gap:12px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Mode</div>
                  <div class="selectWrap">
                    <select id="selMode">
                      <option value="standard">Standard Match</option>
                      <option value="campaign">Campaign</option>
                    </select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Players</div>
                  <div class="selectWrap">
                    <select id="selPlayers">
                      <option value="2">2 Players</option>
                      <option value="3">3 Players</option>
                      <option value="4" selected>4 Players</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">CPU Difficulty (Standard only)</div>
                  <div class="selectWrap">
                    <select id="selDifficulty"></select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Hands (Standard only)</div>
                  <input type="number" id="inpHands" min="1" max="12" value="12" />
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Tiles per Player</div>
                  <input type="number" id="inpTilesPerPlayer" min="8" max="24" value="16" />
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Decks</div>
                  <div class="selectWrap">
                    <select id="selDecks">
                      <option value="1">1 Deck</option>
                      <option value="2" selected>2 Decks (Recommended)</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Theme</span>
              <span class="muted2 small">Accent Color</span>
            </summary>
            <div class="accBody">
              <div class="label">Accent</div>
              <div class="selectWrap">
                <select id="selAccent"></select>
              </div>
              <div class="hint">CPU colors will auto-adjust to avoid matching you or each other.</div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Language</span>
              <span class="muted2 small">EN / ES / FR / DE</span>
            </summary>
            <div class="accBody">
              <div class="label">App Language</div>
              <div class="selectWrap">
                <select id="selLang">
                  <option value="en">English</option>
                  <option value="es">Espa√±ol</option>
                  <option value="fr">Fran√ßais</option>
                  <option value="de">Deutsch</option>
                </select>
              </div>
            </div>
          </details>
        </div>
      </section>
    </main>
  </div>

  <nav class="footer">
    <button class="navBtn active" id="navGame"><div class="ic">üé≠</div><div class="tx">Gameplay</div></button>
    <button class="navBtn" id="navPrep"><div class="ic">üç≥</div><div class="tx">Prep</div></button>
    <button class="navBtn" id="navScores"><div class="ic">üèÜ</div><div class="tx">Scores</div></button>
    <button class="navBtn" id="navSettings"><div class="ic">‚öôÔ∏è</div><div class="tx">Settings</div></button>
  </nav>

  <div id="toastWrap"></div>

  <div id="modalWrap">
    <div class="modal">
      <h3 id="modalTitle">Modal</h3>
      <div class="body" id="modalBody"></div>
      <div class="foot" id="modalFoot"></div>
    </div>
  </div>

  <script>
    /* =========================
       Taco Ria v0.9.1.2.25 (Atomic Patch)
       ‚úÖ Draw Tile opens a modal grid of face-down branded tiles + spin/reveal animation
       ‚úÖ Player selects any tile; assigned tile is RANDOM regardless of choice
       ‚úÖ Grid shows up to 5x5 (25) if >=25 remaining; else best-fit grid w/ exact count + numbering
       ‚úÖ Declares when no tiles remain
       ‚úÖ Still enforces: one draw per turn
       ‚úÖ Scoring refresh: base recipe points + 1 per extra ingredient tile
          - Taco: base = tortilla + protein + 3 dry toppings (extras allowed up to 2 tiles)
          - Enchiladas: base 4 tiles + up to 3 extra toppings
          - Pico: no extras (still fixed 4)
          - Breakfast Taco added (base tortilla+egg, extras allowed; bans sour cream/charro/black beans)
       ‚úÖ Lauren‚Äôs Lunch: toast on any double lettuce publish (incl. remixes), +5 only on ORIGINAL play
       ========================= */

    const VERSION = "v0.9.1.2.25";
    const LS_KEY = "taco_ria_state_v091225";

    const DIFFS = ["Beginner","Easy","Medium","Difficult","Master Chef"];
    const DIFF_DELAY_MS = { "Beginner":5000, "Easy":3500, "Medium":2200, "Difficult":1200, "Master Chef":500 };

    const ACCENTS = [
      { name:"Neon Cyan", val:"#00e5ff" },
      { name:"Signal Yellow", val:"#ffcc00" },
      { name:"Lime", val:"#a3ff12" },
      { name:"Hot Pink", val:"#ff2bd6" },
      { name:"Orange", val:"#ff8a00" },
      { name:"Ice", val:"#b3f6ff" },
      { name:"Violet", val:"#b36bff" },
      { name:"Red", val:"#ff3b30" }
    ];

    const CPU_BASE_COLORS = ["#ff3b30","#b36bff","#ffcc00","#a3ff12"];

    const I18N = {
      en: { gameplay:"Gameplay", prep:"Prep", scores:"Scores", settings:"Settings", orderUp:"Order Up!", drawTile:"Draw Tile", endTurn:"End Turn", prepDish:"Prep a Dish", cancel:"Cancel", close:"Close" },
      es: { gameplay:"Juego", prep:"Preparaci√≥n", scores:"Puntos", settings:"Ajustes", orderUp:"¬°Orden lista!", drawTile:"Robar ficha", endTurn:"Terminar turno", prepDish:"Preparar plato", cancel:"Cancelar", close:"Cerrar" },
      fr: { gameplay:"Jeu", prep:"Pr√©pa", scores:"Scores", settings:"R√©glages", orderUp:"√Ä l‚Äôenvoi !", drawTile:"Piocher une tuile", endTurn:"Fin du tour", prepDish:"Pr√©parer un plat", cancel:"Annuler", close:"Fermer" },
      de: { gameplay:"Spiel", prep:"Vorbereiten", scores:"Punkte", settings:"Einstellungen", orderUp:"Bestellung raus!", drawTile:"Pl√§ttchen ziehen", endTurn:"Zug beenden", prepDish:"Gericht vorbereiten", cancel:"Abbrechen", close:"Schlie√üen" },
    };

    const RULES = {
      remixMinPoints: 5,
      tacoDryToppingsRequired: 3,
      wetLockedUntilKitchen: true,
      starterPassDishKey: "chipsDip",
    };

    const ACH = {
      laurensLunchBonus: 5,
      laurensLunchMs: 5000,
    };

    const RECIPES = [
      { key:"hardTaco", name:"Hard Shell Taco", pts:5, kind:"taco", tortilla:"Corn Tortillas" },
      { key:"softTaco", name:"Soft Taco", pts:5, kind:"taco", tortilla:"Flour Tortillas" },
      { key:"breakfastTaco", name:"Breakfast Taco", pts:5, kind:"breakfastTaco" }, /* NEW */
      { key:"chorizoTaco", name:"Chorizo Taco", pts:8, kind:"chorizoTaco" },
      { key:"chipsDip", name:"Chips & Dip", pts:5, kind:"chipsDip" },
      { key:"pico", name:"Pico de Gallo", pts:8, kind:"pico" },
      { key:"ench", name:"Enchiladas", pts:10, kind:"ench" },
    ];

    const DECK_ING_COUNTS = [
      ["Fish",1],["Ground Beef",2],["Shredded Chicken",2],["Carne Guisada",1],["Al Pastor",1],["Carnitas",1],
      ["Egg",2],["Chicken Fajita",2],["Chorizo",1],
      ["Tortilla Chips",3],["Flour Tortillas",2],["Corn Tortillas",2],
      ["Shredded yellow Cheese",2],["Shredded white cheese",2],
      ["Rice",2],["Charro Beans",1],["Refried Beans",1],["Black Beans",1],
      ["Cilantro",2],["Jalapenos",2],["Lettuce",1],["Lime Juice",2],["Onion",2],["Tomato",2],
      ["Sour Cream",2],["Avocado",2],
      ["Salsa Roja",2],["Salsa Verde",2],["Queso",2],["Guacamole",2],
      ["Grocery Run",2],
    ];

    const $ = (id)=> document.getElementById(id);

    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }
    function randInt(n){ return Math.floor(Math.random()*n); }
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }
    function nowId(prefix="id"){
      return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }
    function hexToRgba(hex, a){
      const h = (hex || "#ffffff").replace("#","").trim();
      const full = h.length===3 ? h.split("").map(c=>c+c).join("") : h.padEnd(6,"0").slice(0,6);
      const n = parseInt(full,16);
      const r=(n>>16)&255, g=(n>>8)&255, b=n&255;
      return `rgba(${r},${g},${b},${a})`;
    }
    function groupBy(arr, keyFn){
      const m = {};
      for(const it of arr){
        const k = keyFn(it);
        (m[k] ||= []).push(it);
      }
      return m;
    }
    function toast(msg, ms=2200){
      const wrap = $("toastWrap");
      wrap.innerHTML = `<div class="toast">${escapeHtml(msg)}</div>`;
      clearTimeout(toast._t);
      toast._t = setTimeout(()=> wrap.innerHTML="", ms);
    }
    function openModal(title, html, footButtons){
      $("modalTitle").textContent = title;
      $("modalBody").innerHTML = html;
      $("modalFoot").innerHTML = "";
      for(const b of footButtons){
        const btn = document.createElement("button");
        btn.className = b.className || "ghost";
        btn.textContent = b.text;
        btn.onclick = ()=> b.onClick?.();
        $("modalFoot").appendChild(btn);
      }
      $("modalWrap").classList.add("on");
    }
    function closeModal(){ $("modalWrap").classList.remove("on"); modalMode = null; $("modalBody").onclick = null; }
    $("modalWrap").addEventListener("click",(e)=>{ if(e.target.id==="modalWrap") closeModal(); });

    function t(key){
      const lang = state.settings.lang || "en";
      return (I18N[lang] && I18N[lang][key]) || I18N.en[key] || key;
    }

    function getAppName(){
      return ($("appNameH")?.textContent || document.title || "App").trim();
    }

    function recipeByKey(k){ return RECIPES.find(r=>r.key===k); }

    /* ===== Ingredient classification ===== */
    function isWild(name){ return name==="Grocery Run"; }
    function isTortilla(name){ return name==="Corn Tortillas" || name==="Flour Tortillas"; }
    function isProtein(name){
      return ["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"].includes(name);
    }
    function isCheese(name){ return name==="Shredded yellow Cheese" || name==="Shredded white cheese"; }
    function isSauce(name){ return name==="Salsa Roja" || name==="Salsa Verde"; }
    function isWet(name){ return ["Salsa Roja","Salsa Verde","Queso","Guacamole"].includes(name); }
    function isDip(name){ return ["Salsa Roja","Salsa Verde","Guacamole","Queso"].includes(name); }
    function isTopping(name){
      return isWet(name) || ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Avocado","Shredded yellow Cheese","Shredded white cheese"].includes(name);
    }
    function isDryTopping(name){ return isTopping(name) && !isWet(name) && !isCheese(name); }

    function ingredientCategory(name){
      if(isWild(name)) return "wild";
      if(isTortilla(name)) return "tortilla";
      if(isProtein(name)) return "protein";
      if(isCheese(name)) return "cheese";
      if(isWet(name)) return "wet";
      if(isDryTopping(name)) return "drytop";
      return "other";
    }
    function categoryLabel(cat){
      return {
        tortilla:"Tortillas",
        protein:"Proteins",
        cheese:"Cheese",
        wet:"Wet Toppings",
        drytop:"Dry Toppings",
        wild:"Grocery Run",
        other:"Other"
      }[cat] || cat;
    }

    /* ===== Lauren's Lunch ===== */
    function hasDoubleLettuce(tileObjs){
      return (tileObjs || []).filter(t=>t?.name==="Lettuce").length >= 2;
    }

    /* ===== Points: base + 1 per extra ingredient tile ===== */
    function requiredCountForRecipe(recipeKey){
      const r = recipeByKey(recipeKey);
      if(!r) return 0;
      if(r.kind==="taco") return 5;             // tortilla + protein + 3 dry toppings
      if(r.kind==="breakfastTaco") return 2;    // tortilla + egg
      if(r.kind==="ench") return 4;             // tortillas + protein + sauce + cheese
      if(r.kind==="chipsDip") return 2;
      if(r.kind==="pico") return 4;
      if(r.kind==="chorizoTaco") return 4;
      return 0;
    }
    function computeDishPoints(recipeKey, tileObjs, isRemix=false){
      const r = recipeByKey(recipeKey);
      const base = r?.pts || 0;
      const req = requiredCountForRecipe(recipeKey);
      const extraCount = Math.max(0, (tileObjs?.length || 0) - req);
      const laurenBonus = (!isRemix && hasDoubleLettuce(tileObjs)) ? ACH.laurensLunchBonus : 0;
      return base + extraCount + laurenBonus;
    }

    /* ===== Slot layout for Current Dish ===== */
    function slotDefsForRecipe(recipeKey){
      const r = recipeByKey(recipeKey);
      const S = (key,label,accept)=>({ key,label,accept });

      if(!r) return [
        S("any1","Slot 1",()=>true), S("any2","Slot 2",()=>true), S("any3","Slot 3",()=>true), S("any4","Slot 4",()=>true),
        S("any5","Slot 5",()=>true), S("any6","Slot 6",()=>true), S("any7","Slot 7",()=>true), S("any8","Slot 8",()=>true),
      ];

      if(r.kind==="taco"){
        return [
          S("tort","Tortilla", isTortilla),
          S("prot","Protein",  isProtein),
          S("chee","Cheese (opt)", isCheese),
          S("wet","Wet (opt)", (n)=> isWet(n)),
          S("top1","Dry Top 1", isDryTopping),
          S("top2","Dry Top 2", isDryTopping),
          S("top3","Dry Top 3", isDryTopping),
          S("xtra","Extra", (n)=> isTopping(n) || isWild(n)),
        ];
      }

      if(r.kind==="breakfastTaco"){
        return [
          S("tort","Tortilla", isTortilla),
          S("egg","Egg", (n)=> n==="Egg"),
          S("chee","Cheese (opt)", isCheese),
          S("wet","Wet (opt)", (n)=> isWet(n)),
          S("top1","Topping 1", (n)=> isTopping(n) || isWild(n)),
          S("top2","Topping 2", (n)=> isTopping(n) || isWild(n)),
          S("top3","Topping 3", (n)=> isTopping(n) || isWild(n)),
          S("top4","Topping 4", (n)=> isTopping(n) || isWild(n)),
        ];
      }

      if(r.kind==="chipsDip"){
        return [
          S("chip","Chips", (n)=> n==="Tortilla Chips"),
          S("dip","Dip",   isDip),
          S("x1","Extra",  ()=>true),
          S("x2","Extra",  ()=>true),
          S("x3","Extra",  ()=>true),
          S("x4","Extra",  ()=>true),
          S("x5","Extra",  ()=>true),
          S("x6","Extra",  ()=>true),
        ];
      }
      if(r.kind==="pico"){
        return [
          S("tom","Tomato",   (n)=> n==="Tomato"),
          S("oni","Onion",    (n)=> n==="Onion"),
          S("cil","Cilantro", (n)=> n==="Cilantro"),
          S("lim","Lime",     (n)=> n==="Lime Juice"),
          S("x1","Extra",     ()=>true),
          S("x2","Extra",     ()=>true),
          S("x3","Extra",     ()=>true),
          S("x4","Extra",     ()=>true),
        ];
      }
      if(r.kind==="ench"){
        return [
          S("tort","Tortillas", isTortilla),
          S("prot","Protein",   isProtein),
          S("sauc","Sauce",     isSauce),
          S("chee","Cheese",    isCheese),
          S("top1","Topping 1 (opt)", (n)=> isTopping(n) || isWild(n)),
          S("top2","Topping 2 (opt)", (n)=> isTopping(n) || isWild(n)),
          S("top3","Topping 3 (opt)", (n)=> isTopping(n) || isWild(n)),
          S("xtra","Extra", (n)=> isTopping(n) || isWild(n)),
        ];
      }
      if(r.kind==="chorizoTaco"){
        return [
          S("tort","Tortilla",  isTortilla),
          S("chor","Chorizo",   (n)=> n==="Chorizo"),
          S("oni","Onion",      (n)=> n==="Onion"),
          S("cil","Cilantro",   (n)=> n==="Cilantro"),
          S("x1","Extra",       ()=>true),
          S("x2","Extra",       ()=>true),
          S("x3","Extra",       ()=>true),
          S("x4","Extra",       ()=>true),
        ];
      }

      return [
        S("any1","Slot 1",()=>true), S("any2","Slot 2",()=>true), S("any3","Slot 3",()=>true), S("any4","Slot 4",()=>true),
        S("any5","Slot 5",()=>true), S("any6","Slot 6",()=>true), S("any7","Slot 7",()=>true), S("any8","Slot 8",()=>true),
      ];
    }

    function assignDishToSlots(pl, dish){
      const slots = slotDefsForRecipe(dish.recipeKey);
      const chosen = dish.tileIds
        .map(id=> pl.hand.find(t=>t.id===id))
        .filter(Boolean);

      const used = new Set();
      const slotFill = slots.map(()=> null);

      for(let si=0; si<slots.length; si++){
        const s = slots[si];
        const found = chosen.find(t => !used.has(t.id) && (isWild(t.name) || s.accept(t.name)));
        if(found){
          slotFill[si] = found;
          used.add(found.id);
        }
      }
      const leftovers = chosen.filter(t=> !used.has(t.id));
      for(let si=0; si<slots.length && leftovers.length; si++){
        if(slotFill[si]) continue;
        slotFill[si] = leftovers.shift();
      }
      return { slots, slotFill };
    }

    /* ===== Validation ===== */
    function validateDish(recipeKey, tileObjs, ctx){
      const r = recipeByKey(recipeKey);
      if(!r) return { ok:false, reason:"Unknown recipe." };

      const names = tileObjs.map(t=>t.name);
      const wildCount = names.filter(isWild).length;
      const nonWild = names.filter(n=>!isWild(n));

      function count(fn){ return nonWild.filter(fn).length; }
      function hasAny(fn){ return count(fn) > 0 || wildCount > 0; }

      /* Taco (improved): allow extra toppings; extra tiles score +1 each */
      if(r.kind==="taco"){
        if(tileObjs.length < 5 || tileObjs.length > 7) return { ok:false, reason:"Use 5‚Äì7 tiles." };

        // keep nonWild to tortilla/protein/toppings only (prevents weird rice/beans in tacos)
        const bad = nonWild.find(n => !(isTortilla(n) || isProtein(n) || isTopping(n)));
        if(bad) return { ok:false, reason:`Not allowed on tacos: ${bad}.` };

        const hasReqTortilla = nonWild.includes(r.tortilla) || (wildCount>0 && !nonWild.some(isTortilla));
        if(!hasReqTortilla) return { ok:false, reason:`Use ${r.tortilla}.` };

        if(!hasAny(isProtein)) return { ok:false, reason:"Needs 1 protein." };

        if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          if(nonWild.some(isWet)) return { ok:false, reason:"Wet toppings locked until Kitchen Open." };
        }

        const dryTopCount = nonWild.filter(isDryTopping).length;
        if(dryTopCount < RULES.tacoDryToppingsRequired && wildCount < Math.max(0, RULES.tacoDryToppingsRequired - dryTopCount)){
          return { ok:false, reason:`Needs ${RULES.tacoDryToppingsRequired} dry toppings.` };
        }

        if(count(isTortilla) > 1) return { ok:false, reason:"Only 1 tortilla." };
        if(count(isProtein) > 1) return { ok:false, reason:"Only 1 protein." };
        if(count(isCheese) > 1) return { ok:false, reason:"Only 1 cheese." };
        if(nonWild.filter(isWet).length > 1) return { ok:false, reason:"Only 1 wet topping." };

        return { ok:true };
      }

      /* Breakfast Taco (NEW): base tortilla+egg; extras allowed; bans sour cream/charro/black beans */
      if(r.kind==="breakfastTaco"){
        if(tileObjs.length < 2 || tileObjs.length > 7) return { ok:false, reason:"Use 2‚Äì7 tiles." };

        const banned = ["Sour Cream","Charro Beans","Black Beans"];
        const badBan = nonWild.find(n => banned.includes(n));
        if(badBan) return { ok:false, reason:`Not allowed on breakfast tacos: ${badBan}.` };

        const bad = nonWild.find(n => !(isTortilla(n) || n==="Egg" || isTopping(n)));
        if(bad) return { ok:false, reason:`Not allowed on breakfast tacos: ${bad}.` };

        const hasTort = nonWild.some(isTortilla) || (wildCount>0 && !nonWild.some(isTortilla));
        if(!hasTort) return { ok:false, reason:"Needs a tortilla." };

        const hasEgg = nonWild.includes("Egg") || (wildCount>0 && !nonWild.includes("Egg"));
        if(!hasEgg) return { ok:false, reason:"Needs egg." };

        if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          if(nonWild.some(isWet)) return { ok:false, reason:"Wet toppings locked until Kitchen Open." };
        }

        if(count(isTortilla) > 1) return { ok:false, reason:"Only 1 tortilla." };
        if(nonWild.filter(n=>n==="Egg").length > 1) return { ok:false, reason:"Only 1 egg." };
        if(nonWild.filter(isWet).length > 1) return { ok:false, reason:"Only 1 wet topping." };

        return { ok:true };
      }

      if(r.kind==="chorizoTaco"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Needs 4 tiles." };
        const hasTort = count(isTortilla) >= 1 || wildCount>=1;
        const hasChor = nonWild.includes("Chorizo") || wildCount>=1;
        const hasOnion = nonWild.includes("Onion") || wildCount>=1;
        const hasCil = nonWild.includes("Cilantro") || wildCount>=1;
        if(!hasTort) return { ok:false, reason:"Needs tortilla." };
        if(!hasChor) return { ok:false, reason:"Needs chorizo." };
        if(!hasOnion) return { ok:false, reason:"Needs onion." };
        if(!hasCil) return { ok:false, reason:"Needs cilantro." };
        return { ok:true };
      }

      if(r.kind==="chipsDip"){
        if(tileObjs.length !== 2) return { ok:false, reason:"Needs 2 tiles." };
        const hasChips = nonWild.includes("Tortilla Chips") || wildCount>=1;
        const hasDip = nonWild.filter(isDip).length >= 1 || wildCount>=1;
        if(!hasChips) return { ok:false, reason:"Needs Tortilla Chips." };
        if(!hasDip) return { ok:false, reason:"Needs a dip (salsa/queso/guac)." };
        return { ok:true };
      }

      if(r.kind==="pico"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Needs 4 tiles." };
        const okTom = nonWild.includes("Tomato") || wildCount>=1;
        const okOn  = nonWild.includes("Onion") || wildCount>=1;
        const okCil = nonWild.includes("Cilantro") || wildCount>=1;
        const okLim = nonWild.includes("Lime Juice") || wildCount>=1;
        if(!okTom || !okOn || !okCil || !okLim) return { ok:false, reason:"Needs Tomato, Onion, Cilantro, Lime." };
        return { ok:true };
      }

      /* Enchiladas: base 4 tiles + up to 3 extra TOPPINGS (max 7 total) */
      if(r.kind==="ench"){
        if(tileObjs.length < 4 || tileObjs.length > 7) return { ok:false, reason:"Use 4‚Äì7 tiles." };

        if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          if(nonWild.some(isWet)) return { ok:false, reason:"Wet toppings locked until Kitchen Open." };
        }

        const hasTort = nonWild.filter(isTortilla).length >= 1 || wildCount>=1;
        const hasProt = nonWild.filter(isProtein).length >= 1 || wildCount>=1;
        const hasChee = nonWild.filter(isCheese).length >= 1 || wildCount>=1;
        const hasSau  = nonWild.filter(isSauce).length >= 1 || wildCount>=1;
        if(!hasTort) return { ok:false, reason:"Needs tortillas." };
        if(!hasProt) return { ok:false, reason:"Needs protein." };
        if(!hasChee) return { ok:false, reason:"Needs shredded cheese." };
        if(!hasSau)  return { ok:false, reason:"Needs sauce." };

        if(count(isTortilla) > 1) return { ok:false, reason:"Only 1 tortilla tile." };
        if(count(isProtein) > 1) return { ok:false, reason:"Only 1 protein tile." };
        if(count(isCheese) > 1) return { ok:false, reason:"Only 1 cheese tile." };
        if(count(isSauce) > 1) return { ok:false, reason:"Only 1 sauce tile." };

        // extras must be toppings (or wild)
        const reqUsed = 4;
        const extras = Math.max(0, tileObjs.length - reqUsed);
        if(extras > 3) return { ok:false, reason:"Max 3 toppings on enchiladas." };

        const badExtra = nonWild.find(n=>{
          // if it's not one of the 4 base requirements, it must be a topping
          const isBase = isTortilla(n) || isProtein(n) || isCheese(n) || isSauce(n);
          return !isBase && !isTopping(n);
        });
        if(badExtra) return { ok:false, reason:`Not allowed as enchilada topping: ${badExtra}.` };

        return { ok:true };
      }

      return { ok:false, reason:"Unknown recipe." };
    }

    /* ===== State ===== */
    function defaultState(){
      return {
        settings:{
          accent:"#00e5ff",
          lang:"en",
          mode:"standard",
          players:4,
          difficulty:"Easy",
          handsTotal:12,
          tilesPerPlayer:16,
          decks:2,
        },
        match: null,
        ui:{
          page:"gameplay",
          currentDishId: null,
          autoScrollDish: false,
        }
      };
    }

    function persist(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    function load(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return null;
        return JSON.parse(raw);
      }catch(e){ return null; }
    }
    let state = load() || defaultState();

    /* ===== Deck / Match ===== */
    function buildDeck(decks=2){
      const tiles = [];
      for(let d=0; d<decks; d++){
        for(const [name,count] of DECK_ING_COUNTS){
          for(let i=0;i<count;i++){
            tiles.push({ id: nowId("t"), name });
          }
        }
      }
      return shuffle(tiles);
    }

    function mkPlayer(id, name, isHuman, color){
      return {
        id, name, isHuman,
        color,
        score: 0,
        servedThisHand: 0,
        hand: [],
        drafts: [],
        starterPassUsed: false,
        didDrawThisTurn: false,
        logThisHand: [],
        remixGainThisHand: 0,
        remixLossThisHand: 0,
      };
    }

    function dealInitial(m){
      const tilesPer = state.settings.tilesPerPlayer;
      for(const pid of Object.keys(m.players)){
        m.players[pid].hand = [];
        for(let i=0;i<tilesPer;i++){
          const t = m.bag.pop();
          if(!t) break;
          m.players[pid].hand.push(t);
        }
      }
    }

    function newDraftDish(recipeKey){
      const r = recipeByKey(recipeKey);
      return { id: nowId("d"), recipeKey, name: r?.name || recipeKey, pts: r?.pts || 0, tileIds: [] };
    }

    function initDraftingForP1(m){
      const p1 = m.players["P1"];
      p1.drafts = [];
      const d = newDraftDish("hardTaco");
      p1.drafts.push(d);
      state.ui.currentDishId = d.id;
    }

    function ensureUniqueCpuColors(){
      const used = new Set([state.settings.accent.toLowerCase()]);
      const pickPool = ACCENTS.map(a=>a.val.toLowerCase());
      const unique = [];

      for(const c of CPU_BASE_COLORS){
        let col = c.toLowerCase();
        if(used.has(col)){
          col = pickPool.find(x=>!used.has(x)) || col;
        }
        used.add(col);
        unique.push(col);
      }
      return unique;
    }

    function newMatch(){
      const cpuCols = ensureUniqueCpuColors();
      const pCount = state.settings.players;

      const m = {
        id: nowId("m"),
        handIndex: 1,
        kitchenOpen: false,
        bag: buildDeck(state.settings.decks),
        publicLine: [],
        players: {},
        activePid: "P1",
        servedThisTurnPts: 0,
      };

      m.players["P1"] = mkPlayer("P1","You", true, state.settings.accent);
      if(pCount >= 2) m.players["P2"] = mkPlayer("P2","Chef Mike", false, cpuCols[0]);
      if(pCount >= 3) m.players["P3"] = mkPlayer("P3","Salsa Sam", false, cpuCols[1]);
      if(pCount >= 4) m.players["P4"] = mkPlayer("P4","Queso Queen", false, cpuCols[2]);

      dealInitial(m);
      initDraftingForP1(m);

      state.match = m;
      state.ui.page = "gameplay";
      persist();
      render();
      toast("New match started.");
    }

    /* ===== Turn helpers ===== */
    function beginTurn(pid){
      const m = state.match;
      const p = m.players[pid];
      if(!p) return;
      p.didDrawThisTurn = false;
      m.servedThisTurnPts = 0;
    }

    /* ===== Draft access ===== */
    function p1(){ return state.match.players["P1"]; }
    function currentDish(){
      const pl = p1();
      return pl.drafts.find(d=>d.id===state.ui.currentDishId) || pl.drafts[0] || null;
    }
    function setCurrentDish(id){
      state.ui.currentDishId = id;
      persist();
      render();
    }

    /* ===== Qualifying drafts ===== */
    function qualifyingDraftIds(pid){
      const m = state.match;
      const pl = m.players[pid];
      const ctx = { kitchenOpen: m.kitchenOpen };
      return pl.drafts
        .filter(d=>{
          const tiles = d.tileIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
          return validateDish(d.recipeKey, tiles, ctx).ok;
        })
        .map(d=>d.id);
    }

    /* ===== Publish (Order Up) ===== */
    function publishDrafts(pid, draftIds){
      const m = state.match;
      const pl = m.players[pid];
      const ctx = { kitchenOpen: m.kitchenOpen };

      const drafts = pl.drafts.filter(d=> draftIds.includes(d.id));
      if(!drafts.length) return { ok:false, msg:"No qualifying dish." };

      const resolved = drafts.map(d=>{
        const tiles = d.tileIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
        return { d, tiles, v: validateDish(d.recipeKey, tiles, ctx) };
      });

      const bad = resolved.find(x=>!x.v.ok);
      if(bad) return { ok:false, msg:`${bad.d.name}: ${bad.v.reason}` };

      let nonStarterPts = 0;

      for(const x of resolved){
        const lunchHit = hasDoubleLettuce(x.tiles);
        if(lunchHit) toast("Lauren‚Äôs Lunch", ACH.laurensLunchMs);

        const pts = computeDishPoints(x.d.recipeKey, x.tiles, false); // original play
        const pub = {
          id: nowId("pub"),
          owner: pid,
          ownerName: pl.name,
          recipeKey: x.d.recipeKey,
          name: x.d.name,
          points: pts,
          tiles: x.tiles.map(t=>({id:t.id, name:t.name})),
          isRemix: false,
          from: null
        };
        m.publicLine.push(pub);

        for(const t of x.tiles){
          const idx = pl.hand.findIndex(h=>h.id===t.id);
          if(idx>=0) pl.hand.splice(idx,1);
        }

        pl.score += pts;
        pl.servedThisHand += pts;
        pl.logThisHand.push({ type:"serve", name:x.d.name, points: pts });

        if(!m.kitchenOpen){
          if(x.d.recipeKey === RULES.starterPassDishKey && !pl.starterPassUsed){
            pl.starterPassUsed = true;
          }else{
            nonStarterPts += pts;
          }
        }else{
          nonStarterPts += pts;
        }
      }

      m.servedThisTurnPts += nonStarterPts;
      if(!m.kitchenOpen && m.servedThisTurnPts >= 10){
        m.kitchenOpen = true;
        toast("üî• Kitchen Open!");
      }

      pl.drafts = pl.drafts.filter(d=> !draftIds.includes(d.id));
      if(pid==="P1" && pl.drafts.length===0){
        const nd = newDraftDish("hardTaco");
        pl.drafts.push(nd);
        state.ui.currentDishId = nd.id;
      }else if(pid==="P1"){
        if(!pl.drafts.some(d=>d.id===state.ui.currentDishId)){
          state.ui.currentDishId = pl.drafts[0]?.id || null;
        }
      }

      return { ok:true };
    }

    /* ===== One draw per turn (hard gate) ===== */
    function drawTile(pid){
      const m = state.match;
      const pl = m.players[pid];
      if(m.activePid !== pid) return { ok:false, msg:"Not your turn." };

      if(pl.didDrawThisTurn){
        return { ok:false, msg:"Only one draw per turn." };
      }
      if(m.bag.length === 0){
        return { ok:false, msg:"No tiles left." };
      }

      const idx = randInt(m.bag.length);
      const t0 = m.bag.splice(idx, 1)[0];

      pl.hand.push(t0);
      pl.didDrawThisTurn = true;
      return { ok:true, msg:`Drew: ${t0.name}`, tile: t0 };
    }

    /* ===== End turn ===== */
    function endTurn(pid){
      const m = state.match;
      if(m.activePid !== pid) return;

      const order = Object.keys(m.players);
      const i = order.indexOf(pid);
      const next = order[(i+1)%order.length];
      m.activePid = next;
      beginTurn(next);

      persist();
      render();

      if(next !== "P1"){
        setTimeout(()=> cpuAct(next), cpuDelayMs());
      }else{
        toast("Your turn.");
      }
    }

    function cpuDelayMs(){
      const diff = state.settings.difficulty || "Easy";
      const base = DIFF_DELAY_MS[diff] ?? 2200;
      return Math.max(450, base + randInt(220));
    }

    function cpuAct(pid){
      const m = state.match;
      const pl = m.players[pid];
      if(!pl || pl.isHuman) return;

      const ctx = { kitchenOpen: m.kitchenOpen };
      const tryKeys = ["ench","pico","breakfastTaco","hardTaco","softTaco","chorizoTaco","chipsDip"];
      let made = false;

      function pick(name){
        const t = pl.hand.find(x=>x.name===name) || pl.hand.find(x=>x.name==="Grocery Run");
        return t?.id || null;
      }
      function anyFrom(names){
        for(const n of names){
          const id = pl.hand.find(x=>x.name===n)?.id;
          if(id) return id;
        }
        return pl.hand.find(x=>x.name==="Grocery Run")?.id || null;
      }

      const draft = newDraftDish("hardTaco");

      for(const rk of tryKeys){
        const r = recipeByKey(rk);
        let ids = [];

        if(r.kind==="chipsDip"){
          const chips = pl.hand.find(x=>x.name==="Tortilla Chips")?.id || pick("Tortilla Chips");
          const dip = anyFrom(["Salsa Roja","Salsa Verde","Guacamole","Queso"]);
          if(chips && dip) ids = [chips,dip];
        }else if(r.kind==="pico"){
          const tom = pick("Tomato"), oni = pick("Onion"), cil = pick("Cilantro"), lim = pick("Lime Juice");
          if(tom && oni && cil && lim) ids = [tom,oni,cil,lim];
        }else if(r.kind==="ench"){
          const tort = anyFrom(["Flour Tortillas","Corn Tortillas"]);
          const prot = anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]);
          const chee = anyFrom(["Shredded yellow Cheese","Shredded white cheese"]);
          const sauc = anyFrom(["Salsa Roja","Salsa Verde"]);
          if(tort && prot && chee && sauc){
            ids = [tort,prot,chee,sauc];
            // optional toppings up to +2 for CPU
            const tops = ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Avocado"];
            for(const n of tops){
              if(ids.length>=6) break;
              const id = pl.hand.find(x=>x.name===n)?.id;
              if(id) ids.push(id);
            }
          }
        }else if(r.kind==="breakfastTaco"){
          const tort = anyFrom(["Flour Tortillas","Corn Tortillas"]);
          const egg  = pick("Egg");
          if(tort && egg){
            ids = [tort, egg];
            const tops = ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Avocado","Shredded yellow Cheese","Shredded white cheese"];
            for(const n of tops){
              if(ids.length>=5) break;
              const id = pl.hand.find(x=>x.name===n)?.id;
              if(id) ids.push(id);
            }
          }
        }else if(r.kind==="chorizoTaco"){
          const tort = anyFrom(["Flour Tortillas","Corn Tortillas"]);
          const chor = pick("Chorizo"), oni = pick("Onion"), cil = pick("Cilantro");
          if(tort && chor && oni && cil) ids = [tort,chor,oni,cil];
        }else if(r.kind==="taco"){
          const tort = pick(r.tortilla);
          const prot = anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]);
          if(tort && prot){
            ids.push(tort,prot);
            const tops = ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Avocado","Shredded yellow Cheese","Shredded white cheese"];
            for(const n of tops){
              if(ids.length>=5) break;
              const id = pl.hand.find(x=>x.name===n)?.id;
              if(id) ids.push(id);
            }
            // optional extra topping (scores +1)
            const extra = pl.hand.find(x=>x.name==="Lettuce")?.id;
            if(extra && ids.length<7) ids.push(extra);
          }
        }

        if(ids.length){
          const tiles = ids.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
          const v = validateDish(rk, tiles, ctx);
          if(v.ok){
            draft.recipeKey = rk;
            draft.name = r.name;
            draft.pts = r.pts;
            draft.tileIds = ids;
            pl.drafts = [draft];
            const res = publishDrafts(pid, [draft.id]);
            if(res.ok){
              made = true;
              toast(`${pl.name}: ${draft.name}`, 1400);
              break;
            }
          }
        }
      }

      if(!made){
        drawTile(pid);
        toast(`${pl.name} drew a tile.`, 1100);
      }

      endTurn(pid);
    }

    /* ===== Dish editing (P1) ===== */
    function toggleHandTileForDish(tileId){
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      const pl = p1();
      const dish = currentDish();
      if(!dish) return;

      const tile = pl.hand.find(t=>t.id===tileId);
      if(!tile) return;

      const inDish = dish.tileIds.includes(tileId);
      if(inDish){
        dish.tileIds = dish.tileIds.filter(id=>id!==tileId);
        state.ui.autoScrollDish = true;
        persist(); render();
        return;
      }

      const r = recipeByKey(dish.recipeKey);
      const ctx = { kitchenOpen: m.kitchenOpen };

      if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen && isWet(tile.name)){
        toast("Wet toppings locked until Kitchen Open.");
        return;
      }

      // max tiles per dish (by kind)
      const curCount = dish.tileIds.length;
      const maxByKind = (r.kind==="ench" || r.kind==="taco" || r.kind==="breakfastTaco") ? 7 :
                        (r.kind==="pico" || r.kind==="chorizoTaco") ? 4 :
                        (r.kind==="chipsDip") ? 2 : 7;
      if(curCount >= maxByKind){
        toast(`Max ${maxByKind} tiles.`);
        return;
      }

      if(r.kind==="taco"){
        const curNames = dish.tileIds.map(id => pl.hand.find(t=>t.id===id)?.name).filter(Boolean);

        // prevent weird non-topping add-ons
        if(!(isTortilla(tile.name) || isProtein(tile.name) || isTopping(tile.name) || isWild(tile.name))){
          toast("Not allowed on tacos.");
          return;
        }

        const hasTort = curNames.some(isTortilla);
        const hasProt = curNames.some(isProtein);
        const hasChee = curNames.some(isCheese);
        const hasWet  = curNames.some(isWet);

        if(isTortilla(tile.name) && hasTort){ toast("Only 1 tortilla."); return; }
        if(isProtein(tile.name) && hasProt){ toast("Only 1 protein."); return; }
        if(isCheese(tile.name) && hasChee){ toast("Only 1 cheese."); return; }
        if(isWet(tile.name) && hasWet){ toast("Only 1 wet topping."); return; }
      }

      if(r.kind==="breakfastTaco"){
        const banned = ["Sour Cream","Charro Beans","Black Beans"];
        if(banned.includes(tile.name)){
          toast(`Not allowed on breakfast tacos: ${tile.name}.`);
          return;
        }

        if(!(isTortilla(tile.name) || tile.name==="Egg" || isTopping(tile.name) || isWild(tile.name))){
          toast("Not allowed on breakfast tacos.");
          return;
        }

        const curNames = dish.tileIds.map(id => pl.hand.find(t=>t.id===id)?.name).filter(Boolean);
        const hasTort = curNames.some(isTortilla);
        const eggCount = curNames.filter(n=>n==="Egg").length;
        const wetCount = curNames.filter(isWet).length;

        if(isTortilla(tile.name) && hasTort){ toast("Only 1 tortilla."); return; }
        if(tile.name==="Egg" && eggCount>=1){ toast("Only 1 egg."); return; }
        if(isWet(tile.name) && wetCount>=1){ toast("Only 1 wet topping."); return; }
      }

      if(r.kind==="chipsDip" && dish.tileIds.length >= 2){ toast("Chips & Dip is 2 tiles."); return; }
      if(r.kind==="pico" && dish.tileIds.length >= 4){ toast("Pico is 4 tiles."); return; }
      if(r.kind==="chorizoTaco" && dish.tileIds.length >= 4){ toast("Chorizo Taco is 4 tiles."); return; }

      if(r.kind==="ench"){
        // allow up to 7; keep base constraints tight
        const curNames = dish.tileIds.map(id => pl.hand.find(t=>t.id===id)?.name).filter(Boolean);
        const counts = {
          tort: curNames.filter(isTortilla).length,
          prot: curNames.filter(isProtein).length,
          chee: curNames.filter(isCheese).length,
          sauc: curNames.filter(isSauce).length,
        };

        if(isTortilla(tile.name) && counts.tort>=1){ toast("Only 1 tortilla tile."); return; }
        if(isProtein(tile.name) && counts.prot>=1){ toast("Only 1 protein tile."); return; }
        if(isCheese(tile.name) && counts.chee>=1){ toast("Only 1 cheese tile."); return; }
        if(isSauce(tile.name) && counts.sauc>=1){ toast("Only 1 sauce tile."); return; }

        // once base is met, extras must be toppings (keeps it clean)
        const baseMet = (counts.tort>=1 && counts.prot>=1 && counts.chee>=1 && counts.sauc>=1);
        if(baseMet){
          const isBase = isTortilla(tile.name) || isProtein(tile.name) || isCheese(tile.name) || isSauce(tile.name);
          if(!isBase && !(isTopping(tile.name) || isWild(tile.name))){
            toast("Only toppings allowed as enchilada extras.");
            return;
          }
          const extrasNow = Math.max(0, (dish.tileIds.length + 1) - 4);
          if(extrasNow > 3){
            toast("Max 3 toppings on enchiladas.");
            return;
          }
        }
      }

      dish.tileIds.push(tileId);
      state.ui.autoScrollDish = true;
      persist();
      render();
    }

    function clearCurrentDish(){
      const d = currentDish();
      if(!d) return;
      d.tileIds = [];
      state.ui.autoScrollDish = true;
      persist(); render();
    }
    function newDish(){
      const pl = p1();
      const d = newDraftDish("hardTaco");
      pl.drafts.push(d);
      setCurrentDish(d.id);
      toast("New dish added.");
    }
    function removeCurrentDish(){
      const pl = p1();
      if(pl.drafts.length <= 1){
        clearCurrentDish();
        toast("Cleared.");
        return;
      }
      const id = state.ui.currentDishId;
      pl.drafts = pl.drafts.filter(d=>d.id!==id);
      setCurrentDish(pl.drafts[0].id);
      toast("Dish removed.");
    }
    function updateCurrentDishRecipe(recipeKey){
      const d = currentDish();
      if(!d) return;
      const r = recipeByKey(recipeKey);
      d.recipeKey = recipeKey;
      d.name = r?.name || recipeKey;
      d.pts = r?.pts || 0;
      d.tileIds = [];
      state.ui.autoScrollDish = true;
      persist(); render();
    }

    /* ===== Auto-scroll to next empty slot ===== */
    function scrollDishToNextEmpty(){
      const strip = $("dishCarousel");
      if(!strip) return;
      const empty = strip.querySelector(".slotValue.slotEmpty");
      if(!empty) return;
      const card = empty.closest(".slotCard");
      if(!card) return;
      card.scrollIntoView({ behavior:"smooth", inline:"center", block:"nearest" });
    }

    /* ===== Draw Modal (Tile-back Grid) ===== */
    let modalMode = null;

    function bestFitCols(n){
      if(n >= 25) return 5;
      const c = Math.ceil(Math.sqrt(n));
      return Math.max(1, Math.min(5, c));
    }

    function revealPickedTile(el, tileObj){
      if(!el || !tileObj) return;
      const cat = ingredientCategory(tileObj.name);
      el.classList.add("spin","revealed",`cat-${cat}`);
      // swap content near the midpoint of the spin
      setTimeout(()=>{
        el.querySelector(".tileBackInner").innerHTML = `
          <div class="tileFrontName">${escapeHtml(tileObj.name)}</div>
          <div class="tileFrontCat">${escapeHtml(categoryLabel(cat))}</div>
        `;
        el.querySelector(".tileBackMark")?.remove?.();
      }, 340);
    }

    function openDrawModal(){
      const m = state.match;
      const pl = p1();
      const myTurn = (m.activePid === "P1");

      if(!myTurn){ toast("Not your turn."); return; }
      if(pl.didDrawThisTurn){ toast("Only one draw per turn."); return; }

      const total = m.bag.length;
      if(total === 0){
        openModal(
          t("drawTile"),
          `<div class="muted">No more tiles to choose from.</div>`,
          [{ text: t("close"), className:"primary", onClick: closeModal }]
        );
        return;
      }

      const shown = Math.min(25, total);
      const cols = bestFitCols(shown);
      const appName = escapeHtml(getAppName());

      const meta = `
        <div class="drawMeta">
          <span class="pill">Tiles Remaining <span class="mono">${total}</span></span>
          ${total > 25 ? `<span class="pill muted">Showing <span class="mono">25</span></span>` : ``}
        </div>
        <div class="muted small">Pick any tile. (The draw is random, regardless of choice.)</div>
      `;

      const grid = `
        <div class="drawGrid" id="drawGrid" style="grid-template-columns: repeat(${cols}, 1fr);">
          ${Array.from({length: shown}).map((_,i)=>`
            <div class="tileBack" data-draw-pick="${i}">
              <div class="tileBackNum">${i+1}/${total}</div>
              <div class="tileBackInner">
                <div class="tileBackBrand">${appName}</div>
                <div class="tileBackMark">TILE BACK ‚Ä¢ ${escapeHtml(VERSION)}</div>
              </div>
            </div>
          `).join("")}
        </div>
      `;

      openModal(
        t("drawTile"),
        meta + grid,
        [{ text: t("cancel"), className:"ghost", onClick: closeModal }]
      );

      modalMode = "draw";

      $("modalBody").onclick = (e)=>{
        if(modalMode !== "draw") return;
        const pick = e.target.closest("[data-draw-pick]");
        if(!pick) return;

        const gridEl = $("drawGrid");
        if(gridEl) gridEl.classList.add("busy");
        pick.classList.add("tileBackSel");

        modalMode = "draw_busy";

        const res = drawTile("P1");
        if(!res.ok){
          toast(res.msg);
          closeModal();
          persist(); render();
          return;
        }

        // reveal animation inside modal
        revealPickedTile(pick, res.tile);

        persist();
        render();

        // keep modal up long enough to watch the flip
        setTimeout(()=>{
          closeModal();
          toast(res.msg);
        }, 920);
      };
    }

    /* ===== Pages ===== */
    function setPage(p){
      state.ui.page = p;
      persist();
      render();
    }
    function setNavActive(btnId){
      ["navGame","navPrep","navScores","navSettings"].forEach(id=>{
        $(id).classList.toggle("active", id===btnId);
      });
    }
    $("navGame").onclick = ()=> setPage("gameplay");
    $("navPrep").onclick = ()=> setPage("prep");
    $("navScores").onclick = ()=> setPage("scores");
    $("navSettings").onclick = ()=> setPage("settings");

    /* ===== Buttons ===== */
    $("btnNewMatchTop").onclick = ()=>{
      openModal(
        "New Match",
        "Start a fresh match? This overwrites current match state.",
        [
          { text:"Cancel", className:"ghost", onClick: closeModal },
          { text:"Start", className:"primary", onClick: ()=>{ closeModal(); newMatch(); } }
        ]
      );
    };

    $("btnPrep").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      setPage("prep");
    };

    $("btnOrderUp").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      const ids = qualifyingDraftIds("P1");
      if(!ids.length){ toast("No qualifying dish."); return; }
      const res = publishDrafts("P1", ids);
      if(!res.ok){ toast(res.msg); return; }
      persist(); render();
      toast("Order up!");
    };

    $("btnEndTurn").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      endTurn("P1");
    };

    $("btnDraw").onclick = openDrawModal;

    $("btnOrderUpFromPrep").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      const ids = qualifyingDraftIds("P1");
      if(!ids.length){ toast("No qualifying dish."); return; }
      const res = publishDrafts("P1", ids);
      if(!res.ok){ toast(res.msg); return; }
      setPage("gameplay");
      toast("Order up!");
    };

    $("btnNewDish").onclick = newDish;
    $("btnClearDish").onclick = clearCurrentDish;
    $("btnRemoveDish").onclick = removeCurrentDish;
    $("selRecipe").onchange = ()=> updateCurrentDishRecipe($("selRecipe").value);

    $("handTiles").addEventListener("click",(e)=>{
      const el = e.target.closest("[data-htile]");
      if(!el) return;
      toggleHandTileForDish(el.getAttribute("data-htile"));
    });

    $("dishCarousel").addEventListener("click",(e)=>{
      const card = e.target.closest(".slotCard");
      if(!card) return;
      const tileId = card.getAttribute("data-tile-id");
      if(!tileId) return;

      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      const pl = p1();
      const d = currentDish();
      if(!d) return;

      d.tileIds = d.tileIds.filter(id => id !== tileId);
      state.ui.autoScrollDish = true;
      persist(); render();
      toast("Removed ingredient.");
    });

    /* ===== Settings ===== */
    function fillSettings(){
      $("selDifficulty").innerHTML = DIFFS.map(d=> `<option value="${d}">${d}</option>`).join("");
      $("selDifficulty").value = state.settings.difficulty;

      $("selAccent").innerHTML = ACCENTS.map(a=> `<option value="${a.val}">${a.name} (${a.val})</option>`).join("");
      $("selAccent").value = state.settings.accent;

      $("selRecipe").innerHTML = RECIPES.map(r=> `<option value="${r.key}">${r.name} (${r.pts} pts)</option>`).join("");

      $("selMode").value = state.settings.mode;
      $("selPlayers").value = String(state.settings.players);
      $("inpHands").value = state.settings.handsTotal;
      $("inpTilesPerPlayer").value = state.settings.tilesPerPlayer;
      $("selDecks").value = String(state.settings.decks);
      $("selLang").value = state.settings.lang;
    }

    $("selMode").onchange = ()=>{ state.settings.mode = $("selMode").value; persist(); render(); toast("Mode updated."); };
    $("selPlayers").onchange = ()=>{ state.settings.players = parseInt($("selPlayers").value,10); persist(); render(); toast("Players updated."); };
    $("selDifficulty").onchange = ()=>{ state.settings.difficulty = $("selDifficulty").value; persist(); render(); };
    $("inpHands").onchange = ()=>{ state.settings.handsTotal = Math.max(1, Math.min(12, parseInt($("inpHands").value,10) || 12)); persist(); render(); };
    $("inpTilesPerPlayer").onchange = ()=>{ state.settings.tilesPerPlayer = Math.max(8, Math.min(24, parseInt($("inpTilesPerPlayer").value,10) || 16)); persist(); render(); };
    $("selDecks").onchange = ()=>{ state.settings.decks = parseInt($("selDecks").value,10) || 2; persist(); render(); };

    $("selAccent").onchange = ()=>{
      state.settings.accent = $("selAccent").value;
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      if(state.match){
        const cpuCols = ensureUniqueCpuColors();
        if(state.match.players["P2"]) state.match.players["P2"].color = cpuCols[0];
        if(state.match.players["P3"]) state.match.players["P3"].color = cpuCols[1];
        if(state.match.players["P4"]) state.match.players["P4"].color = cpuCols[2];
        state.match.players["P1"].color = state.settings.accent;
      }

      persist(); render();
    };

    $("selLang").onchange = ()=>{ state.settings.lang = $("selLang").value; persist(); render(); };

    /* ===== Rendering ===== */
    function phaseText(){
      const m = state.match;
      if(m.kitchenOpen) return { title:"Kitchen Open", desc:"Remix is enabled. Wet toppings allowed." };
      if(m.publicLine.length > 0) return { title:"Appetizers Out", desc:"Build toward 10+ points in a single turn to open the kitchen." };
      return { title:"Not Seated Yet", desc:"Serve 10+ points in one turn to open the kitchen." };
    }

    function playerColor(pid){
      const m = state.match;
      return m.players[pid]?.color || "#ffffff";
    }

    function renderPublicLine(){
      const m = state.match;
      const el = $("publicLine");

      $("lineSummary").textContent = `${m.publicLine.length} dish${m.publicLine.length===1?"":"es"}`;

      if(!m.publicLine.length){
        el.innerHTML = `<div class="muted small">No dishes in the window yet.</div>`;
        return;
      }

      const groups = groupBy(m.publicLine, d=> d.name);
      el.innerHTML = Object.entries(groups).map(([menuItem, dishes])=>{
        const total = dishes.reduce((t,d)=>t+d.points,0);
        return `
          <div class="pubGroup">
            <div class="pubGroupTitle">
              <div>${escapeHtml(menuItem)}</div>
              <span class="badge">Total <span class="mono">${total}</span></span>
            </div>
            ${dishes.map(d=>{
              const col = playerColor(d.owner);
              const tintA = hexToRgba(col,.28);
              const tiles = d.tiles.map(ti=>{
                const cat = ingredientCategory(ti.name);
                const wet = isWet(ti.name) ? "wet" : "";
                const wild = isWild(ti.name) ? "wild" : "";
                return `<span class="tile ${wet} ${wild} cat-${cat}">${escapeHtml(ti.name)}</span>`;
              }).join("");
              return `
                <div class="pubDishRow" style="--tintA:${tintA};">
                  <div class="pubDishMeta">
                    <div>${escapeHtml(d.ownerName)}${d.isRemix ? " ‚Ä¢ Remix" : ""}</div>
                    <span class="badge">${d.points} pts</span>
                  </div>
                  <div class="tiles" style="margin-top:8px;">${tiles}</div>
                </div>
              `;
            }).join("")}
          </div>
        `;
      }).join("");
    }

    function renderPrep(){
      const m = state.match;
      const pl = p1();
      const d = currentDish();
      const myTurn = (m.activePid==="P1");

      $("prepTurnBadge").textContent = myTurn ? "Your Turn" : `${m.players[m.activePid].name}'s Turn`;
      $("handCountHint").textContent = `${pl.hand.length} tiles`;

      $("btnDraw").textContent = t("drawTile");
      $("btnDraw").disabled = !myTurn || pl.didDrawThisTurn || m.bag.length===0;
      if(!pl.didDrawThisTurn && myTurn && m.bag.length>0) $("btnDraw").classList.add("pulse");
      else $("btnDraw").classList.remove("pulse");

      const q = qualifyingDraftIds("P1");
      const canOrder = myTurn && q.length>0;
      $("btnOrderUpFromPrep").disabled = !canOrder;
      $("btnOrderUpFromPrep").classList.toggle("pulseOrder", canOrder);
      $("btnOrderUpFromPrep").textContent = t("orderUp");

      if(d){
        $("selRecipe").value = d.recipeKey;

        const ctx = { kitchenOpen: m.kitchenOpen };
        const chosenTiles = d.tileIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(d.recipeKey, chosenTiles, ctx);
        const previewPts = computeDishPoints(d.recipeKey, chosenTiles, false);
        $("dishMeta").textContent = `${d.name} ‚Ä¢ ${previewPts} pts`;
      }else{
        $("dishMeta").textContent = "‚Äî";
      }

      const grouped = groupBy(pl.hand, t => ingredientCategory(t.name));
      const order = ["tortilla","protein","cheese","wet","drytop","wild","other"];

      $("handTiles").innerHTML = `
        <div class="handGroups">
          ${order.filter(cat => (grouped[cat]||[]).length).map(cat=>{
            const tiles = grouped[cat];
            return `
              <div class="handGroup">
                <div class="handGroupTitle">
                  <span>${escapeHtml(categoryLabel(cat))}</span>
                  <span class="count">${tiles.length}</span>
                </div>
                <div class="tiles">
                  ${tiles.map(ti=>{
                    const inDish = d?.tileIds.includes(ti.id);
                    const wet = isWet(ti.name) ? "wet" : "";
                    const wild = isWild(ti.name) ? "wild" : "";
                    return `
                      <span class="tile ${inDish?"sel":""} ${wet} ${wild} cat-${cat}" data-htile="${escapeHtml(ti.id)}">
                        ${escapeHtml(ti.name)}
                      </span>
                    `;
                  }).join("")}
                </div>
              </div>
            `;
          }).join("")}
        </div>
      `;

      const car = $("dishCarousel");
      if(!d){
        car.innerHTML = `<div class="muted small">No draft selected.</div>`;
        $("dishHint").textContent = "";
      }else{
        const { slots, slotFill } = assignDishToSlots(pl, d);
        car.innerHTML = slots.map((s, i)=>{
          const tObj = slotFill[i];
          const filled = !!tObj;
          const cat = filled ? ingredientCategory(tObj.name) : "";
          const txt = filled ? escapeHtml(tObj.name) : "Empty";
          return `
            <div class="slotCard" data-slot-idx="${i}" ${filled ? `data-tile-id="${escapeHtml(tObj.id)}"` : ""}>
              <div class="slotLabel">${escapeHtml(s.label)}</div>
              <div class="slotValue ${filled ? "slotFilled" : "slotEmpty"} ${filled ? `cat-${cat}` : ""}">
                ${txt}
              </div>
              ${filled ? `<div class="muted2 small" style="margin-top:8px;">${escapeHtml(categoryLabel(cat))}</div>` : ""}
            </div>
          `;
        }).join("");

        const ctx = { kitchenOpen: m.kitchenOpen };
        const chosenTiles = d.tileIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(d.recipeKey, chosenTiles, ctx);
        $("dishHint").textContent = v.ok ? "‚úÖ Qualifies for Order Up!" : `‚ö†Ô∏è ${v.reason}`;

        if(state.ui.autoScrollDish){
          state.ui.autoScrollDish = false;
          persist();
          setTimeout(scrollDishToNextEmpty, 0);
        }
      }
    }

    function renderScores(){
      const m = state.match;
      const pl = p1();

      $("scoreModePill").textContent = state.settings.mode==="campaign" ? "Campaign" : "Standard";
      $("scoreCurrent").textContent = `Current: ${pl.score}`;
      $("scoreServedMuted").textContent = `Served this hand: ${pl.servedThisHand}`;

      const players = Object.values(m.players);

      $("scoreList").innerHTML = players.map(p=>{
        const col = playerColor(p.id);
        const tintA = hexToRgba(col,.18);

        const dishLines = (p.logThisHand || []).map(ev=>{
          const extra = ev.type==="remix" ? ` <span class="muted2 small">(from ${escapeHtml(ev.from || "‚Äî")})</span>` : "";
          return `<div class="row sp" style="gap:12px; margin-top:8px;">
            <div style="font-weight:900;">${escapeHtml(ev.name)}${extra}</div>
            <span class="badge">${ev.points}</span>
          </div>`;
        }).join("") || `<div class="muted small">No dishes served yet this hand.</div>`;

        const net = (p.remixGainThisHand || 0) - (p.remixLossThisHand || 0);
        const netTxt = net === 0 ? "0" : (net > 0 ? `+${net}` : `${net}`);

        return `
          <details class="acc" style="margin-top:12px; background: rgba(255,255,255,.03);">
            <summary>
              <span>${escapeHtml(p.name)}${p.id==="P1" ? " (You)" : ""}</span>
              <span class="badge" style="background: rgba(0,0,0,.30);">Score ${p.score}</span>
            </summary>
            <div class="accBody" style="position:relative; overflow:hidden;">
              <div style="position:absolute; inset:0; background: linear-gradient(135deg, ${tintA}, transparent 70%); opacity:.9; pointer-events:none;"></div>
              <div style="position:relative; z-index:1;">
                <div class="row wrap" style="gap:10px; margin-top:6px;">
                  <span class="pill">Served: ${p.servedThisHand}</span>
                  <span class="pill">Remix Net: ${netTxt}</span>
                </div>
                <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>
                ${dishLines}
              </div>
            </div>
          </details>
        `;
      }).join("");
    }

    function renderGameplay(){
      const m = state.match;
      const myTurn = (m.activePid==="P1");

      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));
      $("verPill").textContent = VERSION;

      $("navGame").querySelector(".tx").textContent = t("gameplay");
      $("navPrep").querySelector(".tx").textContent = t("prep");
      $("navScores").querySelector(".tx").textContent = t("scores");
      $("navSettings").querySelector(".tx").textContent = t("settings");

      $("btnPrep").textContent = t("prepDish");
      $("btnEndTurn").textContent = t("endTurn");

      $("tilesRemainBadge").textContent = `Tiles Remaining ${m.bag.length}`;
      $("kitchenBadge").textContent = m.kitchenOpen ? "Kitchen Open" : "Kitchen Closed";
      $("handBadge").textContent = `Hand ${m.handIndex}/${state.settings.handsTotal}`;
      $("turnBadge").textContent = myTurn ? "Your Turn" : `${m.players[m.activePid].name}'s Turn`;

      const ph = phaseText();
      $("phaseTitle").textContent = ph.title;
      $("phaseDesc").textContent = ph.desc;

      const q = qualifyingDraftIds("P1");
      const canOrder = myTurn && q.length>0;
      $("btnOrderUp").textContent = t("orderUp");
      $("btnOrderUp").disabled = !canOrder;
      $("btnOrderUp").classList.toggle("pulseOrder", canOrder);

      $("btnPrep").disabled = !myTurn;
      $("btnEndTurn").disabled = !myTurn;

      renderPublicLine();
    }

    function render(){
      if(!state.match) newMatch();

      ["pageGameplay","pagePrep","pageScores","pageSettings"].forEach(id=> $(id).classList.remove("on"));
      if(state.ui.page==="gameplay"){ $("pageGameplay").classList.add("on"); setNavActive("navGame"); }
      if(state.ui.page==="prep"){ $("pagePrep").classList.add("on"); setNavActive("navPrep"); }
      if(state.ui.page==="scores"){ $("pageScores").classList.add("on"); setNavActive("navScores"); }
      if(state.ui.page==="settings"){ $("pageSettings").classList.add("on"); setNavActive("navSettings"); }

      fillSettings();
      renderGameplay();
      renderPrep();
      renderScores();
    }

    /* ===== Init ===== */
    function boot(){
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      if(state.match){
        state.match.players["P1"].color = state.settings.accent;
        const cpuCols = ensureUniqueCpuColors();
        if(state.match.players["P2"]) state.match.players["P2"].color = cpuCols[0];
        if(state.match.players["P3"]) state.match.players["P3"].color = cpuCols[1];
        if(state.match.players["P4"]) state.match.players["P4"].color = cpuCols[2];
      }

      if(state.match) beginTurn(state.match.activePid);
      render();
    }

    boot();
  </script>
</body>
</html>
