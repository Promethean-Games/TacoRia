<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Taco Ria ‚Äî Rummikub Variant</title>
  <meta name="theme-color" content="#000000" />
  <style>
    :root{
      --bg:#000;
      --card:#0b0b0b;
      --card2:#111;
      --text:#f4f4f5;
      --muted:#a1a1aa;
      --border:rgba(255,255,255,.14);
      --accent:#00e5ff;
      --accent2:#ffcc00;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --radius:18px;
      --shadow: 0 16px 38px rgba(0,0,0,.55);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 900px at 20% 0%, rgba(0,229,255,.10), transparent 45%),
                  radial-gradient(900px 700px at 90% 10%, rgba(255,204,0,.08), transparent 45%),
                  var(--bg);
      color:var(--text);
      overflow-x:hidden;
    }
    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
      padding-bottom:78px; /* footer nav */
    }
    header{
      padding:14px 14px 10px;
      position:sticky; top:0;
      background: linear-gradient(to bottom, rgba(0,0,0,.92), rgba(0,0,0,.65));
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--border);
      z-index:50;
    }
    .hrow{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .title{
      font-weight:1000; letter-spacing:.3px;
      font-size:18px; line-height:1.1;
    }
    .subtitle{
      margin-top:6px;
      color:var(--muted);
      font-size:12px;
      display:flex; flex-wrap:wrap; gap:10px;
    }
    .pill{
      border:1px solid var(--border);
      border-radius:999px;
      padding:4px 8px;
      background: rgba(255,255,255,.04);
    }
    .mono{font-family:var(--mono)}
    main{flex:1; padding:12px 14px 18px; max-width:980px; width:100%; margin:0 auto;}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      padding:12px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    @media (min-width: 840px){
      .grid.two{grid-template-columns: 1.1fr .9fr;}
      .grid.twoEven{grid-template-columns: 1fr 1fr;}
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .spacer{flex:1}
    button, select, input{
      font:inherit;
      color:var(--text);
      background: rgba(255,255,255,.04);
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      outline:none;
    }
    button{font-weight:900; cursor:pointer;}
    button.primary{
      background: linear-gradient(180deg, rgba(0,229,255,.20), rgba(0,229,255,.08));
      border-color: rgba(0,229,255,.35);
    }
    button.danger{
      background: linear-gradient(180deg, rgba(239,68,68,.18), rgba(239,68,68,.08));
      border-color: rgba(239,68,68,.35);
    }
    button.ghost{
      background: rgba(255,255,255,.02);
    }
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
    }
    .btnTiny{
      padding:7px 10px;
      border-radius:12px;
      font-size:12px;
      font-weight:900;
    }
    .hint{color:var(--muted); font-size:12px; margin-top:6px;}
    .hr{height:1px; background:var(--border); margin:10px 0;}
    .badge{
      padding:4px 8px;
      border-radius:999px;
      font-size:12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      font-weight:900;
    }
    .good{color:var(--good)}
    .warn{color:var(--warn)}
    .bad{color:var(--bad)}
    .screen{display:none}
    .screen.on{display:block}
    footer.nav{
      position:fixed; left:0; right:0; bottom:0;
      background: rgba(0,0,0,.78);
      border-top:1px solid var(--border);
      backdrop-filter: blur(10px);
      z-index:60;
      padding:10px 10px calc(10px + env(safe-area-inset-bottom));
    }
    .navRow{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      max-width:980px; margin:0 auto;
    }
    .navBtn{
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap:4px;
      padding:10px 8px;
      border-radius:16px;
      font-size:12px;
      font-weight:1000;
    }
    .navBtn.on{
      border-color: rgba(0,229,255,.45);
      background: rgba(0,229,255,.08);
    }

    /* Accordion */
    details.acc{
      border:1px solid var(--border);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    details.acc + details.acc{margin-top:10px;}
    details.acc summary{
      list-style:none;
      cursor:pointer;
      padding:12px;
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:1000;
    }
    details.acc summary::-webkit-details-marker{display:none}
    .sumHint{color:var(--muted); font-size:12px; font-weight:800}
    .chev{margin-left:auto; opacity:.8}
    .accBody{padding:0 12px 12px;}

    /* Tiles */
    .tiles{
      display:flex; flex-wrap:wrap; gap:8px;
      align-items:flex-start;
    }
    .tile{
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:9px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      font-size:12px;
      font-weight:900;
      cursor:pointer;
      max-width:100%;
    }
    .tile small{
      font-size:11px;
      color:var(--muted);
      font-weight:800;
    }
    .tile.sel{
      border-color: rgba(0,229,255,.55);
      background: rgba(0,229,255,.10);
    }
    .tile.wet{
      box-shadow: inset 0 0 0 9999px rgba(0,229,255,.04);
    }
    .tile.wild{
      border-style:dashed;
    }
    .tile.disabled{
      opacity:.55;
      cursor:not-allowed;
    }

    /* Published dishes */
    .dish{
      border:1px solid var(--border);
      border-radius:18px;
      padding:10px;
      background: rgba(255,255,255,.03);
    }
    .dishHead{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
    }
    .dishSub{color:var(--muted); font-size:12px; margin-top:4px; display:flex; gap:10px; flex-wrap:wrap;}
    .dishTiles{margin-top:8px;}

    /* Draft carousel */
    .carousel{
      display:flex; align-items:center; gap:8px;
      user-select:none;
    }
    .carViewport{
      flex:1;
      border:1px solid var(--border);
      border-radius:18px;
      padding:10px;
      background: rgba(255,255,255,.03);
      min-height:90px;
      touch-action: pan-y;
    }
    .carTitle{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      font-weight:1000;
    }
    .carMeta{color:var(--muted); font-size:12px; margin-top:6px;}
    .carTiles{margin-top:10px;}
    .carBtns{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}

    /* Table wrap for box score */
    .tableWrap{
      overflow:auto;
      border:1px solid var(--border);
      border-radius:16px;
      background: rgba(0,0,0,.22);
    }
    table.box{
      width:100%;
      border-collapse:collapse;
      min-width:520px;
    }
    table.box th, table.box td{
      padding:10px 10px;
      border-bottom:1px solid var(--border);
      font-size:12px;
      text-align:right;
      white-space:nowrap;
    }
    table.box th:first-child, table.box td:first-child{
      text-align:left;
    }
    table.box thead th{
      font-size:11px;
      color: var(--muted);
      font-weight:1000;
    }
    table.box tbody tr:last-child td{border-bottom:none;}
    table.box .totalRow td{
      font-weight:1100;
      background: rgba(255,255,255,.04);
    }
    table.box .currentRow td{
      background: rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 9999px rgba(255,204,0,.06);
    }

    /* Toast */
    #toast{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:88px;
      z-index:90;
      max-width: min(560px, calc(100% - 24px));
      padding:10px 12px;
      border-radius:16px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.72);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      font-weight:900;
      font-size:13px;
      white-space:normal;
      word-break:break-word;
    }
    #toast.on{
      opacity:1;
      transform:translateX(-50%) translateY(-6px);
    }

    /* Modal */
    #modalWrap{
      position:fixed; inset:0;
      background: rgba(0,0,0,.68);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:95;
      padding:16px;
    }
    #modalWrap.on{display:flex;}
    .modal{
      width:min(560px, 100%);
      background: rgba(0,0,0,.86);
      border:1px solid var(--border);
      border-radius:22px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modalHead{padding:14px 14px 0; font-weight:1000; font-size:16px;}
    .modalBody{padding:12px 14px; color:var(--muted); font-size:13px; line-height:1.35;}
    .modalFoot{padding:12px 14px 14px; display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;}
    .muted2{color:rgba(255,255,255,.55); font-size:12px; margin-top:10px;}

    /* Campaign-only Skip CPU */
    .skipBtn{
      position:fixed;
      right:12px;
      bottom:76px;
      z-index:80;
      display:none;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.55);
      color: var(--text);
      font-weight:1000;
      backdrop-filter: blur(8px);
    }
    .skipBtn:active{ transform: translateY(1px); }

    /* Small forms */
    .field{display:flex; flex-direction:column; gap:6px; margin-top:10px;}
    .label{font-size:12px; color:var(--muted); font-weight:900;}
    .twoCols{
      display:grid; grid-template-columns: 1fr 1fr; gap:10px;
    }
    @media (max-width: 420px){
      .twoCols{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="hrow">
      <div>
        <div class="title">Taco Ria <span class="badge mono" id="ver">v0.9.0</span></div>
        <div class="subtitle">
          <span class="pill" id="phasePill">Not Seated Yet</span>
          <span class="pill">Hand <span class="mono" id="handIndex">1</span>/<span class="mono" id="handsTarget">12</span></span>
          <span class="pill">Difficulty <span class="mono" id="diffLabel">Easy</span></span>
          <span class="pill" id="modePill">Standard</span>
        </div>
      </div>
      <div class="row">
        <button class="btnTiny ghost" id="btnNew">New Match</button>
      </div>
    </div>
  </header>

  <main>
    <!-- GAMEPLAY -->
    <section class="screen on" id="screenGame">
      <div class="grid two">
        <div class="card">
          <div class="row">
            <span class="badge">Public Line / Window</span>
            <span class="badge" id="kitchenBadge">Kitchen Closed</span>
            <span class="spacer"></span>
            <span class="badge">Active: <span class="mono" id="activeLabel">P1</span></span>
          </div>
          <div class="hint" id="publicHint">Publish dishes here once you‚Äôve got 10+ points (or Starter Pass for Chips & Dip).</div>
          <div class="hr"></div>
          <div id="publicArea"></div>
        </div>

        <div class="card">
          <details class="acc" open>
            <summary>
              <span>Dashboard</span>
              <span class="sumHint">you vs chefs</span>
              <span class="chev">‚ñæ</span>
            </summary>
            <div class="accBody">
              <div class="row">
                <span class="badge">Score <span class="mono" id="scoreNow">0</span></span>
                <span class="badge">Pending <span class="mono" id="scorePending">0</span></span>
                <span class="badge">Tiles <span class="mono" id="handCount">0</span></span>
              </div>
              <div class="hint" id="dashHint">Serving happens at the end of the hand.</div>
              <div class="hr"></div>

              <details class="acc" open>
                <summary>
                  <span>Your Turn Controls</span>
                  <span class="sumHint">publish / draw / end</span>
                  <span class="chev">‚ñæ</span>
                </summary>
                <div class="accBody">
                  <div class="row">
                    <button class="primary" id="btnToPrep">Open Prep</button>
                    <button id="btnDraw">Draw Tile</button>
                    <button class="danger" id="btnEndTurn">End Turn</button>
                  </div>
                  <div class="hint" id="turnGateHint"></div>
                </div>
              </details>

              <details class="acc">
                <summary>
                  <span>Quick Rules</span>
                  <span class="sumHint">phase logic</span>
                  <span class="chev">‚ñæ</span>
                </summary>
                <div class="accBody">
                  <div class="hint">
                    ‚Ä¢ <b>Not Seated Yet</b>: Kitchen closed. No wet toppings on first laydown.<br>
                    ‚Ä¢ <b>Appetizers Out</b>: Starter Pass lets you publish Chips & Dip (5 pts) once per hand.<br>
                    ‚Ä¢ <b>Kitchen Open</b>: Public line can be remixed. Remix must be <b>5+ pts</b>.<br>
                    ‚Ä¢ Serving (scoring) happens at the end of the hand.
                  </div>
                </div>
              </details>
            </div>
          </details>
        </div>
      </div>
    </section>

    <!-- PREP -->
    <section class="screen" id="screenPrep">
      <div class="card">
        <div class="row">
          <span class="badge">Prep</span>
          <span class="badge" id="prepKitchen">Kitchen Closed</span>
          <span class="spacer"></span>
          <button class="btnTiny ghost" id="btnBackGame1">Back</button>
        </div>
        <div class="hint">Draft privately. Publish dishes to the public line when ready.</div>
        <div class="hr"></div>

        <div class="grid twoEven">
          <div>
            <details class="acc" open>
              <summary>
                <span>Draft Carousel</span>
                <span class="sumHint">multiple dishes allowed</span>
                <span class="chev">‚ñæ</span>
              </summary>
              <div class="accBody">
                <div class="carousel">
                  <button class="btnTiny ghost" id="btnPrevDish">‚óÄ</button>
                  <div class="carViewport" id="carViewport">
                    <div class="carTitle">
                      <span id="dishTitle">Dish 1</span>
                      <span class="badge">Pts <span class="mono" id="dishPts">0</span></span>
                    </div>
                    <div class="carMeta" id="dishMeta">Select tiles + choose a recipe.</div>
                    <div class="carTiles tiles" id="dishTiles"></div>
                    <div class="carBtns">
                      <select id="selRecipe"></select>
                      <button class="btnTiny" id="btnClearDish">Clear Dish</button>
                      <button class="btnTiny" id="btnRemoveDish">Remove Dish</button>
                      <button class="btnTiny primary" id="btnAddDish">Add Dish</button>
                    </div>
                  </div>
                  <button class="btnTiny ghost" id="btnNextDish">‚ñ∂</button>
                </div>

                <div class="hr"></div>
                <div class="row">
                  <span class="badge">Draft Total <span class="mono" id="draftTotalPts">0</span></span>
                  <span class="badge" id="draftGateBadge">Need 10+</span>
                  <span class="spacer"></span>
                  <button id="btnAutoPlate" class="btnTiny">Auto-Plate</button>
                  <button class="primary" id="btnPublishDraft">Publish Draft</button>
                </div>
                <div class="hint" id="draftHint"></div>
              </div>
            </details>

            <details class="acc">
              <summary>
                <span>Remix Builder</span>
                <span class="sumHint">kitchen open only</span>
                <span class="chev">‚ñæ</span>
              </summary>
              <div class="accBody">
                <div class="hint" id="remixHint">Open kitchen to remix the public line.</div>
                <div class="hr"></div>
                <div class="row">
                  <button class="btnTiny" id="btnClearRemix">Clear Remix</button>
                  <button class="btnTiny primary" id="btnRemixPublish">Publish Remix</button>
                </div>
                <div class="hint">Remix must be <b>5+ points</b>.</div>
              </div>
            </details>
          </div>

          <div>
            <details class="acc" open>
              <summary>
                <span>Your Hand</span>
                <span class="sumHint">tap to select</span>
                <span class="chev">‚ñæ</span>
              </summary>
              <div class="accBody">
                <div class="tiles" id="handTiles"></div>
              </div>
            </details>

            <details class="acc">
              <summary>
                <span>Public Tiles</span>
                <span class="sumHint">tap to select for remix</span>
                <span class="chev">‚ñæ</span>
              </summary>
              <div class="accBody">
                <div class="tiles" id="publicTiles"></div>
              </div>
            </details>
          </div>
        </div>
      </div>
    </section>

    <!-- SCORES -->
    <section class="screen" id="screenScores">
      <div class="card" id="scoresCard"></div>
    </section>

    <!-- SETTINGS -->
    <section class="screen" id="screenSettings">
      <div class="card">
        <div class="row">
          <span class="badge">Settings</span>
          <span class="spacer"></span>
          <button class="btnTiny ghost" id="btnBackGame2">Back</button>
        </div>
        <div class="hint">Primary theme stays black. Choose a high-contrast accent.</div>
        <div class="hr"></div>

        <details class="acc" open>
          <summary>
            <span>Match</span>
            <span class="sumHint">mode + players</span>
            <span class="chev">‚ñæ</span>
          </summary>
          <div class="accBody">
            <div class="twoCols">
              <div class="field">
                <div class="label">Mode</div>
                <select id="selMode">
                  <option value="standard">Standard Match</option>
                  <option value="campaign">Campaign (12 rounds per difficulty)</option>
                </select>
              </div>
              <div class="field">
                <div class="label">Players</div>
                <select id="selPlayers">
                  <option value="2">2 Players</option>
                  <option value="3">3 Players</option>
                  <option value="4">4 Players</option>
                </select>
              </div>
            </div>

            <div class="twoCols">
              <div class="field">
                <div class="label">CPU Difficulty (Standard only)</div>
                <select id="selDifficulty">
                  <option>Beginner</option>
                  <option>Easy</option>
                  <option>Medium</option>
                  <option>Difficult</option>
                  <option>Master Chef</option>
                </select>
              </div>
              <div class="field">
                <div class="label">Hands (Standard only)</div>
                <input id="inpHands" type="number" min="1" max="12" value="12" />
              </div>
            </div>

            <div class="twoCols">
              <div class="field">
                <div class="label">Tiles per Player</div>
                <input id="inpTiles" type="number" min="10" max="24" value="16" />
              </div>
              <div class="field">
                <div class="label">Decks</div>
                <select id="selDecks">
                  <option value="2">2 Decks (Recommended)</option>
                  <option value="1">1 Deck (54 cards)</option>
                </select>
              </div>
            </div>

            <div class="hint">
              Campaign auto-walks difficulty: Beginner ‚Üí Easy ‚Üí Medium ‚Üí Difficult ‚Üí Master Chef.
              Skip button appears during CPU turns in Campaign only.
            </div>
          </div>
        </details>

        <details class="acc">
          <summary>
            <span>Theme</span>
            <span class="sumHint">accent color</span>
            <span class="chev">‚ñæ</span>
          </summary>
          <div class="accBody">
            <div class="field">
              <div class="label">Accent</div>
              <select id="selAccent"></select>
            </div>
          </div>
        </details>

        <div class="hr"></div>
        <div class="hint">Version <span class="mono">v0.9.0</span> ‚Ä¢ Taco Ria (Rummikub variant)</div>
      </div>
    </section>
  </main>

  <footer class="nav">
    <div class="navRow">
      <button class="navBtn on" id="navGame">üé≠<div>Gameplay</div></button>
      <button class="navBtn" id="navPrep">üç≥<div>Prep</div></button>
      <button class="navBtn" id="navScores">üèÜ<div>Scores</div></button>
      <button class="navBtn" id="navSettings">‚öôÔ∏è<div>Settings</div></button>
    </div>
  </footer>
</div>

<div id="toast"></div>

<div id="modalWrap">
  <div class="modal">
    <div class="modalHead" id="modalTitle">Modal</div>
    <div class="modalBody" id="modalBody"></div>
    <div class="modalFoot" id="modalFoot">
      <button class="primary" id="btnModalOK">OK</button>
    </div>
  </div>
</div>

<button id="btnSkipCpu" class="skipBtn" style="display:none">‚è© Skip CPU</button>

<script>
/* =========================
   Taco Ria ‚Äî MVP Engine
   ========================= */

const VERSION = "v0.9.0";

/* --- Ingredient deck (single deck = 54 cards) --- */
const BASE_COUNTS = [
  ["Fish",1],
  ["Ground Beef",2],
  ["Shredded Chicken",2],
  ["Carne Guisada",1],
  ["Al Pastor",1],
  ["Carnitas",1],
  ["Egg",2],
  ["Chicken Fajita",2],
  ["Chorizo",1],
  ["Tortilla Chips",3],
  ["Flour Tortillas",2],
  ["Corn Tortillas",2],
  ["Shredded Yellow Cheese",2],
  ["Shredded White Cheese",2],
  ["Rice",2],
  ["Charro Beans",1],
  ["Refried Beans",1],
  ["Black Beans",1],
  ["Cilantro",2],
  ["Jalape√±os",2],
  ["Lettuce",1],
  ["Lime Juice",2],
  ["Onion",2],
  ["Tomato",2],
  ["Sour Cream",2],
  ["Avocado",2],
  ["Salsa Roja",2],
  ["Salsa Verde",2],
  ["Queso",2],
  ["Guacamole",2],
  ["Grocery Run",2] // wild substitute
];

const CATS = {
  tortillas: new Set(["Flour Tortillas","Corn Tortillas"]),
  chips: new Set(["Tortilla Chips"]),
  proteins: new Set(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]),
  cheeses: new Set(["Shredded Yellow Cheese","Shredded White Cheese"]),
  beans: new Set(["Charro Beans","Refried Beans","Black Beans"]),
  wet: new Set(["Salsa Roja","Salsa Verde","Queso","Guacamole","Sour Cream"]),
  produce: new Set(["Cilantro","Jalape√±os","Lettuce","Onion","Tomato","Lime Juice","Avocado"]),
  wild: new Set(["Grocery Run"])
};

const GAME = {
  rules: {
    publishToOpenKitchenThreshold: 10,
    remixMinPoints: 5,
    maxIngredientsPerDish: 3, // cap
    wetNotAllowedWhenClosed: true
  },
  phases: {
    CLOSED: "Not Seated Yet",
    APPS: "Appetizers Out",
    OPEN: "Kitchen Open"
  },
  toasts: {
    kitchenOpened: "üî• Kitchen Open!",
    needDraw: "üé¥ You must draw if you don‚Äôt publish.",
    needPublishOrDraw: "Pick a move: publish or draw one tile.",
    cannotWetYet: "üíß Wet toppings are off-limits until Kitchen Open.",
    starterPassUsed: "üéüÔ∏è Starter Pass used.",
    draftNeed10: "Need 10+ total to publish (or Starter Pass for Chips & Dip).",
    remixNeedKitchen: "Remix is only available when Kitchen Open.",
    remixNeed5: "Remix must be 5+ points.",
    invalidDish: "That dish doesn‚Äôt validate with your selected tiles."
  }
};

/* =========================
   CPU Difficulty + Characters
   ========================= */

const CPU_CFG = {
  "Beginner": { canRemix:false },
  "Easy": { canRemix:false },
  "Medium": { canRemix:false },
  "Difficult": { canRemix:true },
  "Master Chef": { canRemix:true }
};

const CAMPAIGN = {
  levels: ["Beginner","Easy","Medium","Difficult","Master Chef"],
  roundsPerLevel: 12
};

const CPU_CHARACTERS = {
  chefMike: {
    name: "Chef Mike",
    speedFixedMs: 650,      // ALWAYS fast
    jitterMs: 180,
    sloppyRate: 0.28,
    appetizerBias: 0.10,
    remixBias: 0.85
  },
  salsaSam: {
    name: "Salsa Sam",
    speedMult: 1.00,
    jitterMs: 220,
    sloppyRate: 0.10,
    appetizerBias: 0.20,
    remixBias: 1.00
  },
  quesoQueen: {
    name: "Queso Queen",
    speedMult: 1.12,
    jitterMs: 260,
    sloppyRate: 0.08,
    appetizerBias: 0.75,
    remixBias: 0.95
  },
  grillGuru: {
    name: "Grill Guru",
    speedMult: 0.85,
    jitterMs: 160,
    sloppyRate: 0.04,
    appetizerBias: 0.15,
    remixBias: 1.35
  }
};

function cpuRoster(){
  if(state.settings.numPlayers === 2) return ["chefMike"];
  if(state.settings.numPlayers === 3) return ["chefMike","salsaSam"];
  return ["chefMike","quesoQueen","grillGuru"];
}
function cpuChar(pid){
  const roster = cpuRoster();
  if(pid === "P2") return CPU_CHARACTERS[roster[0]];
  if(pid === "P3") return CPU_CHARACTERS[roster[1] || roster[0]];
  if(pid === "P4") return CPU_CHARACTERS[roster[2] || roster[roster.length-1]];
  return { name: pid, speedMult: 1, jitterMs: 0, sloppyRate: 0, appetizerBias: 0, remixBias: 1 };
}
function cpuName(pid){ return cpuChar(pid).name; }

function effectiveDifficulty(){
  if(state?.settings?.mode === "campaign"){
    const idx = state?.match?.campaign?.levelIndex ?? 0;
    return CAMPAIGN.levels[clamp(idx, 0, CAMPAIGN.levels.length-1)];
  }
  return state?.settings?.cpuDifficulty || "Easy";
}
function getCpuCfg(){
  return CPU_CFG[effectiveDifficulty()] || CPU_CFG["Easy"];
}
function autoPlateAllowed(){
  const d = effectiveDifficulty();
  return d==="Beginner" || d==="Easy";
}
function cpuThinkMs(){
  const d = effectiveDifficulty();
  const map = {
    "Beginner": 5000,
    "Easy": 3500,
    "Medium": 2500,
    "Difficult": 1500,
    "Master Chef": 500
  };
  return map[d] ?? 2500;
}
function randInt(a,b){ return Math.floor(a + Math.random() * (b - a + 1)); }
function cpuThinkMsFor(pid){
  const ch = cpuChar(pid);
  if(ch.speedFixedMs != null){
    return Math.max(120, ch.speedFixedMs + randInt(-ch.jitterMs, ch.jitterMs));
  }
  const base = cpuThinkMs();
  const scaled = Math.round(base * (ch.speedMult ?? 1));
  return Math.max(120, scaled + randInt(-ch.jitterMs, ch.jitterMs));
}

/* =========================
   Recipes (minimal, expandable)
   ========================= */

const RECIPES = [
  {
    key:"chips_and_dip",
    name:"Chips & Dip",
    pts: 5,
    max: 2, // chips + dip
    validate: (names, ctx) => {
      // chips + one dip (wet allowed only via Starter Pass when closed)
      const hasChips = names.includes("Tortilla Chips");
      if(!hasChips) return false;
      const dips = ["Queso","Guacamole","Salsa Roja","Salsa Verde"];
      const dipCount = names.filter(n => dips.includes(n)).length;
      if(dipCount !== 1) return false;
      // allow exactly 2 tiles total (wild may replace dip or chips)
      if(names.length !== 2) return false;
      return true;
    }
  },
  {
    key:"taco",
    name:"Taco",
    pts: 10,
    max: 3,
    validate: (names, ctx) => {
      // tortilla + protein + optional ONE dry topping (no wet when closed)
      const hasTortilla = names.some(n => CATS.tortillas.has(n));
      const hasProtein = names.some(n => CATS.proteins.has(n));
      if(!hasTortilla || !hasProtein) return false;
      if(names.length < 2 || names.length > 3) return false;
      // if 3rd ingredient exists, it must not be a tortilla/protein (i.e., topping)
      if(names.length === 3){
        const top = names.find(n => !CATS.tortillas.has(n) && !CATS.proteins.has(n));
        if(!top) return false;
        // topping allowed can be cheese/produce/beans/rice, but not wet when closed (handled by global rule)
        return true;
      }
      return true;
    }
  },
  {
    key:"quesadilla",
    name:"Quesadilla",
    pts: 10,
    max: 3,
    validate: (names, ctx) => {
      // flour tortilla + cheese (+ optional dry topping)
      if(!names.includes("Flour Tortillas")) return false;
      const hasCheese = names.some(n => CATS.cheeses.has(n));
      if(!hasCheese) return false;
      if(names.length < 2 || names.length > 3) return false;
      return true;
    }
  },
  {
    key:"burrito",
    name:"Burrito",
    pts: 12,
    max: 3,
    validate: (names, ctx) => {
      // flour tortilla + protein + (rice OR beans)
      if(!names.includes("Flour Tortillas")) return false;
      const hasProtein = names.some(n => CATS.proteins.has(n));
      const hasRiceOrBeans = names.some(n => n==="Rice" || CATS.beans.has(n));
      if(!hasProtein || !hasRiceOrBeans) return false;
      if(names.length !== 3) return false;
      return true;
    }
  },
  {
    key:"nachos",
    name:"Nachos",
    pts: 12,
    max: 3,
    validate: (names, ctx) => {
      // chips + cheese + protein
      if(!names.includes("Tortilla Chips")) return false;
      const hasCheese = names.some(n => CATS.cheeses.has(n));
      const hasProtein = names.some(n => CATS.proteins.has(n));
      if(!hasCheese || !hasProtein) return false;
      if(names.length !== 3) return false;
      return true;
    }
  },
  {
    key:"bowl",
    name:"Rice Bowl",
    pts: 10,
    max: 3,
    validate: (names, ctx) => {
      // rice + protein + beans
      if(!names.includes("Rice")) return false;
      const hasProtein = names.some(n => CATS.proteins.has(n));
      const hasBeans = names.some(n => CATS.beans.has(n));
      if(!hasProtein || !hasBeans) return false;
      if(names.length !== 3) return false;
      return true;
    }
  },
  {
    key:"enchiladas",
    name:"Enchiladas",
    pts: 15,
    max: 3,
    validate: (names, ctx) => {
      // corn tortillas + protein + sauce (roja/verde)
      if(!names.includes("Corn Tortillas")) return false;
      const hasProtein = names.some(n => CATS.proteins.has(n));
      const hasSauce = names.includes("Salsa Roja") || names.includes("Salsa Verde");
      if(!hasProtein || !hasSauce) return false;
      if(names.length !== 3) return false;
      // chorizo rule: chorizo is fine as long as sauce is included (already enforced)
      return true;
    }
  },
  {
    key:"side_rice",
    name:"Side: Rice Cup",
    pts: 3,
    max: 1,
    validate: (names, ctx) => names.length===1 && names[0]==="Rice"
  },
  {
    key:"side_beans",
    name:"Side: Beans Cup",
    pts: 3,
    max: 1,
    validate: (names, ctx) => names.length===1 && CATS.beans.has(names[0])
  }
];

function recipeByKey(k){ return RECIPES.find(r=>r.key===k); }

/* =========================
   State
   ========================= */

let state = null;

function defaultState(){
  return {
    settings: {
      mode: "standard",           // "standard" | "campaign"
      numPlayers: 4,
      cpuDifficulty: "Easy",      // standard only
      handsTarget: 12,            // standard only
      tilesPerPlayer: 16,
      decks: 2,
      accent: "#00e5ff"
    },
    match: {
      handIndex: 1,
      scores: { P1:0, P2:0, P3:0, P4:0 },
      campaign: {
        levelIndex: 0,
        roundInLevel: 1,
        levelScores: {}
      }
    },
    hand: null
  };
}

function newHandState(){
  const players = {};
  const pids = activePids();
  for(const pid of pids){
    players[pid] = { hand: [], didDraw:false, didPublish:false, didRemix:false };
  }
  return {
    id: uid("hand"),
    kitchenOpen: false,
    kitchenOpenedBy: null,
    published: [], // list of dishes
    pendingRound: { P1:0, P2:0, P3:0, P4:0 },
    pendingDetail: { P1:[], P2:[], P3:[], P4:[] },
    starterPassUsed: { P1:false, P2:false, P3:false, P4:false },
    bag: [],
    turnCount: 0,
    active: "P1",
    players,
    draft: {
      idx: 0,
      dishes: [ makeDraftDish() ],
      remixSelHand: new Set(),
      remixSelPublic: new Set(),
      recipeKey: "taco"
    }
  };
}

function makeDraftDish(){
  return { id: uid("d"), recipeKey: "taco", tileIds: [] };
}

/* =========================
   Utilities
   ========================= */

function $(id){ return document.getElementById(id); }
function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
function uid(prefix="id"){ return prefix + "_" + Math.random().toString(16).slice(2) + Date.now().toString(16); }
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function escapeHtml(s){
  return (""+s).replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
}
function sum(arr, fn){ let t=0; for(const x of arr) t += fn(x); return t; }

/* =========================
   Toasts
   ========================= */

let toastTimer = null;
function toast(msg, ms = 2200){
  const el = $("toast");
  el.textContent = msg;
  el.classList.add("on");
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>el.classList.remove("on"), ms);
}
function toastSeq(messages, gapMs = 950, toastMs = 1800){
  let t = 0;
  for(const m of messages){
    setTimeout(()=>toast(m, toastMs), t);
    t += gapMs;
  }
}

/* =========================
   Modal
   ========================= */

function closeModal(){ $("modalWrap").classList.remove("on"); }
$("btnModalOK").onclick = closeModal;

function chapterCardCopy(diff){
  if(diff === "Beginner") return [
    "Training wheels on.",
    "Auto-Plate available in Prep.",
    "CPUs won‚Äôt remix the public line."
  ];
  if(diff === "Easy") return [
    "Still chill‚Ä¶ but faster.",
    "Auto-Plate available in Prep.",
    "CPUs won‚Äôt remix the public line."
  ];
  if(diff === "Medium") return [
    "Now you‚Äôre cooking.",
    "Auto-Plate locked.",
    "CPUs play smarter, still no remix."
  ];
  if(diff === "Difficult") return [
    "Heat is up.",
    "CPUs can remix the public line (‚â•5 pts).",
    "Auto-Plate locked."
  ];
  return [
    "Welcome to the fire.",
    "Aggressive remix whenever possible (‚â•5 pts).",
    "May draw-boost to force a remix."
  ];
}
function showChapterCard(prevDiff, nextDiff){
  const lines = chapterCardCopy(nextDiff);
  $("modalTitle").textContent = `Chapter Up: ${nextDiff}`;
  $("modalBody").innerHTML = `
    <div class="muted">
      <div><b>${escapeHtml(prevDiff)}</b> ‚ûú <b>${escapeHtml(nextDiff)}</b></div>
      <div style="margin-top:10px">${lines.map(x=>`‚Ä¢ ${escapeHtml(x)}`).join("<br>")}</div>
    </div>
  `;
  $("modalFoot").innerHTML = `<button class="primary" id="btnChapterContinue">Continue</button>`;
  $("btnChapterContinue").onclick = ()=>{
    closeModal();
    dealNewHand();
    persist();
    render();
    if(state.hand.active !== "P1") runCpuLoop();
  };
  $("modalWrap").classList.add("on");
}

/* =========================
   Deck + dealing
   ========================= */

function buildDeck(decks=2){
  const out = [];
  let seq = 1;
  for(let d=0; d<decks; d++){
    for(const [name,qty] of BASE_COUNTS){
      for(let i=0;i<qty;i++){
        out.push({ id: `t${d+1}_${seq++}_${uid("x")}`, name });
      }
    }
  }
  return out;
}

function activePids(){
  const n = state.settings.numPlayers;
  return ["P1","P2","P3","P4"].slice(0,n);
}

/* =========================
   Campaign scoring helpers
   ========================= */

function campaignLevelKey(){ return effectiveDifficulty(); }

function ensureCampaignLevelScores(){
  if(state.settings.mode !== "campaign") return;
  const key = campaignLevelKey();
  if(!state.match.campaign) state.match.campaign = { levelIndex:0, roundInLevel:1, levelScores:{} };
  if(!state.match.campaign.levelScores) state.match.campaign.levelScores = {};
  if(!state.match.campaign.levelScores[key]){
    state.match.campaign.levelScores[key] = { P1:0, P2:0, P3:0, P4:0 };
  }
}
function ensureAllCampaignLevelScores(){
  if(state.settings.mode !== "campaign") return;
  if(!state.match.campaign) state.match.campaign = { levelIndex:0, roundInLevel:1, levelScores:{} };
  if(!state.match.campaign.levelScores) state.match.campaign.levelScores = {};
  for(const lvl of CAMPAIGN.levels){
    if(!state.match.campaign.levelScores[lvl]){
      state.match.campaign.levelScores[lvl] = { P1:0, P2:0, P3:0, P4:0 };
    }
  }
}

/* =========================
   Rules + validation
   ========================= */

function isWet(name){ return CATS.wet.has(name); }
function isWild(name){ return CATS.wild.has(name); }

function resolveWilds(tileNames, neededPredicate){
  // Simple: treat Grocery Run as "can act as anything" by allowing it to satisfy missing required slots.
  // Implementation: validator functions already accept names; we validate with wilds included as-is,
  // then allow a second pass where wilds are mapped to missing required categories.
  // For MVP: If recipe fails and wild exists, allow it unless failure is "missing required ingredient".
  return tileNames;
}

function dishPoints(recipeKey){
  const r = recipeByKey(recipeKey);
  return r ? r.pts : 0;
}

function kitchenPhaseLabel(){
  const h = state.hand;
  if(h.kitchenOpen) return GAME.phases.OPEN;
  // Kitchen closed: we still show appetizer phase in closed state since Starter Pass exists
  return GAME.phases.APPS;
}

function kitchenAllowsWet(){
  // Wet toppings blocked when kitchen is closed AND the dish is not Starter Pass chips & dip.
  return state.hand.kitchenOpen;
}

function validateDish(recipeKey, tileNames, opts){
  const r = recipeByKey(recipeKey);
  if(!r) return { ok:false, reason:"Unknown recipe." };

  if(tileNames.length === 0) return { ok:false, reason:"Empty dish." };
  if(tileNames.length > GAME.rules.maxIngredientsPerDish) return { ok:false, reason:`Max ${GAME.rules.maxIngredientsPerDish} ingredients.` };
  if(tileNames.length > (r.max ?? 3)) return { ok:false, reason:`Too many tiles for ${r.name}.` };

  // Wet gate when kitchen closed (except chips & dip w/ Starter Pass publish)
  if(GAME.rules.wetNotAllowedWhenClosed && !state.hand.kitchenOpen){
    const hasWet = tileNames.some(isWet);
    const isChipsDip = recipeKey === "chips_and_dip";
    const allowWetViaStarter = !!(opts && opts.allowWetViaStarterPass && isChipsDip);
    if(hasWet && !allowWetViaStarter){
      return { ok:false, reason:"Wet toppings locked until Kitchen Open." };
    }
  }

  // Run recipe validator (with wilds as raw names; MVP allowance)
  const ctx = { kitchenOpen: state.hand.kitchenOpen };
  const ok = r.validate(tileNames, ctx);
  if(!ok){
    // soft wild assistance: if any wild present, allow one fail pass for MVP
    if(tileNames.some(isWild)){
      // Permit wild to fill any one missing role. (Keeps it playful.)
      return { ok:true, reason:"(Wild substituted)" };
    }
    return { ok:false, reason:"Doesn‚Äôt match recipe requirements." };
  }
  return { ok:true, reason:"OK" };
}

function tilePenaltyValue(tile){
  // MVP: 1 point per leftover tile.
  return 1;
}

/* =========================
   Publishing + remixing
   ========================= */

function addPending(pid, dish){
  state.hand.pendingRound[pid] += dish.points;
  state.hand.pendingDetail[pid].push({ dishId: dish.id, name: dish.name, points: dish.points });
}

function removePendingByDishId(pid, dishId, points){
  // remove first matching detail
  const arr = state.hand.pendingDetail[pid];
  const idx = arr.findIndex(x => x.dishId === dishId);
  if(idx >= 0) arr.splice(idx,1);
  state.hand.pendingRound[pid] -= points;
  if(state.hand.pendingRound[pid] < 0) state.hand.pendingRound[pid] = 0;
}

function publishDish(pid, recipeKey, tileObjs, meta){
  const names = tileObjs.map(t=>t.name);
  const allowWetViaStarter = !!(meta && meta.allowWetViaStarterPass);
  const v = validateDish(recipeKey, names, { allowWetViaStarterPass: allowWetViaStarter });
  if(!v.ok) return { ok:false, reason:v.reason };

  const r = recipeByKey(recipeKey);
  const dish = {
    id: uid("pub"),
    owner: pid,
    ownerName: (pid==="P1" ? "You" : cpuName(pid)),
    recipeKey,
    name: r ? r.name : recipeKey,
    points: r ? r.pts : 0,
    tiles: tileObjs.map(t => ({ id:t.id, name:t.name })),
    createdAt: Date.now(),
    isRemix: !!(meta && meta.isRemix),
    fromDishId: meta?.fromDishId || null
  };

  state.hand.published.push(dish);
  addPending(pid, dish);
  return { ok:true, dish };
}

function removePublishedDish(dishId){
  const idx = state.hand.published.findIndex(d => d.id === dishId);
  if(idx < 0) return null;
  const dish = state.hand.published[idx];
  state.hand.published.splice(idx,1);
  removePendingByDishId(dish.owner, dish.id, dish.points);
  return dish;
}

function removeCardsFromHand(pid, tileIds){
  const p = state.hand.players[pid];
  const keep = [];
  const removeSet = new Set(tileIds);
  for(const t of p.hand){
    if(!removeSet.has(t.id)) keep.push(t);
  }
  p.hand = keep;
}

function drawOne(pid){
  const p = state.hand.players[pid];
  if(state.hand.bag.length === 0) return false;
  const t = state.hand.bag.pop();
  p.hand.push(t);
  p.didDraw = true;
  return true;
}

/* =========================
   Draft (P1)
   ========================= */

function currentDraftDish(){
  return state.hand.draft.dishes[state.hand.draft.idx];
}

function calcDraftDishPts(dish){
  const r = recipeByKey(dish.recipeKey);
  if(!r) return 0;
  const tiles = dish.tileIds.map(id => findTileInP1Hand(id)).filter(Boolean);
  if(tiles.length===0) return 0;
  const v = validateDish(dish.recipeKey, tiles.map(t=>t.name), { allowWetViaStarterPass: false });
  return v.ok ? r.pts : 0;
}

function calcDraftTotalPts(){
  let total=0;
  for(const d of state.hand.draft.dishes){
    total += calcDraftDishPts(d);
  }
  return total;
}

function findTileInP1Hand(id){
  return state.hand.players.P1.hand.find(t => t.id === id);
}

function clearDish(dish){
  dish.tileIds = [];
}

function removeDishAt(idx){
  const dishes = state.hand.draft.dishes;
  if(dishes.length<=1){
    clearDish(dishes[0]);
    return;
  }
  dishes.splice(idx,1);
  state.hand.draft.idx = clamp(state.hand.draft.idx, 0, dishes.length-1);
}

function addDish(){
  state.hand.draft.dishes.push(makeDraftDish());
  state.hand.draft.idx = state.hand.draft.dishes.length-1;
}

function toggleDishTileSelection(tileId){
  const dish = currentDraftDish();
  const has = dish.tileIds.includes(tileId);
  if(has){
    dish.tileIds = dish.tileIds.filter(x=>x!==tileId);
    return;
  }
  if(dish.tileIds.length >= GAME.rules.maxIngredientsPerDish){
    toast(`Max ${GAME.rules.maxIngredientsPerDish} ingredients per dish.`);
    return;
  }
  dish.tileIds.push(tileId);
}

function publishDraftFromPrep(){
  const pid = "P1";
  const h = state.hand;

  // Build evaluated dishes
  const evalDishes = [];
  let totalPts = 0;

  for(const d of h.draft.dishes){
    const tiles = d.tileIds.map(id => findTileInP1Hand(id)).filter(Boolean);
    if(tiles.length===0) continue;

    // Starter Pass special case: chips&dip can be published alone even though wet is blocked.
    const wantsChipsDip = d.recipeKey === "chips_and_dip";
    const starterEligible = wantsChipsDip && !h.starterPassUsed[pid] && !h.kitchenOpen;

    const allowWetViaStarter = starterEligible;

    const v = validateDish(d.recipeKey, tiles.map(t=>t.name), { allowWetViaStarterPass: allowWetViaStarter });
    if(!v.ok){
      toast(GAME.toasts.invalidDish);
      return;
    }
    const pts = dishPoints(d.recipeKey);
    evalDishes.push({ recipeKey:d.recipeKey, tiles, pts, starterEligible });
    totalPts += pts;
  }

  if(evalDishes.length===0){
    toast("No dishes drafted.");
    return;
  }

  // Gate publishing:
  // - If kitchen closed: need 10+ total OR Starter Pass publishing ONLY Chips&Dip as a single dish
  if(!h.kitchenOpen){
    const onlyOne = evalDishes.length===1;
    const onlyStarter = onlyOne && evalDishes[0].starterEligible && evalDishes[0].recipeKey==="chips_and_dip";
    if(totalPts < GAME.rules.publishToOpenKitchenThreshold && !onlyStarter){
      toast(GAME.toasts.draftNeed10);
      return;
    }
  }

  // Execute publish
  let openedKitchen = false;

  for(const d of evalDishes){
    const meta = {
      allowWetViaStarterPass: d.starterEligible,
      isRemix:false
    };
    const res = publishDish(pid, d.recipeKey, d.tiles, meta);
    if(!res.ok){
      toast(GAME.toasts.invalidDish);
      return;
    }
    removeCardsFromHand(pid, d.tiles.map(t=>t.id));

    if(d.starterEligible){
      h.starterPassUsed[pid] = true;
      toast(GAME.toasts.starterPassUsed, 1800);
    }
  }

  // Open kitchen if threshold reached (and kitchen currently closed) and publishing isn't ONLY Starter Pass
  if(!h.kitchenOpen && totalPts >= GAME.rules.publishToOpenKitchenThreshold){
    h.kitchenOpen = true;
    h.kitchenOpenedBy = pid;
    openedKitchen = true;
    toast(GAME.toasts.kitchenOpened);
  }

  // Mark turn action
  h.players[pid].didPublish = true;

  // Clear draft
  h.draft.dishes = [makeDraftDish()];
  h.draft.idx = 0;

  persist();
  render();
}

/* =========================
   Remix (P1)
   ========================= */

function publicTilesFlat(){
  const out = [];
  for(const dish of state.hand.published){
    for(const t of dish.tiles){
      out.push({ id:t.id, name:t.name, dishId:dish.id, owner:dish.owner, points:dish.points });
    }
  }
  return out;
}

function clearRemixSelection(){
  state.hand.draft.remixSelHand = new Set();
  state.hand.draft.remixSelPublic = new Set();
}

function toggleRemixHand(id){
  const set = state.hand.draft.remixSelHand;
  if(set.has(id)) set.delete(id);
  else {
    if(set.size + state.hand.draft.remixSelPublic.size >= GAME.rules.maxIngredientsPerDish){
      toast(`Max ${GAME.rules.maxIngredientsPerDish} ingredients per dish.`);
      return;
    }
    set.add(id);
  }
}
function toggleRemixPublic(id){
  const set = state.hand.draft.remixSelPublic;
  if(set.has(id)) set.delete(id);
  else {
    if(set.size + state.hand.draft.remixSelHand.size >= GAME.rules.maxIngredientsPerDish){
      toast(`Max ${GAME.rules.maxIngredientsPerDish} ingredients per dish.`);
      return;
    }
    set.add(id);
  }
}

function publishRemix(){
  const h = state.hand;
  if(!h.kitchenOpen){
    toast(GAME.toasts.remixNeedKitchen);
    return;
  }

  const pid = "P1";
  const handSel = [...h.draft.remixSelHand];
  const pubSel = [...h.draft.remixSelPublic];
  if(handSel.length + pubSel.length === 0){
    toast("Select tiles to remix.");
    return;
  }

  // Get tile objects
  const handTiles = handSel.map(id => findTileInP1Hand(id)).filter(Boolean);
  const pubTiles = publicTilesFlat().filter(t => pubSel.includes(t.id));

  // Ensure selected public tiles are consistent (they exist)
  if(pubTiles.length !== pubSel.length){
    toast("Some public tiles are no longer available.");
    clearRemixSelection();
    render();
    return;
  }

  // We‚Äôll create a dish using selected tiles. Recipe chosen from selRecipe.
  const recipeKey = $("selRecipe").value;
  const names = [...handTiles.map(t=>t.name), ...pubTiles.map(t=>t.name)];
  const v = validateDish(recipeKey, names, { allowWetViaStarterPass:false });
  if(!v.ok){
    toast(GAME.toasts.invalidDish);
    return;
  }

  const pts = dishPoints(recipeKey);
  if(pts < GAME.rules.remixMinPoints){
    toast(GAME.toasts.remixNeed5);
    return;
  }

  // Remove selected public tiles from their dish(es) by removing entire dish(es) if any tile is taken (MVP simplification).
  // This keeps bookkeeping sane: remix consumes whole dish if you touch it.
  const touchedDishIds = new Set(pubTiles.map(t => t.dishId));
  for(const did of touchedDishIds){
    removePublishedDish(did);
  }

  // Publish remix dish
  const tilesForDish = [...handTiles, ...pubTiles.map(t => ({id:t.id, name:t.name}))].map(x=>({id:x.id, name:x.name}));
  const res = publishDish(pid, recipeKey, tilesForDish, { isRemix:true });
  if(!res.ok){
    toast(GAME.toasts.invalidDish);
    return;
  }

  // Remove used hand tiles
  removeCardsFromHand(pid, handTiles.map(t=>t.id));

  h.players[pid].didRemix = true;

  clearRemixSelection();
  persist();
  render();
}

/* =========================
   Turn + end-of-hand scoring
   ========================= */

function resetTurnFlags(pid){
  const p = state.hand.players[pid];
  p.didDraw = false;
  p.didPublish = false;
  p.didRemix = false;
}

function canEndTurn(pid){
  const p = state.hand.players[pid];
  // Must either publish/remix OR draw one tile
  return (p.didPublish || p.didRemix || p.didDraw);
}

function endTurn(){
  const h = state.hand;
  const pid = h.active;

  if(pid === "P1"){
    if(!canEndTurn("P1")){
      toast(GAME.toasts.needPublishOrDraw);
      return false;
    }
  }

  // Next player
  const pids = activePids();
  const idx = pids.indexOf(pid);
  const next = pids[(idx+1) % pids.length];

  h.turnCount += 1;
  h.active = next;

  // Reset next player's turn flags
  resetTurnFlags(next);

  // Check end-of-hand conditions
  if(shouldEndHand()){
    endHand();
    return true;
  }

  persist();
  render();

  // Run CPUs if needed
  if(h.active !== "P1") runCpuLoop();

  return true;
}

function shouldEndHand(){
  const h = state.hand;
  // End when any player is out, OR bag empty and everyone took at least one turn cycle,
  // OR safety cap
  const pids = activePids();
  if(pids.some(pid => h.players[pid].hand.length === 0)) return true;
  if(h.bag.length === 0 && h.turnCount >= pids.length) return true;
  if(h.turnCount >= 80) return true;
  return false;
}

function commitRound(){
  ensureCampaignLevelScores();
  const pids = activePids();

  for(const pid of pids){
    const add = (state.hand.pendingRound[pid] || 0);
    state.match.scores[pid] += add;

    if(state.settings.mode === "campaign"){
      const key = campaignLevelKey();
      state.match.campaign.levelScores[key][pid] += add;
    }

    state.hand.pendingRound[pid] = 0;
    state.hand.pendingDetail[pid] = [];
  }
}

function applyPenalties(){
  ensureCampaignLevelScores();
  const pids = activePids();
  for(const pid of pids){
    const tiles = state.hand.players[pid].hand;
    const pen = tiles.reduce((t,x)=>t+tilePenaltyValue(x),0);
    if(pen > 0){
      state.match.scores[pid] -= pen;
      if(state.settings.mode === "campaign"){
        const key = campaignLevelKey();
        state.match.campaign.levelScores[key][pid] -= pen;
      }
    }
  }
}

function endHand(){
  // Serving: commit pending points, then apply leftover tile penalties
  commitRound();
  applyPenalties();

  const winner = computeHandWinner();
  toast(`üçΩÔ∏è Served! Hand over. ${winner}`, 2600);

  // Advance progression
  if(state.settings.mode === "campaign"){
    const c = state.match.campaign;
    const prevLevelIndex = c.levelIndex;
    c.roundInLevel += 1;

    if(c.roundInLevel > CAMPAIGN.roundsPerLevel){
      c.levelIndex += 1;
      c.roundInLevel = 1;

      if(c.levelIndex >= CAMPAIGN.levels.length){
        showMatchSummary();
        return;
      }

      const prev = CAMPAIGN.levels[prevLevelIndex];
      const next = CAMPAIGN.levels[c.levelIndex];

      persist();
      render();
      showChapterCard(prev, next);
      return; // wait for Continue
    }

    // continue within chapter
    state.match.handIndex += 1;
    dealNewHand();
    persist();
    render();
    if(state.hand.active !== "P1") runCpuLoop();
    return;
  }

  // Standard match
  state.match.handIndex += 1;
  if(state.match.handIndex > state.settings.handsTarget){
    showMatchSummary();
    return;
  }
  dealNewHand();
  persist();
  render();
  if(state.hand.active !== "P1") runCpuLoop();
}

function computeHandWinner(){
  // MVP: winner is highest (pending already committed), show leader
  const pids = activePids();
  let best = pids[0], bestScore = state.match.scores[best];
  for(const pid of pids){
    if(state.match.scores[pid] > bestScore){
      bestScore = state.match.scores[pid];
      best = pid;
    }
  }
  const label = (best==="P1") ? "You‚Äôre leading." : `${cpuName(best)} is leading.`;
  return label;
}

function showMatchSummary(){
  const pids = activePids();
  let best = pids[0], bestScore = state.match.scores[best];
  for(const pid of pids){
    if(state.match.scores[pid] > bestScore){
      bestScore = state.match.scores[pid];
      best = pid;
    }
  }
  const champ = (best==="P1") ? "You" : cpuName(best);
  $("modalTitle").textContent = "Match Complete";
  $("modalBody").innerHTML = `
    <div class="muted">
      <div><b>Champion:</b> ${escapeHtml(champ)} (<span class="mono">${bestScore}</span>)</div>
      <div style="margin-top:10px">${pids.map(pid=>{
        const nm = pid==="P1" ? "You" : cpuName(pid);
        return `‚Ä¢ ${escapeHtml(nm)}: <span class="mono">${state.match.scores[pid]}</span>`;
      }).join("<br>")}</div>
    </div>
  `;
  $("modalFoot").innerHTML = `<button class="primary" id="btnOKDone">OK</button>`;
  $("btnOKDone").onclick = closeModal;
  $("modalWrap").classList.add("on");
}

/* =========================
   CPU logic (simple + flavorful)
   ========================= */

function cpuDraftDishesFromHand(pid){
  const p = state.hand.players[pid];
  const tiles = p.hand.slice();
  const names = tiles.map(t=>t.name);

  // Try to find best single dish first, then optionally a second.
  const dishes = [];

  // Helper to find first valid dish among recipes (with bias)
  function findDish(bias){
    // bias can prioritize appetizers
    const recs = RECIPES.slice();
    if(bias === "apps"){
      recs.sort((a,b)=> (a.key==="chips_and_dip"?-1:0) - (b.key==="chips_and_dip"?-1:0));
    } else {
      recs.sort((a,b)=> (b.pts - a.pts));
    }

    for(const r of recs){
      // Build candidates up to max ingredients
      const max = Math.min(r.max ?? 3, GAME.rules.maxIngredientsPerDish);
      // brute small combinations (<=3)
      const combos = combosUpTo(tiles, max);
      for(const combo of combos){
        const cn = combo.map(t=>t.name);
        const allowWetViaStarter = (r.key==="chips_and_dip" && !state.hand.kitchenOpen && !state.hand.starterPassUsed[pid]);
        const v = validateDish(r.key, cn, { allowWetViaStarterPass: allowWetViaStarter });
        if(v.ok){
          return { recipeKey:r.key, tiles:combo, points:r.pts, starterEligible: allowWetViaStarter };
        }
      }
    }
    return null;
  }

  const ch = cpuChar(pid);

  // Queso Queen: appetizer-leaning while kitchen closed (but won't skip an opening move)
  let bias = null;
  if(ch.name==="Queso Queen" && !state.hand.kitchenOpen) bias = "apps";

  let first = findDish(bias);
  if(!first) return [];

  dishes.push(first);

  // Chef Mike sloppy: may stop at 1 dish
  if(ch.sloppyRate && Math.random() < ch.sloppyRate){
    return dishes;
  }

  // Try for a second dish using remaining tiles (rare; keeps pacing snappy)
  const remainIds = new Set(first.tiles.map(t=>t.id));
  const remain = tiles.filter(t => !remainIds.has(t.id));
  if(remain.length >= 2){
    // Quick attempt: find another valid dish with remaining tiles
    const combos = combosUpTo(remain, 3);
    // prioritize medium pts
    for(const r of RECIPES.slice().sort((a,b)=>b.pts-a.pts)){
      for(const combo of combos){
        const cn = combo.map(t=>t.name);
        const allowWetViaStarter = (r.key==="chips_and_dip" && !state.hand.kitchenOpen && !state.hand.starterPassUsed[pid]);
        const v = validateDish(r.key, cn, { allowWetViaStarterPass: allowWetViaStarter });
        if(v.ok){
          dishes.push({ recipeKey:r.key, tiles:combo, points:r.pts, starterEligible: allowWetViaStarter });
          return dishes;
        }
      }
    }
  }

  return dishes;
}

function combosUpTo(arr, k){
  // generate combos of size 1..k (small brute)
  const out = [];
  const n = arr.length;
  function rec(start, combo){
    if(combo.length>0) out.push(combo.slice());
    if(combo.length===k) return;
    for(let i=start;i<n;i++){
      combo.push(arr[i]);
      rec(i+1, combo);
      combo.pop();
    }
  }
  rec(0, []);
  // Keep only combos within 1..k
  return out.filter(c => c.length>=1 && c.length<=k);
}

function cpuMaybeRemixLine(pid){
  const cfg = getCpuCfg();
  if(!cfg.canRemix || !state.hand.kitchenOpen) return false;

  // Character bias: decide whether to attempt remix at all
  const bias = cpuChar(pid).remixBias ?? 1;
  const wantRemix = (Math.random() < Math.min(0.95, 0.55 * bias));
  if(!wantRemix) return false;

  // Find a public dish worth remixing (>=5 pts)
  const candidates = state.hand.published.filter(d => d.points >= GAME.rules.remixMinPoints && d.owner !== pid);
  if(candidates.length===0) return false;

  // Grill Guru likes higher value targets
  candidates.sort((a,b)=> (b.points-a.points));
  const target = candidates[0];

  // Remove the dish from original owner (pending adjusted)
  const removed = removePublishedDish(target.id);
  if(!removed) return false;

  // Optionally add one tile from CPU hand to upgrade recipe (Master Chef-ish flavor)
  const p = state.hand.players[pid];
  const addTile = p.hand.find(t => !CATS.wild.has(t.name));
  let remixTiles = removed.tiles.map(t=>({id:t.id, name:t.name}));
  if(addTile && remixTiles.length < GAME.rules.maxIngredientsPerDish){
    remixTiles = remixTiles.concat([{id:addTile.id, name:addTile.name}]);
    // remove that tile from hand
    removeCardsFromHand(pid, [addTile.id]);
  }

  // Choose best recipe that validates for these tiles
  const tileNames = remixTiles.map(t=>t.name);
  const possible = RECIPES
    .filter(r => r.pts >= GAME.rules.remixMinPoints)
    .sort((a,b)=>b.pts-a.pts);

  let chosen = null;
  for(const r of possible){
    const v = validateDish(r.key, tileNames, { allowWetViaStarterPass:false });
    if(v.ok){
      chosen = r;
      break;
    }
  }
  if(!chosen){
    // If can't validate, just re-plate original recipe/tile set (still counts as remix steal)
    chosen = recipeByKey(removed.recipeKey) || recipeByKey("taco");
  }

  // Publish remix as new dish
  const res = publishDish(pid, chosen.key, remixTiles, { isRemix:true, fromDishId: removed.id });
  if(!res.ok) return false;

  state.hand.players[pid].didRemix = true;
  return true;
}

function cpuMasterChefBoostRemix(pid){
  // MVP "boost": if Master Chef and no good remix candidate, they may draw then attempt remix again next turns.
  // Here we just treat it as "no-op"; the aggression already comes from cpuMaybeRemixLine + speed.
  return false;
}

function cpuPublishTurn(pid){
  const p = state.hand.players[pid];
  const kitchenClosed = !state.hand.kitchenOpen;

  const out = { pid, platedCount:0, remixed:false, remixType:null, drew:false };

  // Remix attempt first if allowed
  if(state.hand.kitchenOpen){
    const did = cpuMaybeRemixLine(pid);
    if(did){
      out.remixed = true;
      out.remixType = "standard";
    } else if(effectiveDifficulty()==="Master Chef"){
      const did2 = cpuMasterChefBoostRemix(pid);
      if(did2){
        out.remixed = true;
        out.remixType = "boost";
      }
    }
  }

  const drafted = cpuDraftDishesFromHand(pid);
  const totalPts = sum(drafted, d=>d.points);

  // Queso Queen: if kitchen closed and she has Chips&Dip starter eligible AND cannot open kitchen, she‚Äôll take it.
  if(kitchenClosed){
    const starterDish = drafted.find(d=>d.recipeKey==="chips_and_dip" && d.starterEligible);
    const canOpen = totalPts >= GAME.rules.publishToOpenKitchenThreshold;
    if(cpuChar(pid).name==="Queso Queen" && starterDish && !canOpen && !state.hand.starterPassUsed[pid]){
      state.hand.starterPassUsed[pid] = true;
      publishDish(pid, starterDish.recipeKey, starterDish.tiles, { allowWetViaStarterPass:true });
      removeCardsFromHand(pid, starterDish.tiles.map(t=>t.id));
      out.platedCount = 1;
      p.didPublish = true;
      return out;
    }
  }

  // If kitchen closed: open if possible; else starter pass if eligible; else draw
  if(kitchenClosed){
    if(totalPts >= GAME.rules.publishToOpenKitchenThreshold){
      state.hand.kitchenOpen = true;
      state.hand.kitchenOpenedBy = pid;
      toast(GAME.toasts.kitchenOpened, 1400);
    } else {
      const starterDish = drafted.find(d=>d.recipeKey==="chips_and_dip" && d.starterEligible);
      if(starterDish && !state.hand.starterPassUsed[pid]){
        state.hand.starterPassUsed[pid] = true;
        publishDish(pid, starterDish.recipeKey, starterDish.tiles, { allowWetViaStarterPass:true });
        removeCardsFromHand(pid, starterDish.tiles.map(t=>t.id));
        out.platedCount = 1;
        p.didPublish = true;
        return out;
      }
      drawOne(pid);
      out.drew = true;
      return out;
    }
  }

  // Kitchen open: publish drafted (if any), else draw
  if(drafted.length===0){
    drawOne(pid);
    out.drew = true;
    return out;
  }

  // Chef Mike sloppy: might publish only first dish even if more exist
  const ch = cpuChar(pid);
  if(ch.sloppyRate && drafted.length>1 && Math.random() < ch.sloppyRate){
    drafted.splice(1);
  }

  for(const d of drafted){
    // Remix minimum points not required for normal publish
    publishDish(pid, d.recipeKey, d.tiles, { allowWetViaStarterPass: d.starterEligible, isRemix:false });
    removeCardsFromHand(pid, d.tiles.map(t=>t.id));
    out.platedCount += 1;
  }

  p.didPublish = true;
  return out;
}

/* =========================
   CPU loop with delay + Campaign skip
   ========================= */

let cpuBusy = false;
let cpuThinkTimer = null;
let cpuSkipFn = null;

function setSkipVisible(on){
  const btn = $("btnSkipCpu");
  btn.style.display = on ? "inline-flex" : "none";
}
function bindSkipCpu(){
  $("btnSkipCpu").onclick = ()=>{
    if(state.settings.mode !== "campaign") return;
    if(typeof cpuSkipFn === "function") cpuSkipFn();
  };
}

function runCpuLoop(){
  if(cpuBusy) return;
  cpuBusy = true;

  const step = ()=>{
    const pid = state.hand.active;
    if(pid === "P1"){
      // cleanup
      setSkipVisible(false);
      cpuSkipFn = null;
      if(cpuThinkTimer) clearTimeout(cpuThinkTimer);
      cpuThinkTimer = null;

      cpuBusy = false;
      render();
      return;
    }

    render();

    const doCpuTurn = ()=>{
      if(cpuThinkTimer) clearTimeout(cpuThinkTimer);
      cpuThinkTimer = null;
      cpuSkipFn = null;
      setSkipVisible(false);

      if(pid !== state.hand.active){ step(); return; }

      const res = cpuPublishTurn(pid);
      persist();
      render();

      // End turn immediately after action
      endTurn();

      // Action toasts
      const who = cpuName(pid);
      const msgs = [];
      if(res.remixed) msgs.push(`üîÄ ${who} remixed${res.remixType==="boost" ? " (boost)" : ""}.`);
      if(res.platedCount > 0) msgs.push(`üçΩÔ∏è ${who} plated ${res.platedCount} dish${res.platedCount===1?"":"es"}.`);
      if(res.drew) msgs.push(`üé¥ ${who} drew a tile.`);
      msgs.push(`‚úÖ ${who} turn complete`);
      toastSeq(msgs);

      setTimeout(()=>step(), 80);
    };

    // Campaign-only skip during "thinking"
    if(state.settings.mode === "campaign"){
      setSkipVisible(true);
      cpuSkipFn = doCpuTurn;
    } else {
      setSkipVisible(false);
      cpuSkipFn = null;
    }

    const ms = cpuThinkMsFor(pid);
    if(ms >= 1500) toast(`üß† ${cpuName(pid)} is thinking‚Ä¶`, Math.min(1200, ms-200));
    cpuThinkTimer = setTimeout(doCpuTurn, ms);
  };

  step();
}

/* =========================
   Render
   ========================= */

function setScreen(name){
  for(const id of ["screenGame","screenPrep","screenScores","screenSettings"]){
    $(id).classList.remove("on");
  }
  $(name).classList.add("on");
  for(const k of ["navGame","navPrep","navScores","navSettings"]){
    $(k).classList.remove("on");
  }
  const map = {
    screenGame:"navGame",
    screenPrep:"navPrep",
    screenScores:"navScores",
    screenSettings:"navSettings"
  };
  $(map[name]).classList.add("on");
}

function renderTop(){
  $("ver").textContent = VERSION;

  $("diffLabel").textContent = effectiveDifficulty();
  $("modePill").textContent = (state.settings.mode === "campaign") ? "Campaign" : "Standard";

  if(state.settings.mode === "campaign"){
    const c = state.match.campaign;
    $("handIndex").textContent = c.roundInLevel;
    $("handsTarget").textContent = CAMPAIGN.roundsPerLevel;
  } else {
    $("handIndex").textContent = state.match.handIndex;
    $("handsTarget").textContent = state.settings.handsTarget;
  }

  $("phasePill").textContent = kitchenPhaseLabel();
}

function renderPublicLine(){
  const el = $("publicArea");
  const h = state.hand;

  $("kitchenBadge").textContent = h.kitchenOpen ? "Kitchen Open" : "Kitchen Closed";
  $("kitchenBadge").className = "badge " + (h.kitchenOpen ? "good" : "warn");

  $("activeLabel").textContent = (h.active==="P1") ? "You" : cpuName(h.active);
  $("publicHint").textContent = h.kitchenOpen
    ? "Kitchen is open. Public dishes can be remixed. Remix must be 5+ points."
    : "Kitchen closed. Publish 10+ points to open, or Starter Pass Chips & Dip once per hand.";

  if(h.published.length === 0){
    el.innerHTML = `<div class="hint">No dishes in the line yet.</div>`;
    return;
  }

  el.innerHTML = h.published.map(d=>{
    const tiles = d.tiles.map(t=>`<span class="tile ${isWet(t.name)?"wet":""} ${isWild(t.name)?"wild":""}"><span>${escapeHtml(t.name)}</span></span>`).join("");
    const remixTag = d.isRemix ? `<span class="badge">Remix</span>` : ``;
    return `
      <div class="dish">
        <div class="dishHead">
          <div>${escapeHtml(d.name)}</div>
          <div class="row" style="justify-content:flex-end">
            ${remixTag}
            <span class="badge">Pts <span class="mono">${d.points}</span></span>
          </div>
        </div>
        <div class="dishSub">
          <span>By <b>${escapeHtml(d.ownerName)}</b></span>
          <span class="mono">${d.owner}</span>
        </div>
        <div class="dishTiles tiles">${tiles}</div>
      </div>
    `;
  }).join("<div style='height:10px'></div>");
}

function renderDashboard(){
  const pid = "P1";
  $("scoreNow").textContent = state.match.scores[pid];
  $("scorePending").textContent = state.hand.pendingRound[pid] || 0;
  $("handCount").textContent = state.hand.players[pid].hand.length;

  const p = state.hand.players.P1;
  const gate = [];
  if(state.hand.active !== "P1"){
    $("turnGateHint").textContent = "Wait for the CPUs‚Ä¶";
    $("btnDraw").disabled = true;
    $("btnEndTurn").disabled = true;
    $("btnToPrep").disabled = true;
    return;
  }

  $("btnDraw").disabled = p.didDraw;
  $("btnToPrep").disabled = false;
  $("btnEndTurn").disabled = !canEndTurn("P1");

  if(!canEndTurn("P1")){
    $("turnGateHint").textContent = "Publish a dish (or remix) OR draw one tile.";
  } else {
    $("turnGateHint").textContent = "Ready when you are.";
  }
}

function renderHandTiles(){
  const p = state.hand.players.P1;
  const el = $("handTiles");
  const dish = currentDraftDish();
  const remixSel = state.hand.draft.remixSelHand;

  el.innerHTML = p.hand
    .slice()
    .sort((a,b)=>a.name.localeCompare(b.name))
    .map(t=>{
      const isSelDish = dish.tileIds.includes(t.id);
      const isSelRemix = remixSel.has(t.id);
      const sel = isSelDish || isSelRemix;
      const cls = `tile ${sel?"sel":""} ${isWet(t.name)?"wet":""} ${isWild(t.name)?"wild":""}`;
      return `<span class="${cls}" data-tile="${escapeHtml(t.id)}">${escapeHtml(t.name)}</span>`;
    }).join("");
}

function renderPublicTilesForRemix(){
  const el = $("publicTiles");
  const tiles = publicTilesFlat();
  const sel = state.hand.draft.remixSelPublic;

  if(tiles.length===0){
    el.innerHTML = `<div class="hint">Nothing in the public line yet.</div>`;
    return;
  }
  el.innerHTML = tiles.map(t=>{
    const cls = `tile ${sel.has(t.id)?"sel":""} ${isWet(t.name)?"wet":""} ${isWild(t.name)?"wild":""}`;
    return `<span class="${cls}" data-ptile="${escapeHtml(t.id)}">${escapeHtml(t.name)} <small>${escapeHtml(t.owner==="P1"?"You":cpuName(t.owner))}</small></span>`;
  }).join("");
}

function renderDraftCarousel(){
  const h = state.hand;
  const dishes = h.draft.dishes;
  const idx = h.draft.idx;
  const dish = dishes[idx];

  // recipe options
  const sel = $("selRecipe");
  sel.innerHTML = RECIPES.map(r=>`<option value="${escapeHtml(r.key)}">${escapeHtml(r.name)} (${r.pts} pts)</option>`).join("");
  sel.value = dish.recipeKey;

  $("dishTitle").textContent = `Dish ${idx+1} / ${dishes.length}`;
  $("dishMeta").textContent = `Recipe: ${recipeByKey(dish.recipeKey)?.name || dish.recipeKey} ‚Ä¢ Max ${GAME.rules.maxIngredientsPerDish} tiles`;
  $("dishPts").textContent = calcDraftDishPts(dish);

  const tiles = dish.tileIds.map(id => findTileInP1Hand(id)).filter(Boolean);
  $("dishTiles").innerHTML = tiles.length
    ? tiles.map(t=>`<span class="tile sel ${isWet(t.name)?"wet":""} ${isWild(t.name)?"wild":""}">${escapeHtml(t.name)}</span>`).join("")
    : `<div class="hint">Tap tiles in your hand to add them to this dish.</div>`;

  const total = calcDraftTotalPts();
  $("draftTotalPts").textContent = total;

  const kitchenClosed = !h.kitchenOpen;
  const onlyStarterPossible = (
    dishes.length===1 &&
    dish.recipeKey==="chips_and_dip" &&
    tiles.length===2 &&
    !h.starterPassUsed.P1 &&
    kitchenClosed
  );

  $("draftGateBadge").textContent = kitchenClosed
    ? (total >= 10 ? "Publish OK" : (onlyStarterPossible ? "Starter Pass OK" : "Need 10+"))
    : "Publish OK";

  $("draftGateBadge").className = "badge " + ((kitchenClosed && total<10 && !onlyStarterPossible) ? "warn" : "good");

  $("prepKitchen").textContent = h.kitchenOpen ? "Kitchen Open" : "Kitchen Closed";
  $("prepKitchen").className = "badge " + (h.kitchenOpen ? "good" : "warn");

  const ap = autoPlateAllowed() ? "Auto-Plate available." : "Auto-Plate locked at this difficulty.";
  const wet = (!h.kitchenOpen) ? "Wet toppings locked until Kitchen Open (except Starter Pass Chips & Dip)." : "Wet toppings allowed.";
  $("draftHint").textContent = `${ap} ${wet}`;

  // Remix hint
  $("remixHint").textContent = h.kitchenOpen ? "Select tiles from your hand + the public line, choose a recipe, and publish a 5+ pt remix." : "Open kitchen to remix the public line.";

  // Auto-plate button
  $("btnAutoPlate").disabled = !autoPlateAllowed();
}

function renderScores(){
  const pids = activePids();
  const isCamp = state.settings.mode === "campaign";
  if(isCamp) ensureAllCampaignLevelScores();

  const chapterKey = isCamp ? campaignLevelKey() : null;

  const header = isCamp
    ? `<div class="muted" style="margin-bottom:10px">
         <b>Campaign</b>: ${escapeHtml(chapterKey)} ‚Ä¢ Round ${state.match.campaign.roundInLevel}/${CAMPAIGN.roundsPerLevel}
       </div>`
    : `<div class="muted" style="margin-bottom:10px"><b>Standard Match</b> ‚Ä¢ Hand ${state.match.handIndex}/${state.settings.handsTarget}</div>`;

  const box = isCamp ? `
    <details class="acc" open>
      <summary>
        <span>Box Score</span>
        <span class="sumHint">chapters + total</span>
        <span class="chev">‚ñæ</span>
      </summary>
      <div class="accBody">
        <div class="tableWrap">
          <table class="box">
            <thead>
              <tr>
                <th>Chapter</th>
                ${pids.map(pid=>`<th>${escapeHtml(pid==="P1"?"You":cpuName(pid))}</th>`).join("")}
              </tr>
            </thead>
            <tbody>
              ${CAMPAIGN.levels.map(lvl=>{
                const row = state.match.campaign.levelScores[lvl] || {};
                const here = (lvl === chapterKey);
                return `
                  <tr class="${here ? "currentRow" : ""}">
                    <td>${escapeHtml(lvl)}${here ? " ‚Ä¢ Now" : ""}</td>
                    ${pids.map(pid=>`<td class="mono">${row[pid] ?? 0}</td>`).join("")}
                  </tr>
                `;
              }).join("")}
              <tr class="totalRow">
                <td>Total</td>
                ${pids.map(pid=>`<td class="mono">${state.match.scores[pid] ?? 0}</td>`).join("")}
              </tr>
            </tbody>
          </table>
        </div>
        <div class="hint">Chapter rows are subtotals for each difficulty. Total is the running campaign score.</div>
      </div>
    </details>
  ` : ``;

  const live = `
    <details class="acc" open>
      <summary>
        <span>Live Scores</span>
        <span class="sumHint">totals + pending</span>
        <span class="chev">‚ñæ</span>
      </summary>
      <div class="accBody">
        ${pids.map(pid=>{
          const nm = pid==="P1" ? "You" : cpuName(pid);
          const total = state.match.scores[pid] ?? 0;
          const pending = state.hand.pendingRound[pid] ?? 0;
          const sub = isCamp ? ((state.match.campaign.levelScores[chapterKey]?.[pid]) ?? 0) : null;
          return `
            <div class="dish">
              <div class="dishHead">
                <div>${escapeHtml(nm)}</div>
                <div class="row" style="justify-content:flex-end">
                  <span class="badge">Total <span class="mono">${total}</span></span>
                  ${isCamp ? `<span class="badge">${escapeHtml(chapterKey)} <span class="mono">${sub}</span></span>` : ``}
                  <span class="badge">Pending <span class="mono">${pending}</span></span>
                </div>
              </div>
            </div>
          `;
        }).join("<div style='height:10px'></div>")}
        <div class="hr"></div>
        <div class="row">
          <button class="btnTiny danger" id="btnForceServe">Serve & End Hand</button>
          <span class="hint">Admin tool for testing.</span>
        </div>
      </div>
    </details>
  `;

  $("scoresCard").innerHTML = `
    <div class="row">
      <span class="badge">Scores</span>
      <span class="spacer"></span>
      <button class="btnTiny ghost" id="btnBackGame3">Back</button>
    </div>
    <div class="hr"></div>
    ${header}
    ${box}
    ${live}
  `;

  $("btnBackGame3").onclick = ()=>{ setScreen("screenGame"); render(); };
  $("btnForceServe").onclick = ()=>{
    // Serve immediately (commit pending + penalties), then advance like normal
    commitRound();
    applyPenalties();

    if(state.settings.mode === "campaign"){
      const c = state.match.campaign;
      const prevLevelIndex = c.levelIndex;
      c.roundInLevel += 1;

      if(c.roundInLevel > CAMPAIGN.roundsPerLevel){
        c.levelIndex += 1;
        c.roundInLevel = 1;

        if(c.levelIndex >= CAMPAIGN.levels.length){
          persist(); render();
          showMatchSummary();
          return;
        }
        const prev = CAMPAIGN.levels[prevLevelIndex];
        const next = CAMPAIGN.levels[c.levelIndex];

        persist(); render();
        showChapterCard(prev, next);
        return;
      }

      state.match.handIndex += 1;
      dealNewHand();
      persist(); render();
      if(state.hand.active !== "P1") runCpuLoop();
      return;
    }

    state.match.handIndex += 1;
    if(state.match.handIndex > state.settings.handsTarget){
      persist(); render();
      showMatchSummary();
      return;
    }
    dealNewHand();
    persist(); render();
    if(state.hand.active !== "P1") runCpuLoop();
  };
}

function renderSettings(){
  // Build accent list
  const accents = [
    ["Neon Cyan","#00e5ff"],
    ["Signal Yellow","#ffcc00"],
    ["Lime","#a3ff12"],
    ["Hot Pink","#ff2bd6"],
    ["Orange","#ff8a00"],
    ["Ice","#b3f6ff"],
    ["Violet","#b36bff"],
    ["Red","#ff3b30"]
  ];
  const selAccent = $("selAccent");
  selAccent.innerHTML = accents.map(([n,v])=>`<option value="${v}">${escapeHtml(n)} (${v})</option>`).join("");
  selAccent.value = state.settings.accent;

  $("selMode").value = state.settings.mode;
  $("selPlayers").value = String(state.settings.numPlayers);
  $("selDifficulty").value = state.settings.cpuDifficulty;
  $("inpHands").value = state.settings.handsTarget;
  $("inpTiles").value = state.settings.tilesPerPlayer;
  $("selDecks").value = String(state.settings.decks);

  // Standard-only controls disabled in campaign
  const stdOnly = (state.settings.mode !== "campaign");
  $("selDifficulty").disabled = !stdOnly;
  $("inpHands").disabled = !stdOnly;

  // Apply theme accent
  document.documentElement.style.setProperty("--accent", state.settings.accent);
  // use accent2 as a high-contrast secondary; keep stable
  document.documentElement.style.setProperty("--accent2", "#ffcc00");
}

function renderPrep(){
  renderDraftCarousel();
  renderHandTiles();
  renderPublicTilesForRemix();
}

function render(){
  renderTop();
  renderPublicLine();
  renderDashboard();
  renderSettings();
  renderPrep();

  if($("screenScores").classList.contains("on")) renderScores();
}

/* =========================
   Gestures (carousel swipe)
   ========================= */

let touchX0 = null;
$("carViewport").addEventListener("touchstart", (e)=>{
  if(e.touches && e.touches.length) touchX0 = e.touches[0].clientX;
}, {passive:true});
$("carViewport").addEventListener("touchend", (e)=>{
  if(touchX0 == null) return;
  const x1 = (e.changedTouches && e.changedTouches.length) ? e.changedTouches[0].clientX : touchX0;
  const dx = x1 - touchX0;
  touchX0 = null;
  if(Math.abs(dx) < 50) return;
  if(dx < 0) nextDish();
  else prevDish();
}, {passive:true});

/* =========================
   Controls / Wiring
   ========================= */

function prevDish(){
  state.hand.draft.idx = clamp(state.hand.draft.idx - 1, 0, state.hand.draft.dishes.length-1);
  persist(); render();
}
function nextDish(){
  state.hand.draft.idx = clamp(state.hand.draft.idx + 1, 0, state.hand.draft.dishes.length-1);
  persist(); render();
}

$("btnPrevDish").onclick = prevDish;
$("btnNextDish").onclick = nextDish;

$("btnClearDish").onclick = ()=>{
  clearDish(currentDraftDish());
  persist(); render();
};
$("btnRemoveDish").onclick = ()=>{
  removeDishAt(state.hand.draft.idx);
  persist(); render();
};
$("btnAddDish").onclick = ()=>{
  addDish();
  persist(); render();
};

$("selRecipe").onchange = (e)=>{
  const dish = currentDraftDish();
  dish.recipeKey = e.target.value;
  persist(); render();
};

$("btnPublishDraft").onclick = ()=>{
  if(state.hand.active !== "P1"){ toast("Not your turn."); return; }
  publishDraftFromPrep();
};

$("btnToPrep").onclick = ()=>{
  if(state.hand.active !== "P1"){ toast("Not your turn."); return; }
  setScreen("screenPrep");
  render();
};
$("btnBackGame1").onclick = ()=>{ setScreen("screenGame"); render(); };
$("btnBackGame2").onclick = ()=>{ setScreen("screenGame"); render(); };

$("btnDraw").onclick = ()=>{
  if(state.hand.active !== "P1"){ toast("Not your turn."); return; }
  const ok = drawOne("P1");
  if(!ok) toast("Bag is empty.");
  persist(); render();
};
$("btnEndTurn").onclick = ()=>{
  if(state.hand.active !== "P1"){ toast("Not your turn."); return; }
  endTurn();
};

$("btnAutoPlate").onclick = ()=>{
  if(!autoPlateAllowed()){
    toast("Auto-Plate locked.");
    return;
  }
  autoPlateIntoDraft();
  persist(); render();
};

$("btnClearRemix").onclick = ()=>{
  clearRemixSelection();
  persist(); render();
};
$("btnRemixPublish").onclick = ()=>{
  if(state.hand.active !== "P1"){ toast("Not your turn."); return; }
  publishRemix();
};

$("btnNew").onclick = ()=> startNewMatch(true);

$("navGame").onclick = ()=>{ setScreen("screenGame"); render(); };
$("navPrep").onclick = ()=>{ setScreen("screenPrep"); render(); };
$("navScores").onclick = ()=>{ setScreen("screenScores"); renderScores(); };
$("navSettings").onclick = ()=>{ setScreen("screenSettings"); render(); };

$("selMode").onchange = ()=>{
  state.settings.mode = $("selMode").value;
  if(state.settings.mode === "campaign"){
    state.match.campaign = { levelIndex:0, roundInLevel:1, levelScores: {} };
    ensureAllCampaignLevelScores();
    toast("Campaign mode started.", 1800);
  } else {
    toast("Standard match mode.", 1800);
  }
  // restart hand for clean rules
  dealNewHand();
  persist(); render();
  if(state.hand.active !== "P1") runCpuLoop();
};

$("selPlayers").onchange = ()=>{
  state.settings.numPlayers = parseInt($("selPlayers").value,10);
  dealNewHand();
  persist(); render();
};

$("selDifficulty").onchange = ()=>{
  state.settings.cpuDifficulty = $("selDifficulty").value;
  persist(); render();
};

$("inpHands").onchange = ()=>{
  state.settings.handsTarget = clamp(parseInt($("inpHands").value,10) || 12, 1, 12);
  persist(); render();
};

$("inpTiles").onchange = ()=>{
  state.settings.tilesPerPlayer = clamp(parseInt($("inpTiles").value,10) || 16, 10, 24);
  dealNewHand();
  persist(); render();
};

$("selDecks").onchange = ()=>{
  state.settings.decks = parseInt($("selDecks").value,10);
  dealNewHand();
  persist(); render();
};

$("selAccent").onchange = ()=>{
  state.settings.accent = $("selAccent").value;
  persist(); render();
};

function wireTileClicks(){
  // Hand tiles in Prep: click to add to current draft dish
  $("handTiles").addEventListener("click", (e)=>{
    const t = e.target.closest("[data-tile]");
    if(!t) return;
    const id = t.getAttribute("data-tile");
    // If remix selection is active (public tile selected), hand click goes to remix selection when Remix accordion is open:
    // MVP: choose behavior based on whether any public remix tiles are selected or if user is in "remix mindset"
    const anyPubSel = state.hand.draft.remixSelPublic.size > 0;
    if(anyPubSel && state.hand.kitchenOpen){
      toggleRemixHand(id);
    } else {
      toggleDishTileSelection(id);
    }
    persist(); render();
  });

  // Public tiles in Prep: click to select for remix
  $("publicTiles").addEventListener("click", (e)=>{
    const t = e.target.closest("[data-ptile]");
    if(!t) return;
    if(!state.hand.kitchenOpen){
      toast(GAME.toasts.remixNeedKitchen);
      return;
    }
    const id = t.getAttribute("data-ptile");
    toggleRemixPublic(id);
    persist(); render();
  });
}

/* =========================
   Auto-Plate (Beginner/Easy)
   ========================= */

function autoPlateIntoDraft(){
  // Simple: pick up to 2 best dishes from your hand that validate and maximize points
  const tiles = state.hand.players.P1.hand.slice();
  const combos = combosUpTo(tiles, GAME.rules.maxIngredientsPerDish);

  // Find best two non-overlapping dishes
  const candidates = [];
  for(const r of RECIPES.slice().sort((a,b)=>b.pts-a.pts)){
    for(const combo of combos){
      const names = combo.map(t=>t.name);
      const allowWetViaStarter = (r.key==="chips_and_dip" && !state.hand.kitchenOpen && !state.hand.starterPassUsed.P1);
      const v = validateDish(r.key, names, { allowWetViaStarterPass: allowWetViaStarter });
      if(v.ok){
        candidates.push({ recipeKey:r.key, tiles:combo, pts:r.pts });
      }
    }
  }
  candidates.sort((a,b)=>b.pts-a.pts);

  const picked = [];
  const used = new Set();
  for(const c of candidates){
    if(picked.length>=2) break;
    if(c.tiles.some(t=>used.has(t.id))) continue;
    picked.push(c);
    c.tiles.forEach(t=>used.add(t.id));
  }

  if(picked.length===0){
    toast("No auto-plates found.", 1600);
    return;
  }

  // Write into draft dishes
  state.hand.draft.dishes = picked.map(p=>({ id: uid("d"), recipeKey: p.recipeKey, tileIds: p.tiles.map(t=>t.id) }));
  state.hand.draft.idx = 0;
  toast("üçΩÔ∏è Auto-Plate loaded.", 1600);
}

/* =========================
   Hand setup
   ========================= */

function dealNewHand(){
  state.hand = newHandState();

  // Campaign kitchen persistence rule: once Kitchen is opened at least once in campaign, it stays open for future hands
  const persistKitchen = (state.settings.mode === "campaign");
  const alreadyUnlocked = persistKitchen && state.match.campaign && state.match.campaign.levelIndex >= 0 && state.match.campaign._kitchenUnlockedEver;
  if(alreadyUnlocked){
    state.hand.kitchenOpen = true;
    state.hand.kitchenOpenedBy = "Campaign Unlock";
  }

  // Build and shuffle bag
  state.hand.bag = shuffle(buildDeck(state.settings.decks));

  // Deal
  const pids = activePids();
  for(const pid of pids){
    for(let i=0;i<state.settings.tilesPerPlayer;i++){
      drawOne(pid);
    }
    resetTurnFlags(pid);
  }

  // Start with P1
  state.hand.active = "P1";
  resetTurnFlags("P1");

  // Ensure campaign level scores exist
  ensureCampaignLevelScores();

  // Draft defaults
  state.hand.draft.dishes = [makeDraftDish()];
  state.hand.draft.idx = 0;
  clearRemixSelection();

  // Set recipe selector default
  state.hand.draft.dishes[0].recipeKey = "taco";
}

function openKitchenPersistenceFlag(){
  if(state.settings.mode !== "campaign") return;
  if(!state.match.campaign) state.match.campaign = { levelIndex:0, roundInLevel:1, levelScores:{} };
  state.match.campaign._kitchenUnlockedEver = true;
}

const _origPublishDraftFromPrep = publishDraftFromPrep;
publishDraftFromPrep = function(){
  const wasClosed = !state.hand.kitchenOpen;
  const beforeTotal = calcDraftTotalPts();
  _origPublishDraftFromPrep();

  // If kitchen opened this publish and we‚Äôre in campaign, persist unlock
  if(state.settings.mode === "campaign" && wasClosed && state.hand.kitchenOpen && beforeTotal >= GAME.rules.publishToOpenKitchenThreshold){
    openKitchenPersistenceFlag();
  }
};

const _origCpuPublishTurn = cpuPublishTurn;
cpuPublishTurn = function(pid){
  const wasClosed = !state.hand.kitchenOpen;
  const res = _origCpuPublishTurn(pid);
  if(state.settings.mode === "campaign" && wasClosed && state.hand.kitchenOpen){
    openKitchenPersistenceFlag();
  }
  return res;
};

/* =========================
   Persistence
   ========================= */

const LS_KEY = "tacoria_state_v090";

function persist(){
  try{
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }catch(e){}
}

function load(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return null;
    const s = JSON.parse(raw);
    return s;
  }catch(e){
    return null;
  }
}

/* =========================
   Start / Init
   ========================= */

function startNewMatch(showToast){
  state = defaultState();
  dealNewHand();
  persist();
  setScreen("screenGame");
  render();
  if(showToast) toast("üåÆ New match started.", 1500);
}

function init(){
  bindSkipCpu();
  wireTileClicks();

  const s = load();
  if(s){
    state = s;

    // Backward-compat / safety
    if(!state.settings) state.settings = defaultState().settings;
    if(!state.match) state.match = defaultState().match;
    if(!state.hand) dealNewHand();

    // Ensure campaign structure exists
    if(state.settings.mode === "campaign"){
      if(!state.match.campaign) state.match.campaign = { levelIndex:0, roundInLevel:1, levelScores:{} };
      if(!state.match.campaign.levelScores) state.match.campaign.levelScores = {};
      ensureAllCampaignLevelScores();
    }

    // Ensure sets rehydrated
    if(state.hand?.draft){
      if(!(state.hand.draft.remixSelHand instanceof Set)) state.hand.draft.remixSelHand = new Set(state.hand.draft.remixSelHand || []);
      if(!(state.hand.draft.remixSelPublic instanceof Set)) state.hand.draft.remixSelPublic = new Set(state.hand.draft.remixSelPublic || []);
    }

    render();
    // If it's a CPU turn on load, continue
    if(state.hand.active !== "P1") runCpuLoop();
  } else {
    startNewMatch(false);
  }
}
init();
</script>
</body>
</html>
