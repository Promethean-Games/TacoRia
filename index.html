<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Taco Ria</title>
  <style>
    :root{
      --bg:#050608;
      --bg2:#0a0c10;
      --text:#f3f4f6;
      --muted:rgba(243,244,246,.70);
      --muted2:rgba(243,244,246,.55);
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.14);
      --danger:#ff3b30;

      --accent:#00e5ff; /* user-configurable secondary */
      --accentSoft: rgba(0,229,255,.14);

      --radius:20px;
      --pad:16px;
      --gap:12px;
      --shadow: 0 18px 45px rgba(0,0,0,.55);

      --navH:56px;

      /* category colors (cognitive offloading) */
      --cTortilla:#ffcc00;
      --cProtein:#ff3b30;
      --cDry:#a3ff12;
      --cWet:#00e5ff;
      --cDip:#b36bff;
      --cSides:#ff8a00;
      --cWild:#ffffff;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(900px 380px at 18% 0%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(780px 360px at 85% 10%, rgba(255,255,255,.05), transparent 65%),
        radial-gradient(820px 420px at 50% 115%, rgba(0,0,0,.75), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow-x:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    /* Mobile guideline widths */
    .shell{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      width:100%;
      margin:0 auto;
      max-width: 980px;
    }
    @media (max-width: 430px){
      .shell{ max-width: 375px; }
    }
    @media (max-width: 390px){
      .shell{ max-width: 360px; }
    }

    header{
      padding: 14px 14px 10px;
      min-height:56px;
    }
    main{
      flex:1;
      padding: 0 14px calc(var(--navH) + env(safe-area-inset-bottom) + 18px);
    }

    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ min-width:0; }
    .wrap{ flex-wrap:wrap; }
    .sp{ justify-content:space-between; }

    .pageTitle{
      font-weight:1000;
      letter-spacing:.2px;
      line-height:1.08;
      font-size: clamp(20px, 4.7vw, 28px);
    }
    .small{ font-size:12px; }
    .muted{ color:var(--muted); }
    .muted2{ color:var(--muted2); }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.065), rgba(255,255,255,.035));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: var(--shadow);
    }

    .heroPhase{
      position:relative;
      overflow:hidden;
    }
    .heroPhase::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(600px 240px at 20% 0%, rgba(255,255,255,.08), transparent 65%),
        radial-gradient(520px 240px at 85% 10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(540px 260px at 50% 120%, rgba(0,0,0,.60), transparent 55%);
      pointer-events:none;
    }
    .heroPhase > *{ position:relative; z-index:1; }

    .pills{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    button{
      border:1px solid var(--stroke2);
      background: rgba(0,0,0,.35);
      color:var(--text);
      border-radius: 18px;
      padding: 12px 14px;
      font-weight:1000;
      letter-spacing:.2px;
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }
    .btnTiny{ padding:8px 10px; border-radius:14px; font-size:12px; }
    .ghost{ background: rgba(0,0,0,.20); }
    .primary{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border-color: rgba(255,255,255,.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 20px rgba(0,0,0,.55);
    }
    .danger{
      background: linear-gradient(180deg, rgba(255,59,48,.22), rgba(255,59,48,.10));
      border-color: rgba(255,59,48,.35);
    }

    /* Jumbo gameplay controls */
    .jumboGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .jumboGrid button{
      min-height:72px;
      font-size:18px;
      border-radius: 22px;
    }
    @media (max-width: 420px){
      .jumboGrid{ grid-template-columns: 1fr; }
      .jumboGrid button{ min-height:74px; font-size:18px; }
    }

    /* Sticky action tray above bottom nav */
    .actionsTray{
      position: sticky;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom));
      z-index: 30;
    }

    /* Tiles */
    .tiles{ display:flex; flex-wrap:wrap; gap:8px; }
    .tile{
      max-width:100%;
      overflow-wrap:anywhere;
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.14);
      background:
        linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      font-weight: 950;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      position:relative;
      transition: transform .12s ease, outline-color .12s ease, background .12s ease, color .12s ease;
    }
    /* Category tint */
    .tile[data-cat]::before{
      content:"";
      position:absolute; inset:0;
      border-radius:999px;
      background: linear-gradient(135deg, rgba(0,0,0,.10), rgba(0,0,0,.10));
      opacity:1;
      pointer-events:none;
    }
    .tile[data-cat="tortilla"]{ border-color: rgba(255,255,255,.18); box-shadow: 0 0 0 1px rgba(0,0,0,.18) inset; }
    .tile[data-cat="protein"]{ border-color: rgba(255,255,255,.18); }
    .tile[data-cat="dry"]{ border-color: rgba(255,255,255,.18); }
    .tile[data-cat="wet"]{ border-color: rgba(255,255,255,.18); }
    .tile[data-cat="dip"]{ border-color: rgba(255,255,255,.18); }
    .tile[data-cat="sides"]{ border-color: rgba(255,255,255,.18); }
    .tile[data-cat="wild"]{ border-color: rgba(255,255,255,.24); }

    .tile[data-cat="tortilla"]{ background: linear-gradient(180deg, rgba(255,204,0,.14), rgba(255,204,0,.06)); }
    .tile[data-cat="protein"]{ background: linear-gradient(180deg, rgba(255,59,48,.14), rgba(255,59,48,.06)); }
    .tile[data-cat="dry"]{ background: linear-gradient(180deg, rgba(163,255,18,.14), rgba(163,255,18,.06)); }
    .tile[data-cat="wet"]{ background: linear-gradient(180deg, rgba(0,229,255,.14), rgba(0,229,255,.06)); }
    .tile[data-cat="dip"]{ background: linear-gradient(180deg, rgba(179,107,255,.14), rgba(179,107,255,.06)); }
    .tile[data-cat="sides"]{ background: linear-gradient(180deg, rgba(255,138,0,.14), rgba(255,138,0,.06)); }
    .tile[data-cat="wild"]{ background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05)); }

    /* Selected: bold fill using accent for instant recognition */
    .tile.sel{
      background: linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.10)), var(--accent);
      color:#06080b;
      border-color: rgba(255,255,255,.12);
      outline: 2px solid rgba(255,255,255,.12);
      transform: translateY(-1px);
      text-shadow:none;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
    }

    /* Public grouping */
    .pubGroups{
      display:grid;
      grid-template-columns: 1fr 1fr; /* 50% width */
      gap:10px;
    }
    @media (max-width: 420px){
      .pubGroups{ grid-template-columns: 1fr; }
    }
    .pubGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      padding:12px;
    }
    .pubGroupTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
      margin-bottom: 8px;
    }
    .pubDishRow{
      border:1px solid var(--stroke);
      border-radius:16px;
      background: rgba(0,0,0,.45);
      padding:10px;
      margin-top:10px;
      position:relative;
      overflow:hidden;
    }
    .pubDishRow::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, var(--tintA), transparent 70%);
      opacity:.95;
      pointer-events:none;
    }
    .pubDishRow > *{ position:relative; z-index:1; }
    .pubDishMeta{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
    }

    /* Accordion */
    details.acc{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    details.acc + details.acc{ margin-top:10px; }
    details.acc summary{
      list-style:none;
      cursor:pointer;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:1000;
    }
    details.acc summary::-webkit-details-marker{ display:none; }
    .accBody{ padding: 0 14px 14px; }
    .field{ margin-top:10px; }
    .label{ font-size:12px; color:var(--muted); margin-bottom:6px; font-weight:900; }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; line-height:1.35; }

    /* Dark select fix (best-effort) */
    :root{ color-scheme: dark; }
    select, input[type="number"]{
      width:100%;
      padding:12px 40px 12px 14px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background:#0b0b0b;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      appearance:none;
      -webkit-appearance:none;
      outline:none;
    }
    select option{
      background:#0b0b0b;
      color: rgba(255,255,255,.92);
    }
    .selectWrap{ position:relative; }
    .selectWrap::after{
      content:"‚ñæ";
      position:absolute;
      right:14px; top:50%;
      transform: translateY(-50%);
      opacity:.75;
      pointer-events:none;
      font-weight:1000;
    }

    /* Footer nav */
    nav.footer{
      position:fixed;
      left:0; right:0; bottom:0;
      height: var(--navH);
      padding-bottom: env(safe-area-inset-bottom);
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      z-index: 40;
    }
    .navBtn{
      flex:1;
      min-height:56px;
      border:none;
      border-right: 1px solid rgba(255,255,255,.06);
      background: transparent;
      color: rgba(255,255,255,.86);
      font-weight:1000;
      border-radius: 0;
      padding: 8px 6px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:2px;
    }
    .navBtn:last-child{ border-right:none; }
    .navBtn.active{
      color:#fff;
      background: radial-gradient(320px 120px at 50% 0%, rgba(0,229,255,.20), transparent 60%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .navBtn .ic{ font-size:16px; }
    .navBtn .tx{ font-size:12px; }

    /* Toast */
    #toastWrap{
      position:fixed;
      left:0; right:0;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom) + 12px);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 80;
    }
    .toast{
      max-width:min(560px, calc(100% - 24px));
      background: rgba(0,0,0,.78);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,.65);
      font-weight: 900;
      pointer-events:none;
    }

    /* Modal */
    #modalWrap{
      position:fixed; inset:0;
      background: rgba(0,0,0,.65);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 90;
    }
    #modalWrap.on{ display:flex; }
    .modal{
      width: min(560px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: 0 22px 60px rgba(0,0,0,.70);
      padding: 14px;
    }
    .modal h3{ margin: 4px 0 8px; font-size: 18px; }
    .modal .body{ color: var(--muted); font-weight: 900; line-height: 1.35; }
    .modal .foot{ margin-top: 12px; display:flex; gap:10px; justify-content:flex-end; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    /* Tutorial carousel */
    .tutWrap{ overflow:hidden; border-radius:18px; border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.30); }
    .tutTrack{
      display:flex;
      width:100%;
      transition: transform .28s ease;
      will-change: transform;
    }
    .tutPage{
      flex:0 0 100%;
      padding:14px;
      min-height: 180px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:10px;
    }
    .tutTitle{ font-weight:1000; color: var(--text); font-size:16px; }
    .tutText{ color: var(--muted); font-weight:900; line-height:1.35; }
    .dots{ display:flex; gap:6px; justify-content:center; margin-top:10px; }
    .dot{ width:7px; height:7px; border-radius:99px; background: rgba(255,255,255,.22); }
    .dot.on{ background: rgba(255,255,255,.72); }
    .tutEmoji{ font-size:22px; }

    /* Page visibility */
    .page{ display:none; }
    .page.on{ display:block; }

    /* Wrap safety */
    h1,h2,h3,p,div,span{ overflow-wrap:anywhere; word-break:break-word; }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="row sp">
        <div>
          <div class="row" style="gap:10px;">
            <div class="pageTitle">Taco Ria</div>
            <span class="pill"><span class="mono" id="verPill">v0.9.3</span></span>
          </div>
          <div class="muted small" id="subTitle">Rummikub-style recipe drafting ‚Ä¢ Private Prep + Public Line + Remix</div>
        </div>
        <button class="ghost btnTiny" id="btnNewMatchTop">New Match</button>
      </div>
    </header>

    <main>
      <!-- GAMEPLAY (simplified) -->
      <section class="page on" id="pageGameplay">
        <div class="card heroPhase" style="margin-bottom:12px;">
          <div class="pills" style="margin-top:2px;">
            <span class="pill" id="tilesRemainBadge">Tiles Remaining 0</span>
            <span class="pill" id="kitchenBadge">Kitchen Closed</span>
          </div>

          <div style="margin-top:12px;">
            <div style="font-weight:1000; font-size:16px;" id="phaseTitle">Not Seated Yet</div>
            <div class="muted" id="phaseDesc">Serve 10+ points in one turn to open the kitchen.</div>
          </div>
        </div>

        <div class="actionsTray">
          <div class="card">
            <div class="muted small" style="margin-bottom:10px;" id="turnHint">Your Turn</div>
            <div class="jumboGrid">
              <button class="primary" id="btnDraw">Draw Tile</button>
              <button class="danger" id="btnEndTurn">End Turn</button>
            </div>
            <div class="muted small" style="margin-top:10px;" id="actionSubHint">
              Draw exactly <b>1</b> tile before ending your turn (unless no tiles remain).
            </div>
            <div class="row" style="margin-top:10px; justify-content:flex-end; display:none;" id="campaignSkipRow">
              <button class="ghost btnTiny" id="btnSkipCPU">Skip CPU</button>
            </div>
          </div>
        </div>

        <!-- PUBLIC LINE -->
        <div class="card" style="margin-top:12px;">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Public Line / Window</div>
            <span class="pill" id="lineSummary">0 dishes</span>
          </div>
          <div id="publicLine"></div>
        </div>
      </section>

      <!-- PREP -->
      <section class="page" id="pagePrep">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Prep</div>
            <div class="row wrap" style="gap:8px; justify-content:flex-end;">
              <button class="primary btnTiny" id="btnOrderUp">Order Up!</button>
              <button class="ghost btnTiny" id="btnServeSel">Serve Selected</button>
              <span class="badge">Private Drafting</span>
            </div>
          </div>

          <details class="acc" open>
            <summary>
              <span>Your Hand</span>
              <span class="muted2 small" id="handCountHint">0 tiles</span>
            </summary>
            <div class="accBody">
              <div id="handGroups"></div>

              <div class="row wrap" style="margin-top:12px; justify-content:space-between;">
                <div class="row wrap" style="gap:10px;">
                  <button class="ghost btnTiny" id="btnNewDish">+ New Dish</button>
                  <button class="ghost btnTiny" id="btnClearDish">Clear Dish</button>
                </div>
                <div class="row wrap" style="gap:10px;">
                  <button class="primary btnTiny" id="btnAutoPlate" style="display:none;">Auto-Plate</button>
                  <button class="primary btnTiny" id="btnAutoRemix" style="display:none;">Auto-Remix</button>
                </div>
              </div>

              <div class="hint" id="autoHint" style="margin-top:10px;">
                Tap tiles to add/remove from your current dish.
              </div>
            </div>
          </details>

          <details class="acc" open>
            <summary>
              <span>Current Dish</span>
              <span class="muted2 small" id="dishMeta">‚Äî</span>
            </summary>
            <div class="accBody">
              <div class="field">
                <div class="label">Recipe</div>
                <div class="selectWrap">
                  <select id="selRecipe"></select>
                </div>
              </div>

              <div class="field">
                <div class="label">Dish Tiles</div>
                <div class="tiles" id="dishTiles"></div>
              </div>

              <div class="row wrap" style="margin-top:12px; justify-content:flex-end;">
                <button class="ghost btnTiny" id="btnRemoveDish">Remove Dish</button>
              </div>

              <div class="hint" id="dishHint"></div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Public Tiles (for Remix)</span>
              <span class="muted2 small">Grouped</span>
            </summary>
            <div class="accBody">
              <div id="publicTiles"></div>
              <div class="hint">
                Once Kitchen is open, you may select public tiles to remix into a new dish (no loose ingredients).
              </div>
            </div>
          </details>
        </div>
      </section>

      <!-- SCORES -->
      <section class="page" id="pageScores">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Scores</div>
            <span class="badge" id="scoreModePill">Standard</span>
          </div>

          <div class="row wrap" style="gap:10px; margin-bottom:12px;">
            <span class="pill" id="scoreCurrent">Current: 0</span>
            <span class="pill" id="scorePending">Pending: 0</span>
            <span class="pill" id="scoreServed">Served this hand: 0</span>
          </div>

          <div id="scoreList"></div>

          <details class="acc" id="campaignBoxAcc" style="margin-top:12px; display:none;">
            <summary>
              <span>Box Score</span>
              <span class="muted2 small">Chapters + Total</span>
            </summary>
            <div class="accBody" id="campaignBoxBody"></div>
          </details>

          <div class="hint" style="margin-top:10px;">
            End-of-hand penalty is <b>-1</b> per tile remaining in your hand.
          </div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="page" id="pageSettings">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Settings</div>
            <div class="row" style="gap:10px;">
              <button class="ghost btnTiny" id="btnTutorial">Tutorial</button>
              <span class="badge">v<span class="mono">0.9.3</span></span>
            </div>
          </div>
          <div class="muted small">Primary theme stays black. Choose a high-contrast accent.</div>

          <details class="acc" open style="margin-top:12px;">
            <summary>
              <span>Match</span>
              <span class="muted2 small">Mode + Players</span>
            </summary>
            <div class="accBody">
              <div class="row wrap" style="gap:12px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Mode</div>
                  <div class="selectWrap">
                    <select id="selMode">
                      <option value="standard">Standard Match</option>
                      <option value="campaign">Campaign</option>
                    </select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Players</div>
                  <div class="selectWrap">
                    <select id="selPlayers">
                      <option value="2">2 Players</option>
                      <option value="3">3 Players</option>
                      <option value="4" selected>4 Players</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">CPU Difficulty (Standard only)</div>
                  <div class="selectWrap">
                    <select id="selDifficulty"></select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Hands (Standard only)</div>
                  <input type="number" id="inpHands" min="1" max="12" value="12" />
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Tiles per Player</div>
                  <input type="number" id="inpTilesPerPlayer" min="8" max="24" value="16" />
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Decks</div>
                  <div class="selectWrap">
                    <select id="selDecks">
                      <option value="1">1 Deck</option>
                      <option value="2" selected>2 Decks (Recommended)</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="hint">
                Campaign auto-walks difficulty: Beginner ‚Üí Easy ‚Üí Medium ‚Üí Difficult ‚Üí Master Chef.
                Skip button appears during CPU turns in Campaign only. Kitchen stays open after first unlock.
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Theme</span>
              <span class="muted2 small">Accent Color</span>
            </summary>
            <div class="accBody">
              <div class="label">Accent</div>
              <div class="selectWrap">
                <select id="selAccent"></select>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Language</span>
              <span class="muted2 small">English / Espa√±ol</span>
            </summary>
            <div class="accBody">
              <div class="label">App Language</div>
              <div class="selectWrap">
                <select id="selLang">
                  <option value="en">English</option>
                  <option value="es">Espa√±ol</option>
                </select>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Menu Reference</span>
              <span class="muted2 small">What ‚Äúvalid‚Äù looks like</span>
            </summary>
            <div class="accBody" id="menuRef"></div>
          </details>

          <div class="hint" style="margin-top:12px;">
            Starter Pass: before you unlock, you may serve one Chips & Dip per hand without unlocking remix.
            <br/>First laydown: tacos must use dry toppings (no salsa/queso/guac).
          </div>
        </div>
      </section>
    </main>
  </div>

  <nav class="footer">
    <button class="navBtn active" id="navGame"><div class="ic">üé≠</div><div class="tx">Gameplay</div></button>
    <button class="navBtn" id="navPrep"><div class="ic">üç≥</div><div class="tx">Prep</div></button>
    <button class="navBtn" id="navScores"><div class="ic">üèÜ</div><div class="tx">Scores</div></button>
    <button class="navBtn" id="navSettings"><div class="ic">‚öôÔ∏è</div><div class="tx">Settings</div></button>
  </nav>

  <div id="toastWrap"></div>

  <div id="modalWrap">
    <div class="modal">
      <h3 id="modalTitle">Modal</h3>
      <div class="body" id="modalBody"></div>
      <div class="foot" id="modalFoot"></div>
    </div>
  </div>

  <script>
    /* =========================
       Taco Ria v0.9.3 (Atomic UX + offloading)
       ========================= */

    const VERSION = "v0.9.3";
    const LS_KEY = "taco_ria_state_v093";
    const LS_TUT = "taco_ria_tutorial_seen_v093";

    const DIFFS = ["Beginner","Easy","Medium","Difficult","Master Chef"];
    const DIFF_DELAY_MS = { "Beginner":5000, "Easy":3500, "Medium":2200, "Difficult":1200, "Master Chef":500 };

    const CPU_CHARACTERS = {
      chefMike:  { name:"Chef Mike",  speedFixedMs:650,  jitterMs:120, sloppyRate:0.28, appetizerBias:0.10, remixBias:0.90, color:"#ff3b30" },
      salsaSam:  { name:"Salsa Sam",  speedMult:1.00,   jitterMs:220, sloppyRate:0.10, appetizerBias:0.20, remixBias:1.00, color:"#b36bff" },
      quesoQueen:{ name:"Queso Queen",speedMult:1.12,   jitterMs:260, sloppyRate:0.08, appetizerBias:0.78, remixBias:0.95, color:"#ffcc00" },
      grillGuru: { name:"Grill Guru", speedMult:0.85,   jitterMs:160, sloppyRate:0.04, appetizerBias:0.15, remixBias:1.35, color:"#a3ff12" }
    };

    const ACCENTS = [
      { name:"Neon Cyan", val:"#00e5ff" },
      { name:"Signal Yellow", val:"#ffcc00" },
      { name:"Lime", val:"#a3ff12" },
      { name:"Hot Pink", val:"#ff2bd6" },
      { name:"Orange", val:"#ff8a00" },
      { name:"Ice", val:"#b3f6ff" },
      { name:"Violet", val:"#b36bff" },
      { name:"Red", val:"#ff3b30" }
    ];

    const I18N = {
      en: {
        gameplay:"Gameplay", prep:"Prep", scores:"Scores", settings:"Settings",
        orderUp:"Order Up!", drawTile:"Draw Tile", serveSelected:"Serve Selected", endTurn:"End Turn",
        yourTurn:"Your Turn", notYourTurn:"Not your turn.",
        kitchenOpen:"Kitchen Open", kitchenClosed:"Kitchen Closed",
        tilesRemaining:"Tiles Remaining",
      },
      es: {
        gameplay:"Juego", prep:"Preparaci√≥n", scores:"Puntos", settings:"Ajustes",
        orderUp:"¬°Orden lista!", drawTile:"Robar ficha", serveSelected:"Servir seleccionadas", endTurn:"Terminar turno",
        yourTurn:"Tu turno", notYourTurn:"No es tu turno.",
        kitchenOpen:"Cocina abierta", kitchenClosed:"Cocina cerrada",
        tilesRemaining:"Fichas restantes",
      }
    };

    /* ===== Menu / Rules ===== */
    const RULES = {
      remixMinPoints: 5,
      tacoDryToppingCount: 3,
      tacoMaxTiles: 7,               // tortilla + protein + (optional cheese) + (optional wet) + 3 dry toppings
      wetLockedUntilKitchen: true,
      starterPassDishKey: "chipsDip", // 1 per hand, doesn't unlock kitchen
      mustDrawOncePerTurn: true,
    };

    const RECIPES = [
      { key:"hardTaco", name:"Hard Shell Taco", pts:5, kind:"taco", tortilla:"Corn Tortillas" },
      { key:"softTaco", name:"Soft Taco", pts:5, kind:"taco", tortilla:"Flour Tortillas" },
      { key:"breakfastTaco", name:"Breakfast Taco", pts:7, kind:"breakfastTaco" },
      { key:"chorizoTaco", name:"Chorizo Taco", pts:8, kind:"chorizoTaco" },
      { key:"chipsDip", name:"Chips & Dip", pts:5, kind:"chipsDip" },
      { key:"pico", name:"Pico de Gallo", pts:8, kind:"pico" },
      { key:"ench", name:"Enchiladas", pts:10, kind:"ench" },
    ];

    const MENU_REFERENCE = [
      { title:"Hard Shell Taco", pts:5, desc:"Corn Tortilla + Protein + 3 Dry Toppings. Optional: Cheese (+1), Wet (+1) after Kitchen Open. Max 7 tiles." },
      { title:"Soft Taco", pts:5, desc:"Flour Tortilla + Protein + 3 Dry Toppings. Optional: Cheese (+1), Wet (+1) after Kitchen Open. Max 7 tiles." },
      { title:"Breakfast Taco", pts:7, desc:"Tortilla + Egg + 1 Topping (wet topping allowed only after Kitchen Open)." },
      { title:"Chorizo Taco", pts:8, desc:"Tortilla + Chorizo + Onion + Cilantro" },
      { title:"Chips & Dip", pts:5, desc:"Tortilla Chips + 1 dip (Salsa Roja / Salsa Verde / Guacamole / Queso)." },
      { title:"Pico de Gallo", pts:8, desc:"Tomato + Onion + Cilantro + Lime" },
      { title:"Enchiladas", pts:10, desc:"Tortilla + Protein + Sauce. Cheese optional (+1). (Chorizo allowed if Sauce included.)" },
    ];

    /* ===== Deck definition (single deck counts from user list) ===== */
    const DECK_ING_COUNTS = [
      ["Fish",1],
      ["Ground Beef",2],
      ["Shredded Chicken",2],
      ["Carne Guisada",1],
      ["Al Pastor",1],
      ["Carnitas",1],
      ["Egg",2],
      ["Chicken Fajita",2],
      ["Chorizo",1],
      ["Tortilla Chips",3],
      ["Flour Tortillas",2],
      ["Corn Tortillas",2],
      ["Shredded yellow Cheese",2],
      ["Shredded white cheese",2],
      ["Rice",2],
      ["Charro Beans",1],
      ["Refried Beans",1],
      ["Black Beans",1],
      ["Cilantro",2],
      ["Jalapenos",2],
      ["Lettuce",1],
      ["Lime Juice",2],
      ["Onion",2],
      ["Tomato",2],
      ["Sour Cream",2],
      ["Avocado",2],
      ["Salsa Roja",2],
      ["Salsa Verde",2],
      ["Queso",2],
      ["Guacamole",2],
      ["Grocery Run",2], // wildcard
    ];

    /* ===== Utilities ===== */
    const $ = (id)=> document.getElementById(id);

    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;").replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }
    function randInt(n){ return Math.floor(Math.random()*n); }
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }
    function nowId(prefix="id"){
      return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }

    function hexToRgba(hex, a){
      const h = (hex || "#ffffff").replace("#","").trim();
      const full = h.length===3 ? h.split("").map(c=>c+c).join("") : h.padEnd(6,"0").slice(0,6);
      const n = parseInt(full,16);
      const r=(n>>16)&255, g=(n>>8)&255, b=n&255;
      return `rgba(${r},${g},${b},${a})`;
    }

    function groupBy(arr, keyFn){
      const m = {};
      for(const it of arr){
        const k = keyFn(it);
        (m[k] ||= []).push(it);
      }
      return m;
    }

    function toast(msg, ms=2200){
      const wrap = $("toastWrap");
      wrap.innerHTML = `<div class="toast">${escapeHtml(msg)}</div>`;
      clearTimeout(toast._t);
      toast._t = setTimeout(()=> wrap.innerHTML="", ms);
    }

    function openModal(title, html, footButtons){
      $("modalTitle").textContent = title;
      $("modalBody").innerHTML = html;
      $("modalFoot").innerHTML = "";
      for(const b of footButtons){
        const btn = document.createElement("button");
        btn.className = b.className || "ghost";
        btn.textContent = b.text;
        btn.onclick = ()=> b.onClick?.();
        $("modalFoot").appendChild(btn);
      }
      $("modalWrap").classList.add("on");
    }
    function closeModal(){
      $("modalWrap").classList.remove("on");
    }
    $("modalWrap").addEventListener("click",(e)=>{
      if(e.target.id==="modalWrap") closeModal();
    });

    /* ===== Ingredient classification ===== */
    function isWild(name){ return name==="Grocery Run"; }

    function isTortilla(name){
      return name==="Corn Tortillas" || name==="Flour Tortillas";
    }
    function isProtein(name){
      return ["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"].includes(name);
    }
    function isCheese(name){
      return name==="Shredded yellow Cheese" || name==="Shredded white cheese";
    }
    function isSauce(name){
      return name==="Salsa Roja" || name==="Salsa Verde";
    }
    function isWet(name){
      // wet ingredients (for taco wet-lock). Appetizers are exempt via recipe validation.
      return ["Salsa Roja","Salsa Verde","Queso","Guacamole"].includes(name);
    }
    function isDip(name){
      return ["Salsa Roja","Salsa Verde","Guacamole","Queso"].includes(name);
    }

    function isDryTacoTopping(name){
      return ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Avocado"].includes(name);
    }

    function isSide(name){
      return ["Rice","Charro Beans","Refried Beans","Black Beans","Lime Juice"].includes(name);
    }

    function tileCategory(name){
      if(isWild(name)) return { key:"wild", label:"Wildcard" };
      if(isTortilla(name)) return { key:"tortilla", label:"Tortillas" };
      if(isProtein(name)) return { key:"protein", label:"Proteins" };
      if(isCheese(name)) return { key:"dry", label:"Cheese" }; // visually grouped with dry
      if(name==="Tortilla Chips") return { key:"sides", label:"Chips / Sides" };
      if(isDip(name) && (name==="Queso" || name==="Guacamole")) return { key:"dip", label:"Dips" };
      if(isSauce(name)) return { key:"wet", label:"Salsas / Sauce" };
      if(isDryTacoTopping(name)) return { key:"dry", label:"Dry Toppings" };
      if(isSide(name)) return { key:"sides", label:"Sides" };
      // fallbacks
      if(isWet(name)) return { key:"wet", label:"Wet" };
      return { key:"dry", label:"Toppings" };
    }

    function recipeByKey(k){ return RECIPES.find(r=>r.key===k); }

    /* ===== State ===== */
    function defaultState(){
      return {
        settings:{
          accent:"#00e5ff",
          lang:"en",
          mode:"standard",          // standard | campaign
          players:4,
          difficulty:"Beginner",    // standard only
          handsTotal:12,
          tilesPerPlayer:16,
          decks:2,
        },
        campaign:{
          active:false,
          chapterIndex:0,
          chapterHands:12,
          chapterScores:[], // {diff,total}
          kitchenUnlockedEver:false,
        },
        match: null,
        ui:{
          page:"gameplay",
          serveSel: [],
          currentDishId: null,
          pendingAutoRemix: null,
        }
      };
    }

    function persist(){
      localStorage.setItem(LS_KEY, JSON.stringify(state));
    }

    function load(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return null;
        return JSON.parse(raw);
      }catch(e){
        return null;
      }
    }

    let state = load() || defaultState();

    /* ===== Match / Hand ===== */
    function buildDeck(decks=2){
      const tiles = [];
      for(let d=0; d<decks; d++){
        for(const [name,count] of DECK_ING_COUNTS){
          for(let i=0;i<count;i++){
            tiles.push({ id: nowId("t"), name });
          }
        }
      }
      return shuffle(tiles);
    }

    function cpuRoster(n){
      const chars = Object.values(CPU_CHARACTERS);
      const ids = ["P2","P3","P4"];
      return ids.slice(0, n-1).map((pid, i)=>({
        id: pid,
        charKey: Object.keys(CPU_CHARACTERS)[i % Object.keys(CPU_CHARACTERS).length],
        name: chars[i % chars.length].name
      }));
    }

    function mkPlayer(id, name, isHuman, charKey=null){
      return {
        id, name, isHuman,
        charKey,
        score: 0,
        servedThisHand: 0,
        hand: [],
        drafts: [],
        starterPassUsed: false,
        didDraw: false,     // per-turn
      };
    }

    function dealInitial(m){
      const tilesPer = state.settings.tilesPerPlayer;
      for(const pid of Object.keys(m.players)){
        m.players[pid].hand = [];
        for(let i=0;i<tilesPer;i++){
          const t = m.bag.pop();
          if(!t) break;
          m.players[pid].hand.push(t);
        }
      }
    }

    function newDraftDish(recipeKey){
      const r = recipeByKey(recipeKey);
      return {
        id: nowId("d"),
        recipeKey,
        name: r?.name || recipeKey,
        basePts: r?.pts || 0,
        tileIds: [],
      };
    }

    function initDraftingForP1(m){
      const p1 = m.players["P1"];
      p1.drafts = [];
      const d = newDraftDish("hardTaco");
      p1.drafts.push(d);
      state.ui.currentDishId = d.id;
    }

    function newMatch(){
      const m = {
        id: nowId("m"),
        handIndex: 1,
        kitchenOpen: false,
        bag: buildDeck(state.settings.decks),
        publicLine: [],
        players: {},
        activePid: "P1",
        servedThisTurnPts: 0,
      };

      const roster = cpuRoster(state.settings.players);
      m.players["P1"] = mkPlayer("P1","You", true);
      roster.forEach(r=>{
        m.players[r.id] = mkPlayer(r.id, r.name, false, r.charKey);
      });

      dealInitial(m);
      initDraftingForP1(m);

      if(state.settings.mode==="campaign"){
        state.campaign.active = true;
        state.campaign.chapterHands = 12;
        state.campaign.chapterIndex = state.campaign.chapterIndex || 0;
        state.campaign.chapterScores = state.campaign.chapterScores || [];
      }else{
        state.campaign.active = false;
        state.campaign.chapterIndex = 0;
        state.campaign.chapterScores = [];
        state.campaign.kitchenUnlockedEver = false;
      }

      // per-turn draw reset
      for(const p of Object.values(m.players)) p.didDraw = false;

      state.match = m;
      state.ui.page = "gameplay";
      state.ui.serveSel = [];
      state.ui.pendingAutoRemix = null;

      persist();
      render();
      toast("New match started.");
    }

    function p1(){ return state.match.players["P1"]; }
    function currentDish(){
      const pl = p1();
      return pl.drafts.find(d=>d.id===state.ui.currentDishId) || pl.drafts[0] || null;
    }

    function effectiveDifficulty(){
      if(state.settings.mode==="campaign"){
        const order = ["Beginner","Easy","Medium","Difficult","Master Chef"];
        const idx = state.campaign.chapterIndex || 0;
        return order[Math.min(order.length-1, idx)];
      }
      return state.settings.difficulty || "Beginner";
    }

    function cpuTurnDelayMs(pid){
      const diff = effectiveDifficulty();
      const base = DIFF_DELAY_MS[diff] ?? 2200;
      const p = state.match.players[pid];
      const ch = CPU_CHARACTERS[p.charKey] || CPU_CHARACTERS.salsaSam;

      if(ch.speedFixedMs != null){
        return Math.max(350, Math.min(base, ch.speedFixedMs)) + randInt(ch.jitterMs||0);
      }
      const mult = ch.speedMult ?? 1;
      const jit = ch.jitterMs || 0;
      return Math.max(350, Math.floor(base * mult) + randInt(jit));
    }

    function cpuCanRemix(){
      const diff = effectiveDifficulty();
      if(diff==="Beginner" || diff==="Easy" || diff==="Medium") return false;
      return true;
    }
    function autoPlateAllowed(){
      const diff = effectiveDifficulty();
      return diff==="Beginner" || diff==="Easy";
    }
    function autoRemixAllowed(){
      return effectiveDifficulty()==="Beginner";
    }

    /* ===== i18n ===== */
    function t(key){
      const lang = state.settings.lang || "en";
      return (I18N[lang] && I18N[lang][key]) || I18N.en[key] || key;
    }

    /* ===== Player colors for public line tinting ===== */
    function cpuChar(pid){
      const p = state.match.players[pid];
      const key = p.charKey || "salsaSam";
      return CPU_CHARACTERS[key] || CPU_CHARACTERS.salsaSam;
    }
    function playerColor(pid){
      if(pid==="P1") return state.settings.accent || "#00e5ff";
      return cpuChar(pid).color || "#ffffff";
    }

    /* ===== Validation + Points ===== */
    function computeDishPoints(recipeKey, tileObjs){
      const r = recipeByKey(recipeKey);
      const names = tileObjs.map(t=>t.name);

      if(r.kind==="taco"){
        let pts = r.pts; // base 5
        if(names.some(isCheese)) pts += 1;
        if(names.some(isWet)) pts += 1; // optional wet add-on after kitchen open
        return pts;
      }
      if(r.kind==="breakfastTaco"){
        return r.pts; // fixed 7 for now
      }
      if(r.kind==="ench"){
        let pts = r.pts; // base 10
        if(names.some(isCheese)) pts += 1; // optional
        return pts;
      }
      return r.pts;
    }

    function validateDish(recipeKey, tileObjs, ctx){
      const r = recipeByKey(recipeKey);
      const names = tileObjs.map(t=>t.name);

      const wildCount = names.filter(isWild).length;
      const nonWild = names.filter(n=>!isWild(n));

      const count = (fn)=> nonWild.filter(fn).length;

      const hasOrWild = (predicate)=>{
        return count(predicate) > 0 || wildCount > 0;
      };

      // helper: at least N items satisfy predicate (wilds can fill)
      const atLeastN = (predicate, n)=>{
        const c = count(predicate);
        return (c + wildCount) >= n;
      };

      if(r.kind==="taco"){
        const hasReqTortilla = nonWild.includes(r.tortilla) || (wildCount>0 && count(isTortilla)===0);
        const tortillaOk = hasOrWild(isTortilla);
        const proteinOk = hasOrWild(isProtein);

        // wet lock for tacos only (NOT for appetizers)
        if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          if(nonWild.some(isWet)) return { ok:false, reason:"Wet toppings are locked until Kitchen Open." };
        }

        if(!tortillaOk) return { ok:false, reason:"Tacos need 1 tortilla." };
        if(!hasReqTortilla) return { ok:false, reason:`Use ${r.tortilla} for this taco.` };
        if(!proteinOk) return { ok:false, reason:"Tacos need 1 protein." };

        // must have exactly 3 dry toppings (wilds can fill missing)
        const dryTopCount = count(isDryTacoTopping);
        const neededDry = Math.max(0, RULES.tacoDryToppingCount - dryTopCount);
        if(neededDry > wildCount) return { ok:false, reason:`Tacos need ${RULES.tacoDryToppingCount} dry toppings.` };

        // caps
        const maxTiles = RULES.tacoMaxTiles;
        if(tileObjs.length < 5) return { ok:false, reason:"Taco needs at least 5 tiles (tortilla + protein + 3 dry toppings)." };
        if(tileObjs.length > maxTiles) return { ok:false, reason:`Taco max is ${maxTiles} tiles.` };

        // allow optional cheese + optional wet (at most 1 wet)
        const wetCount = count(isWet);
        if(wetCount > 1) return { ok:false, reason:"Tacos may include at most 1 wet add-on." };

        // do not allow >3 dry toppings
        if(dryTopCount > RULES.tacoDryToppingCount) return { ok:false, reason:`Tacos may include at most ${RULES.tacoDryToppingCount} dry toppings.` };

        return { ok:true };
      }

      if(r.kind==="breakfastTaco"){
        // tortilla + egg + 1 topping
        if(tileObjs.length !== 3) return { ok:false, reason:"Breakfast Taco needs 3 tiles." };
        const hasTort = hasOrWild(isTortilla);
        const hasEgg = nonWild.includes("Egg") || wildCount>0;
        const topping = nonWild.find(n => isDryTacoTopping(n) || isWet(n) || isCheese(n)) || (wildCount>0 ? "Grocery Run" : null);

        if(!hasTort) return { ok:false, reason:"Needs a tortilla." };
        if(!hasEgg) return { ok:false, reason:"Needs egg." };
        if(!topping) return { ok:false, reason:"Needs 1 topping." };

        // wet lock applies
        if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          if(nonWild.some(isWet)) return { ok:false, reason:"Wet toppings are locked until Kitchen Open." };
        }
        return { ok:true };
      }

      if(r.kind==="chorizoTaco"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Chorizo Taco needs 4 tiles." };
        const hasTort = hasOrWild(isTortilla);
        const hasChor = nonWild.includes("Chorizo") || wildCount>0;
        const hasOnion = nonWild.includes("Onion") || wildCount>0;
        const hasCil = nonWild.includes("Cilantro") || wildCount>0;
        if(!hasTort) return { ok:false, reason:"Needs a tortilla." };
        if(!hasChor) return { ok:false, reason:"Needs chorizo." };
        if(!hasOnion) return { ok:false, reason:"Needs onion." };
        if(!hasCil) return { ok:false, reason:"Needs cilantro." };
        return { ok:true };
      }

      if(r.kind==="chipsDip"){
        // chips + 1 dip; wet ALWAYS allowed here (explicitly)
        if(tileObjs.length !== 2) return { ok:false, reason:"Chips & Dip needs 2 tiles." };
        const hasChips = nonWild.includes("Tortilla Chips") || wildCount>0;
        const hasDip = count(isDip) >= 1 || wildCount>0;
        if(!hasChips) return { ok:false, reason:"Needs Tortilla Chips." };
        if(!hasDip) return { ok:false, reason:"Needs 1 dip (salsa/queso/guac)." };
        return { ok:true };
      }

      if(r.kind==="pico"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Pico needs 4 tiles." };
        const okTom = nonWild.includes("Tomato") || wildCount>0;
        const okOn  = nonWild.includes("Onion") || wildCount>0;
        const okCil = nonWild.includes("Cilantro") || wildCount>0;
        const okLim = nonWild.includes("Lime Juice") || wildCount>0;
        if(!okTom || !okOn || !okCil || !okLim) return { ok:false, reason:"Needs Tomato, Onion, Cilantro, Lime." };
        return { ok:true };
      }

      if(r.kind==="ench"){
        // tortilla + protein + sauce; cheese optional (+1)
        if(tileObjs.length !== 3 && tileObjs.length !== 4) return { ok:false, reason:"Enchiladas need 3‚Äì4 tiles." };
        const hasTort = hasOrWild(isTortilla);
        const hasProt = atLeastN(isProtein, 1);
        const hasSau  = atLeastN(isSauce, 1);
        if(!hasTort) return { ok:false, reason:"Needs tortillas." };
        if(!hasProt) return { ok:false, reason:"Needs protein." };
        if(!hasSau)  return { ok:false, reason:"Needs sauce." };
        return { ok:true };
      }

      return { ok:false, reason:"Unknown recipe." };
    }

    /* ===== Publishing / Scoring ===== */
    function publishSelectedDrafts(pid, draftIds){
      const m = state.match;
      const pl = m.players[pid];
      if(!pl) return { ok:false, msg:"No player." };

      const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };
      const drafts = pl.drafts.filter(d=> draftIds.includes(d.id));
      if(!drafts.length) return { ok:false, msg:"No drafts selected." };

      const resolved = drafts.map(d=>{
        const tiles = d.tileIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(d.recipeKey, tiles, ctx);
        const pts = v.ok ? computeDishPoints(d.recipeKey, tiles) : 0;
        return { d, tiles, v, pts };
      });

      const invalid = resolved.find(x=>!x.v.ok);
      if(invalid) return { ok:false, msg:`${invalid.d.name}: ${invalid.v.reason}` };

      // Starter pass rule: only Chips & Dip can score before unlock without unlocking kitchen (once/hand)
      let starterPassPts = 0;
      let nonStarterPts = 0;

      for(const x of resolved){
        if(!m.kitchenOpen){
          if(x.d.recipeKey === RULES.starterPassDishKey && !pl.starterPassUsed){
            starterPassPts += x.pts;
          }else{
            nonStarterPts += x.pts;
          }
        }else{
          nonStarterPts += x.pts;
        }
      }

      for(const x of resolved){
        const pub = {
          id: nowId("pub"),
          owner: pid,
          ownerName: pl.name,
          recipeKey: x.d.recipeKey,
          name: recipeByKey(x.d.recipeKey)?.name || x.d.name,
          points: x.pts,
          tiles: x.tiles.map(t=>({id:t.id, name:t.name})),
          isRemix: false,
          from: null
        };
        m.publicLine.push(pub);

        // Remove tiles
        for(const t0 of x.tiles){
          const idx = pl.hand.findIndex(h=>h.id===t0.id);
          if(idx>=0) pl.hand.splice(idx,1);
        }

        pl.score += x.pts;
        pl.servedThisHand += x.pts;
      }

      if(!m.kitchenOpen){
        const usedStarter = resolved.some(x=> x.d.recipeKey===RULES.starterPassDishKey);
        if(usedStarter && !pl.starterPassUsed) pl.starterPassUsed = true;
      }

      // Unlock check (10+ in ONE TURN excluding starter pass)
      m.servedThisTurnPts += nonStarterPts;
      if(!m.kitchenOpen && m.servedThisTurnPts >= 10){
        m.kitchenOpen = true;
        if(state.campaign.active) state.campaign.kitchenUnlockedEver = true;
        toast("üî• Kitchen Open!");
      }

      // Remove served drafts
      pl.drafts = pl.drafts.filter(d=> !draftIds.includes(d.id));
      if(pid==="P1" && pl.drafts.length===0){
        const nd = newDraftDish("hardTaco");
        pl.drafts.push(nd);
        state.ui.currentDishId = nd.id;
      }else if(pid==="P1"){
        if(!pl.drafts.some(d=>d.id===state.ui.currentDishId)){
          state.ui.currentDishId = pl.drafts[0]?.id || null;
        }
      }

      return { ok:true };
    }

    /* ===== End-of-hand (simple MVP) ===== */
    function endHandIfNeeded(){
      const m = state.match;
      const someoneOut = Object.values(m.players).some(p=>p.hand.length===0);
      if(!someoneOut) return false;

      for(const p of Object.values(m.players)){
        const pen = p.hand.length;
        p.score -= pen;
      }
      toast("Hand over. Penalties applied.");

      startNextHand();
      return true;
    }

    function startNextHand(){
      const m = state.match;
      m.handIndex += 1;
      m.servedThisTurnPts = 0;
      m.activePid = "P1";

      for(const p of Object.values(m.players)){
        p.servedThisHand = 0;
        p.starterPassUsed = false;
        p.didDraw = false;
        p.drafts = [];
      }

      if(state.settings.mode==="standard"){
        m.kitchenOpen = false;
      }else{
        m.kitchenOpen = !!state.campaign.kitchenUnlockedEver;
      }

      if(m.bag.length < 10) m.bag = buildDeck(state.settings.decks);

      dealInitial(m);
      initDraftingForP1(m);

      state.ui.serveSel = [];
      state.ui.pendingAutoRemix = null;

      persist();
      render();
    }

    /* ===== Drafting (P1) ===== */
    function setCurrentDish(id){
      state.ui.currentDishId = id;
      persist();
      render();
    }

    function toggleHandTileForDish(tileId){
      const m = state.match;
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      const pl = p1();
      const dish = currentDish();
      if(!dish) return;

      const tile = pl.hand.find(t=>t.id===tileId);
      if(!tile) return;

      const inDish = dish.tileIds.includes(tileId);
      if(inDish){
        dish.tileIds = dish.tileIds.filter(id=>id!==tileId);
        persist(); render();
        return;
      }

      // Enforce taco-specific caps live (UX)
      const r = recipeByKey(dish.recipeKey);
      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);
      if(r.kind==="taco"){
        if(isWet(tile.name) && RULES.wetLockedUntilKitchen && !kitchen){
          toast("Wet toppings are locked until Kitchen Open.");
          return;
        }
        const curNames = dish.tileIds.map(id => pl.hand.find(t=>t.id===id)?.name).filter(Boolean);
        const curDry = curNames.filter(isDryTacoTopping).length;
        const curWet = curNames.filter(isWet).length;

        if(isDryTacoTopping(tile.name) && curDry >= RULES.tacoDryToppingCount){
          toast(`Tacos can have only ${RULES.tacoDryToppingCount} dry toppings.`);
          return;
        }
        if(isWet(tile.name) && curWet >= 1){
          toast("Tacos may include only 1 wet add-on.");
          return;
        }
        if(dish.tileIds.length >= RULES.tacoMaxTiles){
          toast(`Tacos max is ${RULES.tacoMaxTiles} tiles.`);
          return;
        }
      }

      // Strict counts for smaller dishes
      if(r.kind==="chipsDip" && dish.tileIds.length >= 2){ toast("Chips & Dip is 2 tiles."); return; }
      if(r.kind==="pico" && dish.tileIds.length >= 4){ toast("Pico is 4 tiles."); return; }
      if(r.kind==="chorizoTaco" && dish.tileIds.length >= 4){ toast("Chorizo Taco is 4 tiles."); return; }
      if(r.kind==="breakfastTaco" && dish.tileIds.length >= 3){ toast("Breakfast Taco is 3 tiles."); return; }
      if(r.kind==="ench" && dish.tileIds.length >= 4){ toast("Enchiladas are 3‚Äì4 tiles."); return; }

      dish.tileIds.push(tileId);
      persist(); render();
    }

    function clearCurrentDish(){
      const d = currentDish();
      if(!d) return;
      d.tileIds = [];
      persist(); render();
    }

    function newDish(){
      const pl = p1();
      const d = newDraftDish("hardTaco");
      pl.drafts.push(d);
      setCurrentDish(d.id);
      toast("New dish added.");
    }

    function removeCurrentDish(){
      const pl = p1();
      if(pl.drafts.length <= 1){
        clearCurrentDish();
        toast("Cleared.");
        return;
      }
      const id = state.ui.currentDishId;
      pl.drafts = pl.drafts.filter(d=>d.id!==id);
      setCurrentDish(pl.drafts[0].id);
      toast("Dish removed.");
    }

    function updateCurrentDishRecipe(recipeKey){
      const d = currentDish();
      if(!d) return;
      d.recipeKey = recipeKey;
      const r = recipeByKey(recipeKey);
      d.name = r?.name || recipeKey;
      d.basePts = r?.pts || 0;
      d.tileIds = [];
      state.ui.serveSel = [];
      persist(); render();
    }

    /* ===== Auto-Plate (Beginner/Easy only) ===== */
    function findBestDishFromHand(hand, recipeKey, ctx){
      const r = recipeByKey(recipeKey);
      const byName = {};
      for(const t0 of hand){
        (byName[t0.name] ||= []).push(t0.id);
      }
      const pick = (name)=>{
        const arr = byName[name];
        if(arr && arr.length) return arr[0];
        return null;
      };
      const anyFrom = (names)=>{
        for(const n of names){
          const id = pick(n);
          if(id) return id;
        }
        return pick("Grocery Run");
      };

      if(r.kind==="taco"){
        const ids = [];
        const tort = pick(r.tortilla) || pick("Grocery Run");
        if(!tort) return null;
        ids.push(tort);

        const prot = anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]);
        if(!prot) return null;
        ids.push(prot);

        // 3 dry toppings
        const dryPool = ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Avocado"];
        const used = new Set(ids);

        for(let i=0;i<3;i++){
          let found = null;
          for(const n of dryPool){
            const arr = byName[n] || [];
            const id = arr.find(x=>!used.has(x));
            if(id){ found = id; break; }
          }
          if(!found){
            const w = (byName["Grocery Run"]||[]).find(x=>!used.has(x));
            if(!w) return null;
            found = w;
          }
          used.add(found);
          ids.push(found);
        }

        // optional cheese
        const cheese = anyFrom(["Shredded yellow Cheese","Shredded white cheese"]);
        if(cheese && !used.has(cheese)) ids.push(cheese);

        // optional wet (only if kitchen open)
        if(ctx.kitchenOpen){
          const wet = anyFrom(["Salsa Roja","Salsa Verde","Queso","Guacamole"]);
          if(wet && !used.has(wet) && ids.length < RULES.tacoMaxTiles) ids.push(wet);
        }

        const tiles = ids.map(id=> hand.find(t0=>t0.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      if(r.kind==="chipsDip"){
        const chips = pick("Tortilla Chips") || pick("Grocery Run");
        if(!chips) return null;
        const dip = anyFrom(["Salsa Roja","Salsa Verde","Guacamole","Queso"]);
        if(!dip) return null;
        const ids = [chips,dip];
        const tiles = ids.map(id=> hand.find(t0=>t0.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      if(r.kind==="pico"){
        const ids = [
          pick("Tomato") || pick("Grocery Run"),
          pick("Onion") || pick("Grocery Run"),
          pick("Cilantro") || pick("Grocery Run"),
          pick("Lime Juice") || pick("Grocery Run"),
        ].filter(Boolean);
        if(ids.length!==4) return null;
        const tiles = ids.map(id=> hand.find(t0=>t0.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      if(r.kind==="ench"){
        const base = [
          anyFrom(["Flour Tortillas","Corn Tortillas"]),
          anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]),
          anyFrom(["Salsa Roja","Salsa Verde"]),
        ].filter(Boolean);
        if(base.length!==3) return null;

        // optional cheese
        const chee = anyFrom(["Shredded yellow Cheese","Shredded white cheese"]);
        if(chee) base.push(chee);

        const tiles = base.map(id=> hand.find(t0=>t0.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: base };
      }

      if(r.kind==="breakfastTaco"){
        const ids = [
          anyFrom(["Flour Tortillas","Corn Tortillas"]),
          pick("Egg") || pick("Grocery Run"),
        ].filter(Boolean);
        if(ids.length!==2) return null;
        const toppingPool = ctx.kitchenOpen
          ? ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Avocado","Salsa Roja","Salsa Verde","Queso","Guacamole","Shredded yellow Cheese","Shredded white cheese"]
          : ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Avocado","Shredded yellow Cheese","Shredded white cheese"];
        const top = anyFrom(toppingPool);
        if(!top) return null;
        ids.push(top);

        const tiles = ids.map(id=> hand.find(t0=>t0.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      if(r.kind==="chorizoTaco"){
        const ids = [
          anyFrom(["Flour Tortillas","Corn Tortillas"]),
          pick("Chorizo") || pick("Grocery Run"),
          pick("Onion") || pick("Grocery Run"),
          pick("Cilantro") || pick("Grocery Run"),
        ].filter(Boolean);
        if(ids.length!==4) return null;
        const tiles = ids.map(id=> hand.find(t0=>t0.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      return null;
    }

    function autoPlate(){
      if(!autoPlateAllowed()) return;
      const m = state.match;
      if(m.activePid!=="P1"){ toast(t("notYourTurn")); return; }
      const pl = p1();
      const d = currentDish();
      if(!d) return;

      const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };
      const best = findBestDishFromHand(pl.hand, d.recipeKey, ctx);
      if(!best){ toast("No auto-plate found."); return; }

      d.tileIds = best.tileIds;
      persist(); render();
      toast("‚úÖ Auto-plate complete.");
    }

    /* ===== Beginner Auto-Remix (preview) ===== */
    function autoRemixPreview(){
      if(!autoRemixAllowed()) return;
      const m = state.match;
      if(m.activePid!=="P1"){ toast(t("notYourTurn")); return; }
      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);
      if(!kitchen){ toast("Kitchen must be open to remix."); return; }

      const cand = m.publicLine
        .filter(d=>d.points >= RULES.remixMinPoints)
        .sort((a,b)=> b.points - a.points);

      const target = cand.find(x=>x.owner!=="P1") || cand[0];
      if(!target){ toast("No remix targets (5+ pts)."); return; }

      state.ui.pendingAutoRemix = target.id;

      openModal(
        "Auto Remix Preview",
        `<div class="muted">
          <div><b>Target:</b> ${escapeHtml(target.name)} (${target.points} pts)</div>
          <div><b>From:</b> ${escapeHtml(target.ownerName)}</div>
          <div style="margin-top:10px"><b>Tiles:</b> ${target.tiles.map(t=>escapeHtml(t.name)).join(", ")}</div>
          <div class="muted2" style="margin-top:8px">Submit to steal and re-plate this dish as your remix, or cancel.</div>
        </div>`,
        [
          { text:"Cancel", className:"ghost", onClick: ()=>{ state.ui.pendingAutoRemix=null; closeModal(); } },
          { text:"Submit Remix", className:"primary", onClick: commitAutoRemix }
        ]
      );
    }

    function commitAutoRemix(){
      const m = state.match;
      const pid = "P1";
      const pl = m.players[pid];
      const id = state.ui.pendingAutoRemix;
      if(!id){ closeModal(); return; }

      const idx = m.publicLine.findIndex(d=>d.id===id);
      if(idx<0){ toast("Target gone."); state.ui.pendingAutoRemix=null; closeModal(); return; }

      const target = m.publicLine[idx];
      m.publicLine.splice(idx,1);

      const pub = {
        id: nowId("pub"),
        owner: pid,
        ownerName: pl.name,
        recipeKey: target.recipeKey,
        name: target.name,
        points: target.points,
        tiles: target.tiles.map(t=>({id: nowId("rt"), name:t.name})),
        isRemix: true,
        from: target.owner
      };
      m.publicLine.push(pub);

      pl.score += pub.points;
      pl.servedThisHand += pub.points;

      state.ui.pendingAutoRemix = null;
      closeModal();
      persist(); render();
      toast("üîÄ Remix plated. ‚úÖ");
    }

    /* ===== Turn flow ===== */
    function requireDrawOrBlockEnd(pid){
      const m = state.match;
      const pl = m.players[pid];
      if(!RULES.mustDrawOncePerTurn) return true;
      if(m.bag.length === 0) return true;
      if(pl.didDraw) return true;

      if(pid==="P1"){
        toast("You must draw 1 tile before ending your turn.");
        return false;
      }
      return true;
    }

    function endTurn(pid, fromCpu=false){
      const m = state.match;
      if(m.activePid !== pid) return;

      if(!fromCpu){
        if(!requireDrawOrBlockEnd(pid)) return;
      }

      if(endHandIfNeeded()){
        persist(); render();
        return;
      }

      // reset per-turn served counter (kitchen unlock threshold)
      m.servedThisTurnPts = 0;

      const order = Object.keys(m.players);
      const i = order.indexOf(pid);
      const next = order[(i+1)%order.length];
      m.activePid = next;

      // Reset next player's per-turn draw flag
      m.players[next].didDraw = false;

      persist();
      render();

      if(next !== "P1"){
        scheduleCpuTurn(next);
      }else{
        toast("Your turn.");
      }
    }

    /* ===== CPU turn (draw once + action) ===== */
    let cpuTimer = null;

    function scheduleCpuTurn(pid){
      clearTimeout(cpuTimer);
      const delay = cpuTurnDelayMs(pid);

      const showSkip = (state.settings.mode==="campaign");
      $("campaignSkipRow").style.display = showSkip ? "flex" : "none";
      $("btnSkipCPU").onclick = ()=>{
        clearTimeout(cpuTimer);
        cpuTimer = null;
        doCpuTurn(pid, true);
      };

      toast(`${state.match.players[pid].name} is thinking...`, Math.max(900, delay));
      cpuTimer = setTimeout(()=>{
        doCpuTurn(pid);
      }, delay);
    }

    function doCpuTurn(pid, skipped=false){
      const m = state.match;
      const pl = m.players[pid];
      if(!pl || pl.isHuman) return;

      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);
      const ctx = { kitchenOpen: kitchen };

      // MUST DRAW ONCE PER TURN (unless no tiles remain)
      if(RULES.mustDrawOncePerTurn && m.bag.length > 0 && !pl.didDraw){
        const t0 = m.bag.pop();
        if(t0){ pl.hand.push(t0); pl.didDraw = true; }
      }

      let action = "drew";
      let actionDish = null;
      let actionTiles = 0;
      let actionPts = 0;

      // Remix (hard diffs only)
      if(kitchen && cpuCanRemix()){
        const ch = cpuChar(pid);
        const wantRemix = Math.random() < Math.min(0.95, 0.35 * ch.remixBias);
        if(wantRemix){
          const cand = m.publicLine
            .filter(d=> d.points >= RULES.remixMinPoints && d.owner !== pid)
            .sort((a,b)=> b.points - a.points);
          const target = cand[0];
          if(target){
            const diff = effectiveDifficulty();
            const masterBoost = diff==="Master Chef" ? 0.85 : 0.55;
            if(Math.random() < masterBoost){
              const idx = m.publicLine.findIndex(x=>x.id===target.id);
              if(idx>=0){
                m.publicLine.splice(idx,1);
                const pub = {
                  id: nowId("pub"),
                  owner: pid,
                  ownerName: pl.name,
                  recipeKey: target.recipeKey,
                  name: target.name,
                  points: target.points,
                  tiles: target.tiles.map(t=>({id: nowId("rt"), name:t.name})),
                  isRemix: true,
                  from: target.owner
                };
                m.publicLine.push(pub);
                pl.score += pub.points;
                pl.servedThisHand += pub.points;

                action = "remixed";
                actionDish = pub.name;
                actionTiles = pub.tiles.length;
                actionPts = pub.points;
              }
            }
          }
        }
      }

      // Plate from hand if not remixed
      if(action !== "remixed"){
        const ch = cpuChar(pid);
        const prefApp = Math.random() < ch.appetizerBias;
        const tryOrder = prefApp
          ? ["chipsDip","pico","ench","breakfastTaco","hardTaco","softTaco","chorizoTaco"]
          : ["ench","pico","hardTaco","softTaco","breakfastTaco","chorizoTaco","chipsDip"];

        let plated = null;
        for(const rk of tryOrder){
          const best = findBestDishFromHand(pl.hand, rk, ctx);
          if(best){ plated = { rk, tileIds: best.tileIds }; break; }
        }

        if(plated){
          const tiles = plated.tileIds.map(id=> pl.hand.find(t0=>t0.id===id)).filter(Boolean);
          const v = validateDish(plated.rk, tiles, ctx);
          if(v.ok){
            const pts = computeDishPoints(plated.rk, tiles);
            const pub = {
              id: nowId("pub"),
              owner: pid,
              ownerName: pl.name,
              recipeKey: plated.rk,
              name: recipeByKey(plated.rk).name,
              points: pts,
              tiles: tiles.map(t0=>({id:t0.id, name:t0.name})),
              isRemix:false,
              from:null
            };
            m.publicLine.push(pub);

            for(const t0 of tiles){
              const idx = pl.hand.findIndex(h=>h.id===t0.id);
              if(idx>=0) pl.hand.splice(idx,1);
            }

            pl.score += pts;
            pl.servedThisHand += pts;

            // kitchen unlock tracking
            m.servedThisTurnPts += pts;
            if(!m.kitchenOpen && m.servedThisTurnPts >= 10){
              m.kitchenOpen = true;
              if(state.campaign.active) state.campaign.kitchenUnlockedEver = true;
              toast("üî• Kitchen Open!", 2200);
            }

            action = "plated";
            actionDish = pub.name;
            actionTiles = pub.tiles.length;
            actionPts = pub.points;
          }
        }else{
          action = "drew";
        }
      }

      // If they still haven't drawn (rare) and bag empty => ok. If must draw and bag has tiles => draw now
      if(RULES.mustDrawOncePerTurn && m.bag.length > 0 && !pl.didDraw){
        const t0 = m.bag.pop();
        if(t0){ pl.hand.push(t0); pl.didDraw = true; }
      }

      // Toasts (requested detail)
      toast("‚úÖ", 700);
      if(action==="plated"){
        toast(`${pl.name} ‚Ä¢ ${actionDish} ‚Ä¢ Tiles: ${actionTiles} ‚Ä¢ Points: ${actionPts}`, 2000);
      }else if(action==="remixed"){
        toast(`${pl.name} ‚Ä¢ Remix ‚Ä¢ Tiles: ${actionTiles} ‚Ä¢ Points: ${actionPts}`, 2000);
      }else{
        toast(`${pl.name} drew a tile.`, 1400);
      }

      endTurn(pid, true);
    }

    /* ===== Pages ===== */
    function setPage(p){
      state.ui.page = p;
      persist();
      render();
    }

    function setNavActive(btnId){
      ["navGame","navPrep","navScores","navSettings"].forEach(id=>{
        $(id).classList.toggle("active", id===btnId);
      });
    }

    $("navGame").onclick = ()=> setPage("gameplay");
    $("navPrep").onclick = ()=> setPage("prep");
    $("navScores").onclick = ()=> setPage("scores");
    $("navSettings").onclick = ()=> setPage("settings");

    /* ===== Controls ===== */
    $("btnNewMatchTop").onclick = ()=>{
      openModal(
        "New Match",
        "Start a fresh match? This will overwrite the current match state.",
        [
          { text:"Cancel", className:"ghost", onClick: closeModal },
          { text:"Start", className:"primary", onClick: ()=>{ closeModal(); newMatch(); } }
        ]
      );
    };

    $("btnDraw").onclick = ()=>{
      const m = state.match;
      if(!m){ newMatch(); return; }
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      const pl = p1();
      if(RULES.mustDrawOncePerTurn && pl.didDraw){
        toast("You already drew this turn.");
        return;
      }
      const t0 = m.bag.pop();
      if(!t0){ toast("No tiles left."); return; }
      pl.hand.push(t0);
      pl.didDraw = true;
      persist(); render();
      toast(`You drew: ${t0.name}`);
    };

    $("btnEndTurn").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      if(!requireDrawOrBlockEnd("P1")) return;
      endTurn("P1");
    };

    // Prep buttons
    $("btnNewDish").onclick = newDish;
    $("btnClearDish").onclick = clearCurrentDish;
    $("btnRemoveDish").onclick = removeCurrentDish;
    $("btnAutoPlate").onclick = autoPlate;
    $("btnAutoRemix").onclick = autoRemixPreview;
    $("btnOrderUp").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      const pl = p1();
      const ids = pl.drafts.map(d=>d.id);
      if(!ids.length){ toast("No drafts."); return; }
      const res = publishSelectedDrafts("P1", ids);
      if(!res.ok){ toast(res.msg); return; }
      persist(); render();
      toast("Order up!");
    };

    $("btnServeSel").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      const pl = p1();
      let sel = state.ui.serveSel || [];

      // if none selected, serve all valid drafts
      if(sel.length===0){
        const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };
        sel = pl.drafts.filter(d=>{
          const tiles = d.tileIds.map(id=>pl.hand.find(t0=>t0.id===id)).filter(Boolean);
          return validateDish(d.recipeKey, tiles, ctx).ok;
        }).map(d=>d.id);
      }

      if(sel.length===0){ toast("No valid drafts selected."); return; }
      const res = publishSelectedDrafts("P1", sel);
      if(!res.ok){ toast(res.msg); return; }
      state.ui.serveSel = [];
      persist(); render();
      toast("Served selected.");
    };

    $("selRecipe").onchange = ()=> updateCurrentDishRecipe($("selRecipe").value);

    // Hand tile interaction (delegated from grouped containers)
    document.addEventListener("click",(e)=>{
      const el = e.target.closest("[data-htile]");
      if(!el) return;
      toggleHandTileForDish(el.getAttribute("data-htile"));
    });

    /* ===== Settings wiring ===== */
    function fillSettings(){
      $("selDifficulty").innerHTML = DIFFS.map(d=> `<option value="${d}">${d}</option>`).join("");
      $("selDifficulty").value = state.settings.difficulty;

      $("selAccent").innerHTML = ACCENTS.map(a=> `<option value="${a.val}">${a.name} (${a.val})</option>`).join("");
      $("selAccent").value = state.settings.accent;

      $("selRecipe").innerHTML = RECIPES.map(r=> `<option value="${r.key}">${r.name}</option>`).join("");

      $("selMode").value = state.settings.mode;
      $("selPlayers").value = String(state.settings.players);
      $("inpHands").value = state.settings.handsTotal;
      $("inpTilesPerPlayer").value = state.settings.tilesPerPlayer;
      $("selDecks").value = String(state.settings.decks);
      $("selLang").value = state.settings.lang;
    }

    $("selMode").onchange = ()=>{
      state.settings.mode = $("selMode").value;
      persist(); render();
      toast("Mode updated.");
    };
    $("selPlayers").onchange = ()=>{
      state.settings.players = parseInt($("selPlayers").value,10);
      persist(); render();
      toast("Players updated.");
    };
    $("selDifficulty").onchange = ()=>{
      state.settings.difficulty = $("selDifficulty").value;
      persist(); render();
    };
    $("inpHands").onchange = ()=>{
      state.settings.handsTotal = Math.max(1, Math.min(12, parseInt($("inpHands").value,10) || 12));
      persist(); render();
    };
    $("inpTilesPerPlayer").onchange = ()=>{
      state.settings.tilesPerPlayer = Math.max(8, Math.min(24, parseInt($("inpTilesPerPlayer").value,10) || 16));
      persist(); render();
    };
    $("selDecks").onchange = ()=>{
      state.settings.decks = parseInt($("selDecks").value,10) || 2;
      persist(); render();
    };
    $("selAccent").onchange = ()=>{
      state.settings.accent = $("selAccent").value;
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));
      persist(); render();
    };
    $("selLang").onchange = ()=>{
      state.settings.lang = $("selLang").value;
      persist(); render();
    };

    /* ===== Tutorial ===== */
    function showTutorial(force=false){
      if(!force && localStorage.getItem(LS_TUT)==="1") return;

      const pages = [
        { e:"üåÆ", t:"Welcome to Taco Ria", b:"Draft recipes in Prep, then serve to score. First to empty your hand wins the hand." },
        { e:"üÉè", t:"Turn rule", b:"Each turn: draw exactly 1 tile, then you may serve from your drafts. No double-draws." },
        { e:"üç≥", t:"Prep is your kitchen", b:"Your hand is grouped by ingredient type. Tap tiles to build your current dish." },
        { e:"üî•", t:"Kitchen Open", b:"Serve 10+ points in one turn to open the kitchen. After that, remixing the public line is allowed." },
        { e:"ü™ü", t:"Public Line / Window", b:"Everything served is public. Watch the line for targets and timing." },
      ];

      let idx = 0;
      const renderTut = ()=>{
        const track = document.querySelector(".tutTrack");
        if(!track) return;
        track.style.transform = `translateX(${-idx*100}%)`;
        const dots = document.querySelectorAll(".dot");
        dots.forEach((d,i)=> d.classList.toggle("on", i===idx));
        $("modalTitle").textContent = "Tutorial";
      };

      const html = `
        <div class="tutWrap" id="tutWrap">
          <div class="tutTrack">
            ${pages.map(p=>`
              <div class="tutPage">
                <div class="tutEmoji">${p.e}</div>
                <div class="tutTitle">${escapeHtml(p.t)}</div>
                <div class="tutText">${escapeHtml(p.b)}</div>
              </div>
            `).join("")}
          </div>
        </div>
        <div class="dots">
          ${pages.map((_,i)=>`<div class="dot ${i===0?"on":""}"></div>`).join("")}
        </div>
      `;

      openModal("Tutorial", html, [
        { text:"Skip", className:"ghost", onClick: ()=>{ localStorage.setItem(LS_TUT,"1"); closeModal(); } },
        { text:"Back", className:"ghost", onClick: ()=>{ idx=Math.max(0,idx-1); renderTut(); } },
        { text:"Next", className:"primary", onClick: ()=>{
            if(idx < pages.length-1){ idx++; renderTut(); }
            else { localStorage.setItem(LS_TUT,"1"); closeModal(); toast("‚úÖ Tutorial complete."); }
          }
        }
      ]);

      // Swipe gesture
      const wrap = document.getElementById("tutWrap");
      let startX = null;
      wrap.addEventListener("pointerdown",(e)=>{ startX = e.clientX; wrap.setPointerCapture(e.pointerId); });
      wrap.addEventListener("pointerup",(e)=>{
        if(startX==null) return;
        const dx = e.clientX - startX;
        startX = null;
        if(Math.abs(dx) < 40) return;
        if(dx < 0 && idx < pages.length-1){ idx++; renderTut(); }
        if(dx > 0 && idx > 0){ idx--; renderTut(); }
      });

      setTimeout(renderTut, 0);
    }

    $("btnTutorial").onclick = ()=> showTutorial(true);

    /* ===== Render ===== */
    function render(){
      if(!state.match) newMatch();

      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      $("verPill").textContent = VERSION;
      $("btnDraw").textContent = t("drawTile");
      $("btnEndTurn").textContent = t("endTurn");
      $("turnHint").textContent = t("yourTurn");

      $("navGame").querySelector(".tx").textContent = t("gameplay");
      $("navPrep").querySelector(".tx").textContent = t("prep");
      $("navScores").querySelector(".tx").textContent = t("scores");
      $("navSettings").querySelector(".tx").textContent = t("settings");

      ["pageGameplay","pagePrep","pageScores","pageSettings"].forEach(id=> $(id).classList.remove("on"));
      if(state.ui.page==="gameplay"){ $("pageGameplay").classList.add("on"); setNavActive("navGame"); }
      if(state.ui.page==="prep"){ $("pagePrep").classList.add("on"); setNavActive("navPrep"); }
      if(state.ui.page==="scores"){ $("pageScores").classList.add("on"); setNavActive("navScores"); }
      if(state.ui.page==="settings"){ $("pageSettings").classList.add("on"); setNavActive("navSettings"); }

      fillSettings();
      renderMenuRef();
      renderGameplay();
      renderPrep();
      renderScores();

      const m = state.match;
      if(m.activePid !== "P1"){
        scheduleCpuTurn(m.activePid);
      }else{
        $("campaignSkipRow").style.display = "none";
      }
    }

    function renderMenuRef(){
      $("menuRef").innerHTML = MENU_REFERENCE.map(x=>`
        <div class="row sp" style="margin-bottom:10px;">
          <div style="font-weight:1000;">${escapeHtml(x.title)}</div>
          <span class="badge">${x.pts} pts</span>
        </div>
        <div class="muted small" style="margin-bottom:12px;">${escapeHtml(x.desc)}</div>
        <div style="height:1px; background: rgba(255,255,255,.06); margin: 0 0 12px;"></div>
      `).join("");
    }

    function phaseText(){
      const m = state.match;
      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);
      if(!kitchen){
        return { title:"Not Seated Yet", desc:"Serve 10+ points in one turn to open the kitchen." };
      }
      return { title:"Kitchen Open", desc:"Remix is enabled. The line is live." };
    }

    function renderGameplay(){
      const m = state.match;
      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);

      $("tilesRemainBadge").textContent = `${t("tilesRemaining")} ${m.bag.length}`;
      $("kitchenBadge").textContent = kitchen ? t("kitchenOpen") : t("kitchenClosed");
      $("lineSummary").textContent = `${m.publicLine.length} dish${m.publicLine.length===1?"":"es"}`;

      const ph = phaseText();
      $("phaseTitle").textContent = ph.title;
      $("phaseDesc").textContent = ph.desc;

      const myTurn = (m.activePid==="P1");
      $("btnDraw").disabled = !myTurn;
      $("btnEndTurn").disabled = !myTurn;

      renderPublicLine();
    }

    function renderPublicLine(){
      const m = state.match;
      const el = $("publicLine");
      if(!m.publicLine.length){
        el.innerHTML = `<div class="muted small">No dishes in the window yet.</div>`;
        return;
      }

      const groups = groupBy(m.publicLine, d=> d.name);

      el.innerHTML = Object.entries(groups).map(([menuItem, dishes])=>{
        const total = dishes.reduce((t0,d)=>t0+d.points,0);
        return `
          <div class="pubGroup" style="margin-bottom:12px;">
            <div class="pubGroupTitle">
              <div>${escapeHtml(menuItem)}</div>
              <span class="badge">Total <span class="mono">${total}</span></span>
            </div>
            ${dishes.map(d=>{
              const col = playerColor(d.owner);
              const tintA = hexToRgba(col,.28);
              const tiles = d.tiles.map(t0=>{
                const cat = tileCategory(t0.name).key;
                return `<span class="tile" data-cat="${escapeHtml(cat)}">${escapeHtml(t0.name)}</span>`;
              }).join("");
              return `
                <div class="pubDishRow" style="--tintA:${tintA};">
                  <div class="pubDishMeta">
                    <div>${escapeHtml(d.ownerName)}${d.isRemix ? " ‚Ä¢ Remix" : ""}</div>
                    <span class="badge">Pts <span class="mono">${d.points}</span></span>
                  </div>
                  <div class="tiles" style="margin-top:8px;">${tiles}</div>
                </div>
              `;
            }).join("")}
          </div>
        `;
      }).join("");
    }

    function renderPrep(){
      const m = state.match;
      const pl = p1();
      const d = currentDish();

      $("handCountHint").textContent = `${pl.hand.length} tiles`;

      $("btnAutoPlate").style.display = autoPlateAllowed() ? "inline-flex" : "none";
      $("btnAutoRemix").style.display = autoRemixAllowed() ? "inline-flex" : "none";

      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);
      $("btnAutoPlate").disabled = !(m.activePid==="P1");
      $("btnAutoRemix").disabled = !(m.activePid==="P1" && kitchen);

      $("autoHint").innerHTML = autoPlateAllowed()
        ? "Auto-Plate is enabled for Beginner/Easy."
        : "Tap tiles to add/remove from your current dish.";

      if(d){
        $("selRecipe").value = d.recipeKey;
        // show dynamic points preview
        const tiles = d.tileIds.map(id=> pl.hand.find(t0=>t0.id===id)).filter(Boolean);
        const ctx = { kitchenOpen: kitchen };
        const v = validateDish(d.recipeKey, tiles, ctx);
        const pts = v.ok ? computeDishPoints(d.recipeKey, tiles) : recipeByKey(d.recipeKey)?.pts || 0;
        $("dishMeta").textContent = `${recipeByKey(d.recipeKey)?.name || d.name} ‚Ä¢ ${pts} pts`;
      }else{
        $("dishMeta").textContent = "‚Äî";
      }

      renderHandGrouped();

      // Dish tiles
      if(!d){
        $("dishTiles").innerHTML = `<div class="muted small">No draft selected.</div>`;
        $("dishHint").textContent = "";
      }else{
        const tiles = d.tileIds.map(id=> pl.hand.find(t0=>t0.id===id)).filter(Boolean);
        $("dishTiles").innerHTML = tiles.map(t0=>{
          const cat = tileCategory(t0.name).key;
          return `<span class="tile" data-cat="${escapeHtml(cat)}">${escapeHtml(t0.name)}</span>`;
        }).join("") || `<div class="muted small">No tiles yet.</div>`;

        const ctx = { kitchenOpen: kitchen };
        const v = validateDish(d.recipeKey, tiles, ctx);
        $("dishHint").textContent = v.ok ? "‚úÖ Ready to serve." : `‚ö†Ô∏è ${v.reason}`;
      }

      renderPublicTilesGrouped();
    }

    function renderHandGrouped(){
      const pl = p1();
      const d = currentDish();

      const groups = groupBy(pl.hand, t0 => tileCategory(t0.name).label);
      const order = ["Tortillas","Proteins","Dry Toppings","Cheese","Salsas / Sauce","Dips","Chips / Sides","Sides","Wildcard","Toppings","Wet"];

      const sortedKeys = Object.keys(groups).sort((a,b)=>{
        const ia = order.indexOf(a); const ib = order.indexOf(b);
        return (ia===-1?999:ia) - (ib===-1?999:ib);
      });

      $("handGroups").innerHTML = sortedKeys.map(label=>{
        const tiles = groups[label];
        return `
          <div style="margin-top:12px;">
            <div class="row sp" style="margin-bottom:8px;">
              <div style="font-weight:1000;">${escapeHtml(label)}</div>
              <span class="badge">${tiles.length}</span>
            </div>
            <div class="tiles">
              ${tiles.map(t0=>{
                const cat = tileCategory(t0.name).key;
                const sel = d?.tileIds.includes(t0.id);
                return `<span class="tile ${sel?"sel":""}" data-cat="${escapeHtml(cat)}" data-htile="${escapeHtml(t0.id)}">${escapeHtml(t0.name)}</span>`;
              }).join("")}
            </div>
          </div>
        `;
      }).join("");
    }

    function renderPublicTilesGrouped(){
      const m = state.match;
      const el = $("publicTiles");
      if(!m.publicLine.length){
        el.innerHTML = `<div class="muted small">No public dishes yet.</div>`;
        return;
      }
      const groups = groupBy(m.publicLine, d=> d.name);
      el.innerHTML = `<div class="pubGroups">${
        Object.entries(groups).map(([menuItem, dishes])=>{
          return `
            <div class="pubGroup">
              <div class="pubGroupTitle">
                <div>${escapeHtml(menuItem)}</div>
                <span class="badge">${dishes.length} dish${dishes.length===1?"":"es"}</span>
              </div>
              ${dishes.map(d=>{
                const col = playerColor(d.owner);
                const tintA = hexToRgba(col,.28);
                const tiles = d.tiles.map(t0=>{
                  const cat = tileCategory(t0.name).key;
                  return `<span class="tile" data-cat="${escapeHtml(cat)}">${escapeHtml(t0.name)}</span>`;
                }).join("");
                return `
                  <div class="pubDishRow" style="--tintA:${tintA};">
                    <div class="pubDishMeta">
                      <div>${escapeHtml(d.ownerName)}${d.isRemix ? " ‚Ä¢ Remix" : ""}</div>
                      <span class="badge">${d.points} pts</span>
                    </div>
                    <div class="tiles" style="margin-top:8px;">${tiles}</div>
                  </div>
                `;
              }).join("")}
            </div>
          `;
        }).join("")
      }</div>`;
    }

    function renderScores(){
      const m = state.match;
      const pl = p1();

      $("scoreModePill").textContent = state.settings.mode==="campaign" ? "Campaign" : "Standard";

      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);
      const ctx = { kitchenOpen: kitchen };

      const pendingPts = pl.drafts.reduce((sum,d)=>{
        const tiles = d.tileIds.map(id=>pl.hand.find(t0=>t0.id===id)).filter(Boolean);
        const v = validateDish(d.recipeKey, tiles, ctx);
        return sum + (v.ok ? computeDishPoints(d.recipeKey, tiles) : 0);
      },0);

      $("scoreCurrent").textContent = `Current: ${pl.score}`;
      $("scorePending").textContent = `Pending: ${pendingPts}`;
      $("scoreServed").textContent = `Served this hand: ${pl.servedThisHand}`;

      const players = Object.values(m.players);
      $("scoreList").innerHTML = players.map(p=>{
        const isMe = p.id==="P1";
        const c = playerColor(p.id);
        const tintA = hexToRgba(c,.18);
        return `
          <div class="card" style="margin-top:12px; padding:14px; position:relative; overflow:hidden;">
            <div style="position:absolute; inset:0; background: linear-gradient(135deg, ${tintA}, transparent 70%); opacity:.9; pointer-events:none;"></div>
            <div style="position:relative; z-index:1;">
              <div class="row sp">
                <div style="font-weight:1000;">${escapeHtml(p.name)}${isMe ? " (You)" : ""}</div>
                <span class="badge">${p.score} match</span>
              </div>
              <div class="muted small" style="margin-top:6px;">
                Hand served: ${p.servedThisHand} ‚Ä¢ tiles left: ${p.hand.length}
              </div>
            </div>
          </div>
        `;
      }).join("");

      const show = (state.settings.mode==="campaign");
      $("campaignBoxAcc").style.display = show ? "block" : "none";
      if(show){
        const rows = (state.campaign.chapterScores || []).map((c,i)=>`
          <div class="row sp" style="margin-top:10px;">
            <div style="font-weight:1000;">Chapter ${i+1} ‚Ä¢ ${escapeHtml(c.diff)}</div>
            <span class="badge">${c.total}</span>
          </div>
        `).join("");

        const running = pl.score ?? 0;
        $("campaignBoxBody").innerHTML = `
          ${rows || `<div class="muted small">No completed chapters yet.</div>`}
          <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>
          <div class="row sp">
            <div style="font-weight:1000;">Running Total</div>
            <span class="badge">${running}</span>
          </div>
        `;
      }
    }

    function boot(){
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));
      render();
      showTutorial(false);
    }

    boot();
  </script>
</body>
</html>
