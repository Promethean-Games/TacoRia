<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Taco Ria</title>

  <style>
    :root{
      --bg:#050608;
      --bg2:#0a0c10;
      --panel:#0c0f14;
      --panel2:#0b0d11;
      --text:#f3f4f6;
      --muted:rgba(243,244,246,.70);
      --muted2:rgba(243,244,246,.52);

      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.14);

      --accent:#00e5ff;
      --accentSoft: rgba(0,229,255,.14);

      --danger:#ff3b30;

      --radius:20px;
      --pad:16px;
      --gap:12px;
      --shadow: 0 18px 45px rgba(0,0,0,.55);

      --navH:56px;
      color-scheme: dark;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(900px 380px at 18% 0%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(780px 360px at 85% 10%, rgba(255,255,255,.05), transparent 65%),
        radial-gradient(820px 420px at 50% 115%, rgba(0,0,0,.75), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow-x:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .shell{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      width:100%;
      margin:0 auto;
      max-width: 980px;
    }
    @media (max-width: 430px){ .shell{ max-width: 390px; } }

    header{
      padding: 14px 14px 10px;
      min-height:56px;
    }
    main{
      flex:1;
      padding: 0 14px calc(var(--navH) + env(safe-area-inset-bottom) + 18px);
    }

    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ min-width:0; }
    .wrap{ flex-wrap:wrap; }
    .sp{ justify-content:space-between; }

    .pageTitle{
      font-weight:1000;
      letter-spacing:.2px;
      line-height:1.08;
      font-size: clamp(20px, 4.7vw, 28px);
    }
    .small{ font-size:12px; }
    .muted{ color:var(--muted); }
    .muted2{ color:var(--muted2); }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.065), rgba(255,255,255,.035));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: var(--shadow);
    }

    .heroPhase{
      position:relative;
      overflow:hidden;
    }
    .heroPhase::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(600px 240px at 20% 0%, rgba(255,255,255,.08), transparent 65%),
        radial-gradient(520px 240px at 85% 10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(540px 260px at 50% 120%, rgba(0,0,0,.60), transparent 55%);
      pointer-events:none;
    }
    .heroPhase > *{ position:relative; z-index:1; }

    .pills{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    button{
      border:1px solid var(--stroke2);
      background: rgba(0,0,0,.35);
      color:var(--text);
      border-radius: 18px;
      padding: 12px 14px;
      font-weight:1000;
      letter-spacing:.2px;
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .btnTiny{ padding:8px 10px; border-radius:14px; font-size:12px; }
    .ghost{ background: rgba(0,0,0,.20); }
    .primary{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border-color: rgba(255,255,255,.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 20px rgba(0,0,0,.55);
    }
    .danger{
      background: linear-gradient(180deg, rgba(255,59,48,.22), rgba(255,59,48,.10));
      border-color: rgba(255,59,48,.35);
    }

    /* Jumbo gameplay buttons */
    .jumbo{
      min-height: 64px;
      font-size: 18px;
      border-radius: 20px;
      width:100%;
    }
    @media (max-width: 430px){
      .jumbo{ min-height: 68px; font-size: 19px; }
    }

    @keyframes pulseGlow{
      0%   { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
      50%  { transform: translateY(-1px); box-shadow: 0 0 0 1px rgba(255,255,255,.10), 0 0 32px rgba(0,229,255,.28); }
      100% { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
    }
    .pulse{ animation: pulseGlow 1.55s ease-in-out infinite; }
    .pulseOrder{ animation: pulseGlow 1.25s ease-in-out infinite; }

    /* Sticky action tray above bottom nav */
    .actionsTray{
      position: sticky;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom));
      z-index: 30;
    }
    .actionsStack{ display:flex; flex-direction:column; gap:10px; }

    /* Hand pills */
    .tiles{ display:flex; flex-wrap:wrap; gap:8px; }
    .tile{
      max-width:100%;
      overflow-wrap:anywhere;
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.14);
      font-weight: 900;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      --catTint: rgba(255,255,255,.06);
      background: linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.sel{
      outline: 2px solid rgba(0,229,255,.55);
      transform: translateY(-1px);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.wild{ border-color: rgba(255,255,255,.28); box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset; }

    .handGroups{ display:flex; flex-direction:column; gap:12px; }
    .handGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(0,0,0,.22);
      padding:10px;
    }
    .handGroupTitle{
      font-weight:1000;
      font-size:12px;
      letter-spacing:.18px;
      color: var(--muted);
      margin-bottom:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .handGroupTitle .count{ opacity:.75; font-weight:1000; }

    /* Category tinting */
    .tile.cat-tortilla{ --catTint: rgba(255,204,0,.18); border-color: rgba(255,204,0,.30); }
    .tile.cat-protein { --catTint: rgba(255,59,48,.16);  border-color: rgba(255,59,48,.28); }
    .tile.cat-cheese  { --catTint: rgba(255,245,200,.14); border-color: rgba(255,245,200,.24); }
    .tile.cat-wet     { --catTint: rgba(0,229,255,.14); border-color: rgba(0,229,255,.24); }
    .tile.cat-drytop  { --catTint: rgba(163,255,18,.12); border-color: rgba(163,255,18,.22); }
    .tile.cat-wild    { --catTint: rgba(255,255,255,.10); border-color: rgba(255,255,255,.26); }
    .tile.cat-other   { --catTint: rgba(179,107,255,.14); border-color: rgba(179,107,255,.24); }

    /* Public line */
    .pubGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      padding:12px;
      margin-bottom:12px;
    }
    .pubGroupTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
      margin-bottom: 8px;
    }
    .pubDishRow{
      border:1px solid var(--stroke);
      border-radius:16px;
      background: rgba(0,0,0,.45);
      padding:10px;
      margin-top:10px;
      position:relative;
      overflow:hidden;
    }
    .pubDishRow::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, var(--tintA), transparent 70%);
      opacity:.95;
      pointer-events:none;
    }
    .pubDishRow > *{ position:relative; z-index:1; }
    .pubDishMeta{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
    }

    /* Accordion */
    details.acc{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    details.acc + details.acc{ margin-top:10px; }
    details.acc summary{
      list-style:none;
      cursor:pointer;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:1000;
    }
    details.acc summary::-webkit-details-marker{ display:none; }
    .accBody{ padding: 0 14px 14px; }
    .field{ margin-top:10px; }
    .label{ font-size:12px; color:var(--muted); margin-bottom:6px; font-weight:900; }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; line-height: 1.35; }

    select, input[type="number"]{
      width:100%;
      padding:12px 40px 12px 14px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background:#0b0b0b;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      appearance:none;
      -webkit-appearance:none;
      outline:none;
    }
    select option{ background:#0b0b0b; color: rgba(255,255,255,.92); }
    .selectWrap{ position:relative; }
    .selectWrap::after{
      content:"‚ñæ";
      position:absolute;
      right:14px; top:50%;
      transform: translateY(-50%);
      opacity:.75;
      pointer-events:none;
      font-weight:1000;
    }

    nav.footer{
      position:fixed;
      left:0; right:0; bottom:0;
      height: var(--navH);
      padding-bottom: env(safe-area-inset-bottom);
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      z-index: 40;
    }
    .navBtn{
      flex:1;
      min-height:56px;
      border:none;
      border-right: 1px solid rgba(255,255,255,.06);
      background: transparent;
      color: rgba(255,255,255,.86);
      font-weight:1000;
      border-radius: 0;
      padding: 8px 6px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:2px;
    }
    .navBtn:last-child{ border-right:none; }
    .navBtn.active{
      color:#fff;
      background: radial-gradient(320px 120px at 50% 0%, rgba(0,229,255,.20), transparent 60%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .navBtn .ic{ font-size:16px; }
    .navBtn .tx{ font-size:12px; }

    #toastWrap{
      position:fixed;
      left:0; right:0;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom) + 12px);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 80;
    }
    .toast{
      max-width:min(560px, calc(100% - 24px));
      background: rgba(0,0,0,.78);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,.65);
      font-weight: 900;
      pointer-events:none;
    }

    /* Modal */
    #modalWrap{
      position:fixed; inset:0;
      background: var(--bg); /* no transparency for tile picker or tutorial */
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 90;
    }
    #modalWrap.on{ display:flex; }
    .modal{
      width: min(560px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: 0 22px 60px rgba(0,0,0,.70);
      padding: 14px;
    }
    .modal h3{ margin: 4px 0 8px; font-size: 18px; }
    .modal .body{ color: var(--muted); font-weight: 900; line-height: 1.35; }
    .modal .foot{ margin-top: 12px; display:flex; gap:10px; justify-content:flex-end; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .page{ display:none; }
    .page.on{ display:block; }

    /* Prep Table: 10 neutral placeholders (blank slate) */
    .prepRow{
      border:1px solid var(--stroke);
      border-radius: 18px;
      background: rgba(0,0,0,.26);
      padding: 12px;
      overflow:hidden;
    }
    .prepTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
      font-weight:1000;
    }
    .prepSlots{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:10px;
    }
    @media (max-width: 430px){
      .prepSlots{ grid-template-columns: repeat(2, 1fr); }
    }
    .slot{
      border-radius: 16px;
      border: 1px dashed rgba(255,255,255,.20);
      background: rgba(255,255,255,.03);
      padding: 10px;
      min-height: 58px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      user-select:none;
    }
    .slot.filled{
      border-style: solid;
      border-color: rgba(255,255,255,.18);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        rgba(0,0,0,.30);
    }
    .slot .sName{
      font-weight: 1000;
      font-size: 13px;
      color: rgba(243,244,246,.94);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:100%;
    }
    .slot .sHint{
      font-weight: 900;
      font-size: 12px;
      color: rgba(243,244,246,.42);
    }

    /* Draw Modal Grid + Tile Flip */
    .drawMeta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 10px;
    }
    .drawGrid{
      display:grid;
      gap:10px;
      margin-top: 10px;
    }
    .drawGrid.busy{ pointer-events:none; opacity:.98; }

    @keyframes slowShimmer{
      0%   { transform: translateX(-12%); opacity:.22; }
      50%  { transform: translateX(12%);  opacity:.32; }
      100% { transform: translateX(-12%); opacity:.22; }
    }
    @keyframes slowBreath{
      0%   { box-shadow: 0 10px 26px rgba(0,0,0,.55); transform: translateY(0); }
      50%  { box-shadow: 0 14px 32px rgba(0,0,0,.66); transform: translateY(-1px); }
      100% { box-shadow: 0 10px 26px rgba(0,0,0,.55); transform: translateY(0); }
    }

    .tileCard{
      perspective: 900px;
      min-height: 82px;
    }
    .tileFlip{
      position:relative;
      width:100%;
      height:100%;
      transform-style:preserve-3d;
      transition: transform 650ms cubic-bezier(.2,.9,.2,1);
      border-radius:18px;
    }
    .tileFace{
      position:absolute;
      inset:0;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      overflow:hidden;
      backface-visibility:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 10px 8px;
      user-select:none;
    }

    .tileBack{
      background:
        radial-gradient(340px 140px at 25% 0%, rgba(255,255,255,.08), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      animation: slowBreath 4.6s ease-in-out infinite;
      cursor:pointer;
    }
    .tileBack::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(520px 240px at 10% 0%, rgba(0,229,255,.16), transparent 60%),
        radial-gradient(520px 240px at 90% 10%, rgba(255,255,255,.06), transparent 65%);
      opacity:.55;
      pointer-events:none;
      animation: slowShimmer 7.8s ease-in-out infinite;
    }
    .tileBack::after{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, rgba(0,0,0,.25), rgba(0,0,0,.55));
      opacity:.55;
      pointer-events:none;
    }
    .tileBackInner{
      position:relative;
      z-index:1;
      width:100%;
      font-weight:1000;
      letter-spacing:.2px;
      color: rgba(243,244,246,.78);
      font-size: 13px;
      line-height:1.1;
      padding: 0 6px;
    }
    .tileBackNum{
      position:absolute;
      top:10px;
      left:10px;
      z-index:2;
      font-weight:1000;
      font-size:12px;
      color: rgba(243,244,246,.38);
      background: rgba(0,0,0,.24);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 4px 8px;
    }
    .tilePickOutline{
      outline: 2px solid rgba(0,229,255,.55);
      box-shadow: 0 0 0 1px rgba(255,255,255,.08), 0 0 30px rgba(0,229,255,.24);
    }

    .tileFront{
      transform: rotateY(180deg);
      background:
        radial-gradient(420px 160px at 15% 0%, rgba(255,255,255,.08), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,.55));
      border-color: rgba(255,255,255,.18);
    }
    .tileFront .frontName{
      font-weight:1000;
      font-size: 14px;
      color: rgba(243,244,246,.95);
    }
    .tileFlip.reveal{ transform: rotateY(180deg); }

    /* Tutorial pager */
    .tutWrap{
      position:relative;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      background: rgba(0,0,0,.22);
    }
    .tutStrip{
      display:flex;
      width:100%;
      overflow-x:auto;
      scroll-snap-type:x mandatory;
      -webkit-overflow-scrolling:touch;
    }
    .tutPage{
      flex: 0 0 100%;
      scroll-snap-align:start;
      padding: 14px;
      min-height: 220px;
    }
    .tutTitle{ font-weight:1000; font-size:16px; margin-bottom:6px; }
    .tutText{ color: var(--muted); font-weight:900; line-height:1.35; }
    .tutDots{
      display:flex; gap:8px; justify-content:center;
      margin-top:10px;
      opacity:.85;
    }
    .dot{
      width:8px; height:8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.05);
    }
    .dot.on{ background: rgba(0,229,255,.45); border-color: rgba(0,229,255,.55); }
  </style>
</head>

<body>
  <div class="shell">
    <header>
      <div class="row sp">
        <div>
          <div class="row" style="gap:10px;">
            <div class="pageTitle" id="appNameH">Taco Ria</div>
</div>
          <div class="muted small" id="subTitle">Private Prep ‚Ä¢ Public Line ‚Ä¢ Remix</div>
        </div>
        <button class="ghost btnTiny" id="btnNewMatchTop">New Match</button>
      </div>
    </header>

    <main>
      <!-- GAMEPLAY -->
      <section class="page on" id="pageGameplay">
        <div class="card heroPhase" style="margin-bottom:12px;">
          <div class="pills" style="margin-top:2px;">
            <span class="pill" id="tilesRemainBadge">Tiles Remaining 0</span>
            <span class="pill" id="kitchenBadge">Kitchen Closed</span>
            <span class="pill" id="handBadge">Hand 1/12</span>
            <span class="pill" id="turnBadge">Your Turn</span>
          </div>

          <div style="margin-top:12px;">
            <div style="font-weight:1000; font-size:16px;" id="phaseTitle">Not Seated Yet</div>
            <div class="muted" id="phaseDesc">Serve 10+ points in one turn to open the kitchen.</div>
          </div>
        </div>

        <!-- SIMPLE ACTIONS -->
        <div class="actionsTray">
          <div class="card">
            <div class="actionsStack">
              <button class="primary jumbo" id="btnPrep">Prep a Dish</button>
              <button class="primary jumbo" id="btnOrderUp">Order Up!</button>
              <button class="danger jumbo" id="btnEndTurn">End Turn</button>
            </div>
            <div class="muted small" style="margin-top:10px;" id="actionHint">
              Prep your ingredients, then Order Up. One draw per turn.
            </div>
          </div>
        </div>

        <!-- PUBLIC LINE -->
        <div class="card" style="margin-top:12px;">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Public Line / Window</div>
            <span class="pill" id="lineSummary">0 dishes</span>
          </div>
          <div id="publicLine"></div>
        </div>
      </section>

      <!-- PREP -->
      <section class="page" id="pagePrep">
        <div class="card">
          <div class="row sp" style="margin-bottom:8px;">
            <div style="font-weight:1000;">Prep Table</div>
            <span class="badge" id="prepTurnBadge">Your Turn</span>
          </div>

          <div class="prepRow" style="margin-bottom:12px;">
            <div class="prepTop">
              <div>Prep Window</div>
              <div class="muted2 small" id="prepLoadedHint">0/10 loaded</div>
            </div>
            <div class="prepSlots" id="prepSlots"></div>
            <div class="muted small" style="margin-top:10px;" id="prepStatus">No dish detected yet.</div>
          </div>

          <div class="row wrap" style="gap:10px; justify-content:space-between; margin-bottom:12px;">
            <button class="primary jumbo" id="btnDraw">Draw Tile</button>
            <button class="primary jumbo" id="btnOrderUpFromPrep">Order Up!</button>
          </div>

          <div class="row wrap" style="gap:10px; justify-content:space-between; margin-bottom:12px;">
            <button class="ghost btnTiny" id="btnAutoPlate">Auto-Plate</button>
            <button class="ghost btnTiny" id="btnAutoRemix">Auto-Remix</button>
            <button class="ghost btnTiny" id="btnClearPrep">Clear Prep</button>
          </div>

          <details class="acc" open>
            <summary>
              <span>Your Hand</span>
              <span class="muted2 small" id="handCountHint">0 tiles</span>
            </summary>
            <div class="accBody">
              <div id="handTiles"></div>
              <div class="hint" id="handHint" style="margin-top:10px;">
                Tap hand tiles to add/remove them from your Prep Window.
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Menu Guide</span>
              <span class="muted2 small">Reference</span>
            </summary>
            <div class="accBody" id="menuGuideBody"></div>
          </details>
        </div>
      </section>

      <!-- SCORES -->
      <section class="page" id="pageScores">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Scores</div>
            <span class="badge" id="scoreModePill">Standard</span>
          </div>

          <div class="row wrap" style="gap:10px; margin-bottom:12px;">
            <span class="pill" id="scoreCurrent">Current: 0</span>
            <span class="pill muted" id="scoreServedMuted">Served this hand: 0</span>
          </div>

          <div id="scoreList"></div>

          <div class="hint" style="margin-top:10px;">
            Player panels are collapsed by default. Expand to see dishes served and remix net.
          </div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="page" id="pageSettings">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Settings</div>
</div>
          <div class="muted small">Primary theme stays black. Choose a high-contrast accent.</div>

          <details class="acc" open style="margin-top:12px;">
            <summary>
              <span>Match</span>
              <span class="muted2 small">Mode + Players</span>
            </summary>
            <div class="accBody">
              <div class="row wrap" style="gap:12px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Mode</div>
                  <div class="selectWrap">
                    <select id="selMode">
                      <option value="standard">Standard Match</option>
                      <option value="campaign">Campaign</option>
                    </select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Players</div>
                  <div class="selectWrap">
                    <select id="selPlayers">
                      <option value="2">2 Players</option>
                      <option value="3">3 Players</option>
                      <option value="4" selected>4 Players</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">CPU Difficulty (Standard only)</div>
                  <div class="selectWrap">
                    <select id="selDifficulty"></select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Hands (Standard only)</div>
                  <input type="number" id="inpHands" min="1" max="12" value="12" />
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Tiles per Player</div>
                  <input type="number" id="inpTilesPerPlayer" min="8" max="24" value="16" />
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Decks</div>
                  <div class="selectWrap">
                    <select id="selDecks">
                      <option value="1">1 Deck</option>
                      <option value="2" selected>2 Decks (Recommended)</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Theme</span>
              <span class="muted2 small">Accent Color</span>
            </summary>
            <div class="accBody">
              <div class="label">Accent</div>
              <div class="selectWrap">
                <select id="selAccent"></select>
              </div>
              <div class="hint">CPU colors will auto-adjust to avoid matching you or each other.</div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Language</span>
              <span class="muted2 small">EN / ES / FR / DE</span>
            </summary>
            <div class="accBody">
              <div class="label">App Language</div>
              <div class="selectWrap">
                <select id="selLang">
                  <option value="en">English</option>
                  <option value="es">Espa√±ol</option>
                  <option value="fr">Fran√ßais</option>
                  <option value="de">Deutsch</option>
                </select>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Tutorial</span>
              <span class="muted2 small">View / Hide</span>
            </summary>
            <div class="accBody">
              <button class="primary" id="btnViewTutorial">View Tutorial</button>
              <div class="hint">Tutorial appears after your first draw unless you hide it.</div>
            </div>
          </details>
        </div>
      </section>
    </main>
  </div>

  <nav class="footer">
    <button class="navBtn active" id="navGame"><div class="ic">üé≠</div><div class="tx">Gameplay</div></button>
    <button class="navBtn" id="navPrep"><div class="ic">üç≥</div><div class="tx">Prep</div></button>
    <button class="navBtn" id="navScores"><div class="ic">üèÜ</div><div class="tx">Scores</div></button>
    <button class="navBtn" id="navSettings"><div class="ic">‚öôÔ∏è</div><div class="tx">Settings</div></button>
  </nav>

  <div id="toastWrap"></div>

  <div id="modalWrap">
    <div class="modal">
      <h3 id="modalTitle">Modal</h3>
      <div class="body" id="modalBody"></div>
      <div class="foot" id="modalFoot"></div>
    </div>
  </div>

  <script>
/* =====================================================
  Taco Ria (GitHub-ready) v0.9.1.2.26
  Mobile compatibility build (no optional chaining / ?? / ||= / replaceAll)
  Fixes ‚Äúbuttons dead on mobile‚Äù caused by unsupported JS syntax on some mobile browsers.
  Also removes visible version numbers per request.
====================================================== */

(function(){
  "use strict";

  var VERSION = "v0.9.1.2.26";
  var LS_KEY  = "taco_ria_state_v091226_mobilefix";

  function $(id){ return document.getElementById(id); }

  // --- minimal polyfills ---
  if (!Element.prototype.closest){
    Element.prototype.closest = function(s){
      var el = this;
      while(el && el.nodeType === 1){
        if (el.matches && el.matches(s)) return el;
        el = el.parentElement || el.parentNode;
      }
      return null;
    };
  }
  if (!Element.prototype.matches){
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }

  // --- helpers ---
  function escapeHtml(s){
    s = (s === null || s === undefined) ? "" : String(s);
    return s.replace(/&/g,"&amp;")
            .replace(/</g,"&lt;")
            .replace(/>/g,"&gt;")
            .replace(/"/g,"&quot;")
            .replace(/'/g,"&#039;");
  }
  function randInt(n){ return Math.floor(Math.random() * n); }
  function shuffle(a){
    for (var i=a.length-1;i>0;i--){
      var j = Math.floor(Math.random()*(i+1));
      var t = a[i]; a[i]=a[j]; a[j]=t;
    }
    return a;
  }
  function nowId(prefix){
    prefix = prefix || "id";
    return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }
  function hexToRgba(hex, a){
    hex = (hex || "#ffffff").replace("#","").trim();
    var full = hex.length === 3 ? (hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]) : (hex + "000000").slice(0,6);
    var n = parseInt(full, 16);
    var r=(n>>16)&255, g=(n>>8)&255, b=n&255;
    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
  }
  function groupBy(arr, keyFn){
    var m = {};
    arr = arr || [];
    for (var i=0;i<arr.length;i++){
      var it = arr[i];
      var k = keyFn(it);
      if(!m[k]) m[k] = [];
      m[k].push(it);
    }
    return m;
  }
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  // --- toast ---
  function toast(msg, ms){
    ms = ms || 2200;
    var wrap = $("toastWrap");
    if(!wrap) return;
    wrap.innerHTML = '<div class="toast">' + escapeHtml(msg) + '</div>';
    if(toast._t) clearTimeout(toast._t);
    toast._t = setTimeout(function(){ wrap.innerHTML=""; }, ms);
  }

  // --- modal ---
  var modalMode = null;

  function openModal(title, htmlBody, footButtons){
    $("modalTitle").textContent = title;
    $("modalBody").innerHTML = htmlBody;
    var foot = $("modalFoot");
    foot.innerHTML = "";
    footButtons = footButtons || [];
    for (var i=0;i<footButtons.length;i++){
      (function(b){
        var btn = document.createElement("button");
        btn.className = b.className || "ghost";
        btn.textContent = b.text || "OK";
        btn.onclick = function(){
          if (typeof b.onClick === "function") b.onClick();
        };
        foot.appendChild(btn);
      })(footButtons[i]);
    }
    $("modalWrap").classList.add("on");
  }
  function closeModal(){
    $("modalWrap").classList.remove("on");
    $("modalBody").onclick = null;
    modalMode = null;
  }

  // --- i18n (tiny, no fluff) ---
  var I18N = {
    en:{ gameplay:"Gameplay", prep:"Prep", scores:"Scores", settings:"Settings", orderUp:"Order Up!", drawTile:"Draw Tile", endTurn:"End Turn", prepDish:"Prep a Dish", cancel:"Cancel", close:"Close", start:"Start", hide:"Hide" },
    es:{ gameplay:"Juego",    prep:"Preparaci√≥n", scores:"Puntos", settings:"Ajustes", orderUp:"¬°Orden lista!", drawTile:"Robar ficha", endTurn:"Terminar turno", prepDish:"Preparar plato", cancel:"Cancelar", close:"Cerrar", start:"Iniciar", hide:"Ocultar" },
    fr:{ gameplay:"Jeu",      prep:"Pr√©pa", scores:"Scores", settings:"R√©glages", orderUp:"√Ä l‚Äôenvoi !", drawTile:"Piocher", endTurn:"Fin du tour", prepDish:"Pr√©parer", cancel:"Annuler", close:"Fermer", start:"D√©marrer", hide:"Masquer" },
    de:{ gameplay:"Spiel",    prep:"Vorbereiten", scores:"Punkte", settings:"Einstellungen", orderUp:"Bestellung raus!", drawTile:"Ziehen", endTurn:"Zug beenden", prepDish:"Vorbereiten", cancel:"Abbrechen", close:"Schlie√üen", start:"Start", hide:"Ausblenden" }
  };
  function t(key){
    var lang = (state && state.settings && state.settings.lang) ? state.settings.lang : "en";
    var pack = I18N[lang] || I18N.en;
    return pack[key] || I18N.en[key] || key;
  }
  function getAppName(){
    var el = $("appNameH");
    return (el && el.textContent ? el.textContent : (document.title || "Taco Ria")).trim();
  }

  // --- difficulty ---
  var DIFFS = ["Beginner","Easy","Medium","Difficult","Master Chef"];
  var DIFF_DELAY_MS = { "Beginner":5000, "Easy":3500, "Medium":2200, "Difficult":1200, "Master Chef":700 };
  function isLoose(diff){ return diff==="Beginner" || diff==="Easy" || diff==="Medium"; }
  function isStrict(diff){ return diff==="Difficult" || diff==="Master Chef"; }

  // --- accents ---
  var ACCENTS = [
    {name:"Neon Cyan", val:"#00e5ff"},
    {name:"Signal Yellow", val:"#ffcc00"},
    {name:"Lime", val:"#a3ff12"},
    {name:"Hot Pink", val:"#ff2bd6"},
    {name:"Orange", val:"#ff8a00"},
    {name:"Ice", val:"#b3f6ff"},
    {name:"Violet", val:"#b36bff"},
    {name:"Red", val:"#ff3b30"}
  ];
  var CPU_BASE_COLORS = ["#ff3b30","#b36bff","#ffcc00","#a3ff12"];
  function ensureUniqueCpuColors(){
    var used = {};
    used[String((state.settings && state.settings.accent) || "#00e5ff").toLowerCase()] = true;
    var pool = [];
    for(var i=0;i<ACCENTS.length;i++) pool.push(ACCENTS[i].val.toLowerCase());
    var out = [];
    for(var j=0;j<CPU_BASE_COLORS.length;j++){
      var col = CPU_BASE_COLORS[j].toLowerCase();
      if(used[col]){
        for(var k=0;k<pool.length;k++){
          if(!used[pool[k]]){ col = pool[k]; break; }
        }
      }
      used[col] = true;
      out.push(col);
    }
    return out;
  }

  // --- deck ---
  var DECK_ING_COUNTS = [
    ["Fish",1],["Ground Beef",2],["Shredded Chicken",2],["Carne Guisada",1],["Al Pastor",1],["Carnitas",1],
    ["Egg",2],["Chicken Fajita",2],["Beef Fajita",2],["Chorizo",1],
    ["Tortilla Chips",3],["Flour Tortillas",2],["Corn Tortillas",2],
    ["Shredded yellow Cheese",2],["Shredded white cheese",2],
    ["Rice",2],["Charro Beans",1],["Refried Beans",1],["Black Beans",1],
    ["Cilantro",2],["Jalapenos",2],["Lettuce",2],["Lime Juice",2],["Onion",2],["Tomato",2],
    ["Sour Cream",2],["Avocado",2],
    ["Salsa Roja",2],["Salsa Verde",2],["Queso",2],["Guacamole",2],
    ["Grocery Run",2]
  ];
  function buildDeck(decks){
    decks = decks || 2;
    var tiles = [];
    for (var d=0; d<decks; d++){
      for (var i=0;i<DECK_ING_COUNTS.length;i++){
        var name = DECK_ING_COUNTS[i][0];
        var count = DECK_ING_COUNTS[i][1];
        for (var c=0;c<count;c++){
          tiles.push({ id: nowId("t"), name: name });
        }
      }
    }
    return shuffle(tiles);
  }

  // --- ingredient classification ---
  function isWild(n){ return n==="Grocery Run"; }
  function isTortilla(n){ return n==="Corn Tortillas" || n==="Flour Tortillas"; }
  function isEgg(n){ return n==="Egg"; }
  function isProtein(n){
    return n==="Fish" || n==="Ground Beef" || n==="Shredded Chicken" || n==="Carne Guisada" ||
           n==="Al Pastor" || n==="Carnitas" || n==="Chicken Fajita" || n==="Beef Fajita" ||
           n==="Chorizo" || n==="Egg";
  }
  function isCheese(n){ return n==="Shredded yellow Cheese" || n==="Shredded white cheese"; }
  function isSauce(n){ return n==="Salsa Roja" || n==="Salsa Verde"; }
  function isWet(n){ return n==="Salsa Roja" || n==="Salsa Verde" || n==="Queso" || n==="Guacamole"; }
  function isDip(n){ return n==="Salsa Roja" || n==="Salsa Verde" || n==="Guacamole" || n==="Queso"; }
  function isDryTopping(n){
    return n==="Lettuce" || n==="Onion" || n==="Tomato" || n==="Cilantro" || n==="Jalapenos" || n==="Avocado" ||
           isCheese(n) || n==="Sour Cream";
  }
  function ingredientCategory(name){
    if(isWild(name)) return "wild";
    if(isTortilla(name)) return "tortilla";
    if(isProtein(name)) return "protein";
    if(isCheese(name)) return "cheese";
    if(isWet(name)) return "wet";
    if(isDryTopping(name)) return "drytop";
    return "other";
  }
  function categoryLabel(cat){
    var map = {
      tortilla:"Tortillas", protein:"Proteins", cheese:"Cheese", wet:"Wet Toppings",
      drytop:"Dry Toppings", wild:"Grocery Run", other:"Other"
    };
    return map[cat] || cat;
  }

  // --- scoring/recipes ---
  var GRILL_PROTEINS = { "Fish":true, "Chicken Fajita":true, "Beef Fajita":true };

  var RECIPES = [
    { key:"breakfastTaco", name:"Breakfast Taco", base:3, kind:"breakfast" },
    { key:"hardTaco", name:"Hard Shell Taco", base:5, kind:"taco", tortilla:"Corn Tortillas" },
    { key:"softTaco", name:"Soft Taco", base:5, kind:"taco", tortilla:"Flour Tortillas" },
    { key:"chorizoTaco", name:"Chorizo Taco", base:8, kind:"chorizo" },
    { key:"chipsDip", name:"Chips & Dip", base:5, kind:"chipsDip" },
    { key:"pico", name:"Pico de Gallo", base:8, kind:"pico" },
    { key:"ench", name:"Enchiladas", base:10, kind:"ench" }
  ];
  function recipeByKey(k){
    for(var i=0;i<RECIPES.length;i++){ if(RECIPES[i].key===k) return RECIPES[i]; }
    return null;
  }

  var RULES = {
    openKitchenTurnPts: 10,
    wetLockedUntilKitchen: true,
    tacoDryLoose: 1,
    tacoDryStrict: 3,
    starterPassDishKey: "chipsDip"
  };

  // --- state ---
  function defaultState(){
    return {
      settings:{
        accent:"#00e5ff",
        lang:"en",
        mode:"standard",
        players:4,
        difficulty:"Easy",
        handsTotal:12,
        tilesPerPlayer:16,
        decks:2,
        tutorialHidden:false
      },
      flags:{ sawFirstDraw:false },
      match:null,
      ui:{ page:"gameplay" }
    };
  }
  function persist(){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){}
  }
  function load(){
    try{
      var raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch(e){ return null; }
  }
  var state = load() || defaultState();

  // --- players/match ---
  function mkPlayer(id, name, isHuman, color){
    return {
      id:id, name:name, isHuman:isHuman,
      color:color,
      score:0,
      servedThisHand:0,
      hand:[],
      didDrawThisTurn:false,
      prepSelectedIds:[],
      logThisHand:[],
      remixGainThisHand:0,
      remixLossThisHand:0,
      starterPassUsed:false
    };
  }
  function dealInitial(m){
    var tilesPer = state.settings.tilesPerPlayer || 16;
    for(var pid in m.players){
      if(!m.players.hasOwnProperty(pid)) continue;
      var p = m.players[pid];
      p.hand = [];
      p.prepSelectedIds = [];
      p.logThisHand = [];
      p.servedThisHand = 0;
      p.remixGainThisHand = 0;
      p.remixLossThisHand = 0;
      p.didDrawThisTurn = false;
      for(var i=0;i<tilesPer;i++){
        var t0 = m.bag.pop();
        if(!t0) break;
        p.hand.push(t0);
      }
    }
  }
  function beginTurn(pid){
    var m = state.match;
    var p = m.players[pid];
    p.didDrawThisTurn = false;
    m.servedThisTurnPts = 0;
  }
  function p1(){ return state.match.players["P1"]; }

  function newMatch(){
    var cpuCols = ensureUniqueCpuColors();
    var pCount = parseInt(state.settings.players,10) || 4;

    var m = {
      id: nowId("m"),
      handIndex: 1,
      kitchenOpen: false,
      bag: buildDeck(parseInt(state.settings.decks,10) || 2),
      publicLine: [],
      players: {},
      activePid: "P1",
      servedThisTurnPts: 0
    };

    m.players["P1"] = mkPlayer("P1","You", true, state.settings.accent);
    if(pCount >= 2) m.players["P2"] = mkPlayer("P2","Chef Mike", false, cpuCols[0]);
    if(pCount >= 3) m.players["P3"] = mkPlayer("P3","Salsa Sam", false, cpuCols[1]);
    if(pCount >= 4) m.players["P4"] = mkPlayer("P4","Queso Queen", false, cpuCols[2]);

    dealInitial(m);
    state.match = m;
    state.ui.page = "gameplay";
    beginTurn("P1");
    persist();
    render();
    toast("New match started.");
  }

  // --- selection ---
  function selectedTilesFor(pid){
    var m = state.match;
    var p = m && m.players ? m.players[pid] : null;
    var ids = (p && p.prepSelectedIds) ? p.prepSelectedIds : [];
    var hand = (p && p.hand) ? p.hand : [];
    var out = [];
    for(var i=0;i<ids.length;i++){
      var id = ids[i];
      for(var j=0;j<hand.length;j++){
        if(hand[j].id === id){ out.push(hand[j]); break; }
      }
    }
    return out;
  }

  // --- draw ---
  function drawTile(pid){
    var m = state.match;
    var pl = m.players[pid];
    if(m.activePid !== pid) return {ok:false, msg:"Not your turn."};
    if(pl.didDrawThisTurn) return {ok:false, msg:"Only one draw per turn."};
    if(m.bag.length === 0) return {ok:false, msg:"No tiles left."};

    var idx = randInt(m.bag.length);
    var t0 = m.bag.splice(idx,1)[0];
    pl.hand.push(t0);
    pl.didDrawThisTurn = true;

    if(pid==="P1" && !state.flags.sawFirstDraw) state.flags.sawFirstDraw = true;

    return {ok:true, tile:t0};
  }

  // --- validation/detection ---
  function diffCtx(){
    var diff = state.settings.difficulty || "Easy";
    return {
      kitchenOpen: !!(state.match && state.match.kitchenOpen),
      difficulty: diff,
      strict: isStrict(diff),
      loose: isLoose(diff)
    };
  }
  function countOcc(names){
    var m = {};
    for(var i=0;i<names.length;i++){
      var n = names[i];
      m[n] = (m[n] || 0) + 1;
    }
    return m;
  }

  function validateRecipeForSelection(recipeKey, tileObjs, ctx){
    var r = recipeByKey(recipeKey);
    if(!r) return {ok:false, reason:"Unknown recipe."};

    tileObjs = tileObjs || [];
    var names = [];
    for(var i=0;i<tileObjs.length;i++) names.push(tileObjs[i].name);

    var occ = countOcc(names);
    var wildCount = 0;
    var nonWild = [];
    for(i=0;i<names.length;i++){
      if(isWild(names[i])) wildCount++;
      else nonWild.push(names[i]);
    }

    var hasWet = false;
    for(i=0;i<nonWild.length;i++){ if(isWet(nonWild[i])){ hasWet=true; break; } }
    if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen && hasWet){
      return {ok:false, reason:"Wet locked until Kitchen Open."};
    }

    var reqDry = ctx.strict ? RULES.tacoDryStrict : RULES.tacoDryLoose;

    // Breakfast Taco: tortilla + egg required only
    if(r.kind === "breakfast"){
      var hasTort = false, hasEgg = false;
      for(i=0;i<nonWild.length;i++){
        if(isTortilla(nonWild[i])) hasTort = true;
        if(isEgg(nonWild[i])) hasEgg = true;
      }
      if(!hasTort && wildCount>0) hasTort = true;
      if(!hasEgg && wildCount>0) hasEgg = true;
      if(!hasTort || !hasEgg) return {ok:false, reason:"Needs tortilla + egg."};

      // restrictions
      for(i=0;i<nonWild.length;i++){
        if(nonWild[i]==="Sour Cream" || nonWild[i]==="Charro Beans" || nonWild[i]==="Black Beans"){
          return {ok:false, reason:"Breakfast taco: no sour cream/charro/black beans."};
        }
      }
      // wet max 1
      var wetCount = 0;
      for(i=0;i<nonWild.length;i++) if(isWet(nonWild[i])) wetCount++;
      if(wetCount > 1) return {ok:false, reason:"Only 1 wet topping."};

      if(tileObjs.length > 8) return {ok:false, reason:"Too many tiles."};

      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:r.base, grillBonus:0, extras:0, laurensLunch:false};
    }

    // Chips & Dip: exactly 2 tiles
    if(r.kind === "chipsDip"){
      if(tileObjs.length !== 2) return {ok:false, reason:"Needs 2 tiles."};
      var hasChips = false, hasDip = false;
      for(i=0;i<nonWild.length;i++){
        if(nonWild[i]==="Tortilla Chips") hasChips = true;
        if(isDip(nonWild[i])) hasDip = true;
      }
      if(!hasChips && wildCount>0) hasChips = true;
      if(!hasDip && wildCount>0) hasDip = true;
      if(!hasChips) return {ok:false, reason:"Needs chips."};
      if(!hasDip) return {ok:false, reason:"Needs a dip."};
      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:r.base, grillBonus:0, extras:0, laurensLunch:false};
    }

    // Pico: exactly 4 tiles, no extras
    if(r.kind === "pico"){
      if(tileObjs.length !== 4) return {ok:false, reason:"Needs 4 tiles."};
      var need = { "Tomato":false, "Onion":false, "Cilantro":false, "Lime Juice":false };
      for(i=0;i<nonWild.length;i++){
        if(need.hasOwnProperty(nonWild[i])) need[nonWild[i]] = true;
      }
      // wild can cover missing
      if(wildCount>0){
        for(var k in need) if(need.hasOwnProperty(k) && !need[k]){ need[k] = true; wildCount--; }
      }
      if(!need["Tomato"] || !need["Onion"] || !need["Cilantro"] || !need["Lime Juice"]){
        return {ok:false, reason:"Needs Tomato, Onion, Cilantro, Lime."};
      }
      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:r.base, grillBonus:0, extras:0, laurensLunch:false};
    }

    // Enchiladas: tort + protein + sauce + cheese, extras capped
    if(r.kind === "ench"){
      if(tileObjs.length < 4) return {ok:false, reason:"Needs more tiles."};
      var hasT = false, hasP = false, hasS = false, hasC = false;
      for(i=0;i<nonWild.length;i++){
        var n = nonWild[i];
        if(isTortilla(n)) hasT = true;
        else if(isProtein(n)) hasP = true;
        else if(isSauce(n)) hasS = true;
        else if(isCheese(n)) hasC = true;
      }
      if(!hasT && wildCount>0) hasT = true;
      if(!hasP && wildCount>0) hasP = true;
      if(!hasS && wildCount>0) hasS = true;
      if(!hasC && wildCount>0) hasC = true;

      if(!hasT) return {ok:false, reason:"Needs tortillas."};
      if(!hasP) return {ok:false, reason:"Needs protein."};
      if(!hasS) return {ok:false, reason:"Needs sauce."};
      if(!hasC) return {ok:false, reason:"Needs cheese."};
      if(tileObjs.length > 7) return {ok:false, reason:"Too many toppings."};

      var base = r.base;
      var grillBonus = 0;
      var prot = null;
      for(i=0;i<nonWild.length;i++){
        if(isProtein(nonWild[i]) && !isEgg(nonWild[i])){ prot = nonWild[i]; break; }
      }
      if(prot && GRILL_PROTEINS[prot]) grillBonus = 1;

      var extras = Math.max(0, tileObjs.length - 4);
      var points = base + grillBonus + extras;
      return {ok:true, recipeKey:r.key, name:r.name, base:base, points:points, grillBonus:grillBonus, extras:extras, laurensLunch:false};
    }

    // Chorizo Taco: tortilla + chorizo + onion + cilantro
    if(r.kind === "chorizo"){
      if(tileObjs.length < 4) return {ok:false, reason:"Needs more tiles."};
      if(ctx.strict && tileObjs.length !== 4) return {ok:false, reason:"Needs 4 tiles."};

      var hasTort2=false, hasChor=false, hasOn=false, hasCil=false;
      for(i=0;i<nonWild.length;i++){
        var n2 = nonWild[i];
        if(isTortilla(n2)) hasTort2=true;
        else if(n2==="Chorizo") hasChor=true;
        else if(n2==="Onion") hasOn=true;
        else if(n2==="Cilantro") hasCil=true;
      }
      if(!hasTort2 && wildCount>0) hasTort2=true;
      if(!hasChor && wildCount>0) hasChor=true;
      if(!hasOn && wildCount>0) hasOn=true;
      if(!hasCil && wildCount>0) hasCil=true;

      if(!hasTort2) return {ok:false, reason:"Needs tortilla."};
      if(!hasChor) return {ok:false, reason:"Needs chorizo."};
      if(!hasOn) return {ok:false, reason:"Needs onion."};
      if(!hasCil) return {ok:false, reason:"Needs cilantro."};

      var base2 = r.base;
      var extras2 = ctx.loose ? Math.max(0, tileObjs.length - 4) : 0;
      return {ok:true, recipeKey:r.key, name:r.name, base:base2, points:base2+extras2, grillBonus:0, extras:extras2, laurensLunch:false};
    }

    // Taco (hard/soft)
    if(r.kind === "taco"){
      if(tileObjs.length < (ctx.strict ? 5 : 3)) return {ok:false, reason:"Needs more tiles."};
      if(tileObjs.length > 8) return {ok:false, reason:"Too many tiles."};

      // required tortilla type
      var hasReqT = false;
      for(i=0;i<nonWild.length;i++){ if(nonWild[i]===r.tortilla) { hasReqT=true; break; } }
      // wild can cover missing tortilla type only if you didn't already play the wrong tortilla
      if(!hasReqT && wildCount>0){
        var hasAnyT = false;
        for(i=0;i<nonWild.length;i++){ if(isTortilla(nonWild[i])){ hasAnyT=true; break; } }
        if(!hasAnyT) hasReqT = true;
      }
      if(!hasReqT) return {ok:false, reason:"Use " + r.tortilla + "."};

      // protein
      var hasProt2 = false;
      for(i=0;i<nonWild.length;i++){ if(isProtein(nonWild[i])){ hasProt2=true; break; } }
      if(!hasProt2 && wildCount===0) return {ok:false, reason:"Needs protein."};

      // dry topping count
      var dryCount = 0;
      for(i=0;i<nonWild.length;i++){ if(isDryTopping(nonWild[i])) dryCount++; }
      if(dryCount < reqDry){
        // wild can cover missing dry
        if(wildCount < (reqDry - dryCount)) return {ok:false, reason:"Needs " + reqDry + " dry toppings."};
      }

      // wet max 1
      var wetCount2 = 0;
      for(i=0;i<nonWild.length;i++){ if(isWet(nonWild[i])) wetCount2++; }
      if(wetCount2 > 1) return {ok:false, reason:"Only 1 wet topping."};

      var base3 = r.base;
      var grillBonus2 = 0;
      var prot2 = null;
      for(i=0;i<nonWild.length;i++){
        if(isProtein(nonWild[i]) && !isEgg(nonWild[i])) { prot2 = nonWild[i]; break; }
      }
      if(prot2 && GRILL_PROTEINS[prot2]) grillBonus2 = 1;

      var minReq = ctx.strict ? 5 : 3;
      var extras3 = Math.max(0, tileObjs.length - minReq);
      var pts = base3 + grillBonus2 + extras3;

      // Lauren‚Äôs Lunch: double lettuce on original play = +5
      var laurens = (occ["Lettuce"] || 0) >= 2;
      if(laurens) pts += 5;

      return {ok:true, recipeKey:r.key, name:r.name, base:base3, points:pts, grillBonus:grillBonus2, extras:extras3, laurensLunch:laurens};
    }

    return {ok:false, reason:"No match."};
  }

  function detectBestDish(tileObjs, ctx){
    tileObjs = tileObjs || [];
    if(tileObjs.length === 0) return {ok:false, reason:"No dish detected yet."};

    var names = [];
    for(var i=0;i<tileObjs.length;i++) names.push(tileObjs[i].name);

    var hasEgg = false, hasTort = false, hasWild = false;
    for(i=0;i<names.length;i++){
      if(names[i]==="Egg") hasEgg = true;
      if(isTortilla(names[i])) hasTort = true;
      if(isWild(names[i])) hasWild = true;
    }
    if(hasWild){ hasEgg = true; hasTort = true; } // wild can cover

    // recipe order preference
    var ordered = [];
    if(hasEgg && hasTort){
      ordered.push("breakfastTaco");
      for(i=0;i<RECIPES.length;i++) if(RECIPES[i].key!=="breakfastTaco") ordered.push(RECIPES[i].key);
    }else{
      for(i=0;i<RECIPES.length;i++) if(RECIPES[i].key!=="breakfastTaco") ordered.push(RECIPES[i].key);
      ordered.push("breakfastTaco");
    }

    var best = null;
    for(i=0;i<ordered.length;i++){
      var k = ordered[i];
      var v = validateRecipeForSelection(k, tileObjs, ctx);
      if(!v.ok) continue;
      if(!best || v.points > best.points) best = v;
    }
    if(!best) return {ok:false, reason:"No dish detected yet."};
    best.ok = true;
    return best;
  }

  // --- publish (Order Up) ---
  function publishSelectionAsDish(pid){
    var m = state.match;
    var pl = m.players[pid];
    var ctx = diffCtx();
    var selected = selectedTilesFor(pid);
    var best = detectBestDish(selected, ctx);
    if(!best.ok) return {ok:false, msg: best.reason};

    var usedIds = (pl.prepSelectedIds || []).slice(0);
    var usedTiles = [];
    for(var i=0;i<usedIds.length;i++){
      var id = usedIds[i];
      for(var j=0;j<pl.hand.length;j++){
        if(pl.hand[j].id === id){ usedTiles.push(pl.hand[j]); break; }
      }
    }

    // remove from hand
    for(i=0;i<usedTiles.length;i++){
      for(j=0;j<pl.hand.length;j++){
        if(pl.hand[j].id === usedTiles[i].id){ pl.hand.splice(j,1); break; }
      }
    }
    pl.prepSelectedIds = [];

    var pub = {
      id: nowId("pub"),
      owner: pid,
      ownerName: pl.name,
      recipeKey: best.recipeKey,
      name: best.name,
      basePts: best.base,
      points: best.points,
      tiles: [],
      isRemix: false
    };
    for(i=0;i<usedTiles.length;i++){
      pub.tiles.push({id: usedTiles[i].id, name: usedTiles[i].name});
    }
    m.publicLine.push(pub);

    // score
    pl.score += best.points;
    pl.servedThisHand += best.points;
    pl.logThisHand.push({ type:"serve", name: best.name, points: best.points });

    // kitchen open gate (Starter Pass for Chips & Dip)
    var turnPts = best.points;
    if(!m.kitchenOpen){
      if(best.recipeKey === RULES.starterPassDishKey && !pl.starterPassUsed){
        pl.starterPassUsed = true;
        turnPts = 0;
      }
    }
    m.servedThisTurnPts += turnPts;
    if(!m.kitchenOpen && m.servedThisTurnPts >= RULES.openKitchenTurnPts){
      m.kitchenOpen = true;
      toast("üî• Kitchen Open!");
    }

    if(best.laurensLunch){ toast("Lauren‚Äôs Lunch", 5000); }

    return {ok:true, dish: pub};
  }

  // --- remix (simple additive, from-hand only) ---
  function findBestRemix(pid){
    var m = state.match;
    var pl = m.players[pid];
    if(!m.kitchenOpen) return null;

    var selected = selectedTilesFor(pid);
    if(!selected || selected.length===0) return null;

    var strict = isStrict(state.settings.difficulty || "Easy");
    var best = null;

    for(var i=0;i<m.publicLine.length;i++){
      var d = m.publicLine[i];
      if(!d || !d.tiles) continue;

      // pick addable tiles
      var addable = [];
      for(var j=0;j<selected.length;j++){
        var nm = selected[j].name;
        if(isWild(nm)) { addable.push(selected[j]); continue; }
        if(strict){
          if(isDryTopping(nm) || isWet(nm)) addable.push(selected[j]);
        }else{
          addable.push(selected[j]);
        }
      }
      if(addable.length===0) continue;

      var cap = 4;
      var take = addable.slice(0, cap);
      var gain = take.length; // +1 per tile

      if(!best || gain > best.gain){
        var addIds = [];
        for(var k=0;k<take.length;k++) addIds.push(take[k].id);
        best = { dishId:d.id, dishName:d.name, addIds:addIds, gain:gain };
      }
    }

    if(!best || best.gain < 1) return null;
    return best;
  }

  function applyRemix(pid, plan){
    var m = state.match;
    var pl = m.players[pid];
    var target = null;
    for(var i=0;i<m.publicLine.length;i++){
      if(m.publicLine[i].id === plan.dishId){ target = m.publicLine[i]; break; }
    }
    if(!target) return {ok:false, msg:"No target."};

    // gather tiles from hand
    var addTiles = [];
    for(i=0;i<plan.addIds.length;i++){
      var id = plan.addIds[i];
      for(var j=0;j<pl.hand.length;j++){
        if(pl.hand[j].id === id){ addTiles.push(pl.hand[j]); break; }
      }
    }
    if(addTiles.length===0) return {ok:false, msg:"No tiles."};

    // remove from hand
    for(i=0;i<addTiles.length;i++){
      for(j=0;j<pl.hand.length;j++){
        if(pl.hand[j].id === addTiles[i].id){ pl.hand.splice(j,1); break; }
      }
    }
    // clear from prep selection
    var nextIds = [];
    for(i=0;i<(pl.prepSelectedIds||[]).length;i++){
      var keep = true;
      for(j=0;j<plan.addIds.length;j++){
        if(pl.prepSelectedIds[i] === plan.addIds[j]){ keep = false; break; }
      }
      if(keep) nextIds.push(pl.prepSelectedIds[i]);
    }
    pl.prepSelectedIds = nextIds;

    // append to dish
    if(!target.tiles) target.tiles = [];
    for(i=0;i<addTiles.length;i++){
      target.tiles.push({id:addTiles[i].id, name:addTiles[i].name});
    }
    target.isRemix = true;

    // scoring: +1 per added tile
    pl.score += addTiles.length;
    pl.remixGainThisHand += addTiles.length;
    pl.logThisHand.push({ type:"remix", name:"Remix: " + target.name, points:addTiles.length, from: target.ownerName });

    // Lauren‚Äôs Lunch on remix: toast only (no +5)
    var occ = countOcc((function(){
      var a=[]; for(var x=0;x<addTiles.length;x++) a.push(addTiles[x].name); return a;
    })());
    if((occ["Lettuce"]||0) >= 2) toast("Lauren‚Äôs Lunch", 5000);
    else toast("Remix!", 1600);

    return {ok:true};
  }

  // --- autoplate ---
  function computeBestPlateFromHand(pid){
    var m = state.match;
    var pl = m.players[pid];
    var ctx = diffCtx();
    var hand = pl.hand || [];
    if(hand.length===0) return null;

    function countWild(ids){
      var w = 0;
      for(var i=0;i<ids.length;i++){
        var id = ids[i];
        for(var j=0;j<hand.length;j++){
          if(hand[j].id===id && isWild(hand[j].name)) w++;
        }
      }
      return w;
    }
    function scoreCandidate(recipeKey, ids){
      var tiles = [];
      for(var i=0;i<ids.length;i++){
        for(var j=0;j<hand.length;j++){
          if(hand[j].id===ids[i]){ tiles.push(hand[j]); break; }
        }
      }
      var v = validateRecipeForSelection(recipeKey, tiles, ctx);
      if(!v.ok) return null;
      return { recipeKey:recipeKey, ids:ids, points:v.points, name:v.name, wilds:countWild(ids) };
    }
    function pickOne(name, used){
      for(var i=0;i<hand.length;i++){
        if(used[hand[i].id]) continue;
        if(hand[i].name===name) return hand[i].id;
      }
      return null;
    }
    function pickAny(pred, used){
      for(var i=0;i<hand.length;i++){
        if(used[hand[i].id]) continue;
        if(pred(hand[i].name)) return hand[i].id;
      }
      return null;
    }
    function pickWild(used){
      return pickOne("Grocery Run", used);
    }
    function pickMany(pred, n, used){
      var out = [];
      for(var i=0;i<hand.length && out.length<n;i++){
        if(used[hand[i].id]) continue;
        if(pred(hand[i].name)) out.push(hand[i].id);
      }
      return out;
    }

    var best = null;

    for(var r=0;r<RECIPES.length;r++){
      var rec = RECIPES[r];
      var ids = [];
      var used = {};

      if(rec.key==="breakfastTaco"){
        var tort = pickAny(isTortilla, used) || pickWild(used);
        if(tort){ ids.push(tort); used[tort]=true; }
        var egg = pickOne("Egg", used) || pickWild(used);
        if(egg){ ids.push(egg); used[egg]=true; }
        if(isLoose(ctx.difficulty)){
          var tops = pickMany(function(n){ return (isDryTopping(n) || isWet(n)) && n!=="Sour Cream" && n!=="Charro Beans" && n!=="Black Beans"; }, 2, used);
          for(var i0=0;i0<tops.length;i0++){ ids.push(tops[i0]); used[tops[i0]]=true; }
        }
      }else if(rec.kind==="chipsDip"){
        var chips = pickOne("Tortilla Chips", used) || pickWild(used);
        if(chips){ ids.push(chips); used[chips]=true; }
        var dip = pickAny(isDip, used) || pickWild(used);
        if(dip){ ids.push(dip); used[dip]=true; }
      }else if(rec.kind==="pico"){
        var need = ["Tomato","Onion","Cilantro","Lime Juice"];
        for(var ni=0; ni<need.length; ni++){
          var idn = pickOne(need[ni], used) || pickWild(used);
          if(idn){ ids.push(idn); used[idn]=true; }
        }
      }else if(rec.kind==="ench"){
        var tort2 = pickAny(isTortilla, used) || pickWild(used);
        var prot2 = pickAny(function(n){ return isProtein(n) && !isEgg(n); }, used) || pickWild(used);
        var sau2 = pickAny(isSauce, used) || pickWild(used);
        var che2 = pickAny(isCheese, used) || pickWild(used);
        var arr = [tort2, prot2, sau2, che2];
        for(var ai=0; ai<arr.length; ai++){
          if(arr[ai] && !used[arr[ai]]){ ids.push(arr[ai]); used[arr[ai]]=true; }
        }
        if(isLoose(ctx.difficulty)){
          var extras = pickMany(function(n){ return isDryTopping(n) || isWet(n); }, 2, used);
          for(ai=0; ai<extras.length; ai++){ ids.push(extras[ai]); used[extras[ai]]=true; }
        }
      }else if(rec.kind==="chorizo"){
        var tort3 = pickAny(isTortilla, used) || pickWild(used);
        var chor = pickOne("Chorizo", used) || pickWild(used);
        var on = pickOne("Onion", used) || pickWild(used);
        var cil = pickOne("Cilantro", used) || pickWild(used);
        arr = [tort3, chor, on, cil];
        for(ai=0; ai<arr.length; ai++){
          if(arr[ai] && !used[arr[ai]]){ ids.push(arr[ai]); used[arr[ai]]=true; }
        }
        if(isLoose(ctx.difficulty)){
          extras = pickMany(function(n){ return isDryTopping(n) || isWet(n); }, 1, used);
          for(ai=0; ai<extras.length; ai++){ ids.push(extras[ai]); used[extras[ai]]=true; }
        }
      }else if(rec.kind==="taco"){
        var tortReq = pickOne(rec.tortilla, used) || pickWild(used);
        var protReq = pickAny(function(n){ return isProtein(n) && !isEgg(n); }, used) || pickWild(used);
        if(tortReq){ ids.push(tortReq); used[tortReq]=true; }
        if(protReq){ ids.push(protReq); used[protReq]=true; }

        var reqDry = isStrict(ctx.difficulty) ? RULES.tacoDryStrict : RULES.tacoDryLoose;
        var dry = pickMany(isDryTopping, reqDry, used);
        for(ai=0; ai<dry.length; ai++){ ids.push(dry[ai]); used[dry[ai]]=true; }

        if(isLoose(ctx.difficulty)){
          extras = pickMany(function(n){ return isDryTopping(n) || isWet(n); }, 2, used);
          for(ai=0; ai<extras.length; ai++){ ids.push(extras[ai]); used[extras[ai]]=true; }
        }
      }

      var cand = scoreCandidate(rec.key, ids);
      if(!cand) continue;

      if(!best || cand.points > best.points || (cand.points === best.points && cand.wilds < best.wilds)){
        best = cand;
      }
    }

    return best;
  }

  // --- turn/cpu ---
  function cpuDelayMs(){
    var diff = state.settings.difficulty || "Easy";
    var base = DIFF_DELAY_MS[diff] || 2200;
    return Math.max(450, base + randInt(220));
  }

  function endTurn(pid){
    var m = state.match;
    if(m.activePid !== pid) return;

    var order = [];
    for(var k in m.players) if(m.players.hasOwnProperty(k)) order.push(k);
    // stable order P1..P4
    order.sort();

    var i = 0;
    for(i=0;i<order.length;i++) if(order[i]===pid) break;
    var next = order[(i+1) % order.length];

    m.activePid = next;
    beginTurn(next);
    persist();
    render();

    if(next !== "P1"){
      setTimeout(function(){ cpuAct(next); }, cpuDelayMs());
    }else{
      toast("Your turn.");
    }
  }

  function cpuAct(pid){
    var m = state.match;
    var pl = m.players[pid];
    if(!pl || pl.isHuman) return;

    var diff = state.settings.difficulty || "Easy";
    var strict = isStrict(diff);
    var wildSavor = strict; // ‚Äúon‚Äù for Difficult/Master Chef

    // strict CPU can remix
    if(strict && m.kitchenOpen && m.publicLine.length){
      // pick up to 3 toppings
      var tops = [];
      for(var i=0;i<pl.hand.length && tops.length<3;i++){
        var nm = pl.hand[i].name;
        if((isDryTopping(nm) || isWet(nm)) && !isWild(nm)) tops.push(pl.hand[i]);
      }
      if(tops.length >= 2){
        var target = m.publicLine[m.publicLine.length-1];
        var plan = { dishId: target.id, dishName: target.name, addIds: [], gain: tops.length };
        for(i=0;i<tops.length;i++) plan.addIds.push(tops[i].id);
        applyRemix(pid, plan);
        endTurn(pid);
        return;
      }
    }

    // dish play: compare with/without wild; only use wild if +4 or more
    var bestWith = computeBestPlateFromHand(pid);
    var bestNo = null;
    if(wildSavor){
      // temporarily remove wilds
      var save = pl.hand.slice(0);
      var noWild = [];
      for(var i2=0;i2<pl.hand.length;i2++) if(pl.hand[i2].name !== "Grocery Run") noWild.push(pl.hand[i2]);
      pl.hand = noWild;
      bestNo = computeBestPlateFromHand(pid);
      pl.hand = save;
      if(bestWith && bestNo){
        var delta = bestWith.points - bestNo.points;
        if(delta < 4) bestWith = bestNo;
      }
    }

    if(bestWith && bestWith.ids && bestWith.ids.length){
      pl.prepSelectedIds = bestWith.ids.slice(0,10);
      publishSelectionAsDish(pid);
    }else{
      if(m.bag.length>0 && !pl.didDrawThisTurn){
        drawTile(pid);
      }
    }

    endTurn(pid);
  }

  // --- prep selection ---
  function togglePrepSelect(pid, tileId){
    var m = state.match;
    var pl = m.players[pid];
    if(m.activePid !== pid){ toast("Not your turn."); return; }

    if(!pl.prepSelectedIds) pl.prepSelectedIds = [];

    var idx = -1;
    for(var i=0;i<pl.prepSelectedIds.length;i++){
      if(pl.prepSelectedIds[i] === tileId){ idx=i; break; }
    }
    if(idx >= 0){
      pl.prepSelectedIds.splice(idx,1);
    }else{
      if(pl.prepSelectedIds.length >= 10){ toast("Prep window is full."); return; }
      pl.prepSelectedIds.push(tileId);
    }
    persist();
    render();
  }
  function clearPrep(pid){
    var pl = state.match.players[pid];
    pl.prepSelectedIds = [];
    persist();
    render();
  }

  // --- draw modal ---
  function bestFitCols(n){
    if(n >= 25) return 5;
    var c = Math.ceil(Math.sqrt(n));
    return clamp(c, 1, 5);
  }
  function openDrawModal(){
    var m = state.match;
    var pl = p1();
    var myTurn = (m.activePid === "P1");

    if(!myTurn){ toast("Not your turn."); return; }
    if(pl.didDrawThisTurn){ toast("Only one draw per turn."); return; }

    var total = m.bag.length;
    if(total === 0){
      openModal(t("drawTile"), '<div class="muted">No more tiles to choose from.</div>', [
        {text:t("close"), className:"primary", onClick: closeModal}
      ]);
      return;
    }

    var shown = Math.min(25, total);
    var cols = bestFitCols(shown);
    var appName = escapeHtml(getAppName());

    var meta =
      '<div class="drawMeta">' +
        '<span class="pill">Tiles Remaining <span class="mono">' + total + '</span></span>' +
        (total > 25 ? '<span class="pill muted">Showing <span class="mono">25</span></span>' : '') +
      '</div>' +
      '<div class="muted small">Pick a tile, any tile...</div>';

    var grid = '<div class="drawGrid" id="drawGrid" style="grid-template-columns: repeat(' + cols + ', 1fr);">';
    for(var i=0;i<shown;i++){
      grid +=
        '<div class="tileCard" data-draw-pick="' + i + '">' +
          '<div class="tileFlip" id="flip_' + i + '">' +
            '<div class="tileFace tileBack">' +
              '<div class="tileBackNum">' + (i+1) + '/' + shown + '</div>' +
              '<div class="tileBackInner">' + appName + '</div>' +
            '</div>' +
            '<div class="tileFace tileFront">' +
              '<div class="frontName" id="front_' + i + '">‚Äî</div>' +
            '</div>' +
          '</div>' +
        '</div>';
    }
    grid += '</div>';

    openModal(t("drawTile"), meta + grid, [{text:t("cancel"), className:"ghost", onClick: closeModal}]);
    modalMode = "draw";

    $("modalBody").onclick = function(e){
      if(modalMode !== "draw") return;
      var pick = e.target.closest("[data-draw-pick]");
      if(!pick) return;

      var idx = parseInt(pick.getAttribute("data-draw-pick"),10);
      var flip = $("flip_" + idx);
      var gridEl = $("drawGrid");
      if(gridEl) gridEl.className = gridEl.className + " busy";
      if(flip) flip.className = flip.className + " tilePickOutline";

      modalMode = "draw_busy";

      var res = drawTile("P1");
      if(!res.ok){
        closeModal();
        toast(res.msg || "Cannot draw.");
        persist();
        render();
        return;
      }

      var front = $("front_" + idx);
      if(front) front.textContent = res.tile.name;

      // flip
      setTimeout(function(){
        if(flip && flip.className.indexOf("reveal") < 0) flip.className += " reveal";
      }, 0);

      // close after reveal
      setTimeout(function(){
        closeModal();
        persist();
        render();
        if(state.flags.sawFirstDraw && !state.settings.tutorialHidden){
          openTutorialModal();
        }
      }, 1150);
    };
  }

  // --- tutorial ---
  function openTutorialModal(){
    // avoid stacking
    if($("modalWrap").classList.contains("on")) closeModal();
    modalMode = "tutorial";

    var pages = [
      {title:"Next step", text:"Use the ingredients in your hand to load your Prep Window. When a dish is detected, Order Up becomes available."},
      {title:"Opening the kitchen", text:"Serve 10+ points in a single turn to open the kitchen. Once it‚Äôs open, wet toppings become available."},
      {title:"Remixing", text:"When the kitchen is open, you can improve the public line using tiles from your hand. Remix points are additive."},
      {title:"Bonuses", text:"Some combos trigger fun bonuses and achievements. (Example: double lettuce shows Lauren‚Äôs Lunch.)"},
      {title:"Difficulty", text:"Beginner/Easy/Medium are forgiving and include helpers. Difficult/Master Chef are strict and CPUs remix smarter."}
    ];

    var html = '<div class="tutWrap"><div class="tutStrip" id="tutStrip">';
    for(var i=0;i<pages.length;i++){
      html +=
        '<div class="tutPage">' +
          '<div class="tutTitle">' + escapeHtml(pages[i].title) + '</div>' +
          '<div class="tutText">' + escapeHtml(pages[i].text) + '</div>' +
          '<div class="hint" style="margin-top:12px;">Swipe to continue.</div>' +
        '</div>';
    }
    html += '</div></div><div class="tutDots" id="tutDots">';
    for(i=0;i<pages.length;i++){
      html += '<div class="dot ' + (i===0 ? 'on' : '') + '"></div>';
    }
    html += '</div>';

    openModal("Tutorial", html, [
      {text:t("hide"), className:"ghost", onClick:function(){ state.settings.tutorialHidden = true; persist(); closeModal(); }},
      {text:t("close"), className:"primary", onClick:function(){ persist(); closeModal(); }}
    ]);

    var strip = $("tutStrip");
    var dots = $("tutDots") ? $("tutDots").querySelectorAll(".dot") : [];
    function updateDots(){
      if(!strip) return;
      var w = strip.clientWidth || 1;
      var idx = Math.round(strip.scrollLeft / w);
      for(var i=0;i<dots.length;i++){
        if(dots[i].classList) dots[i].classList.toggle("on", i===idx);
      }
    }
    if(strip){
      strip.addEventListener("scroll", function(){ window.requestAnimationFrame(updateDots); });
    }
  }

  // --- menu guide ---
  function renderMenuGuide(){
    var lines = [];
    lines.push('<div class="label">Breakfast Taco (3 pts)</div><div class="hint">Tortilla + Egg required. Wet: max 1. Dry toppings can be doubled. No Sour Cream / Charro Beans / Black Beans.</div>');
    lines.push('<div class="label">Hard Shell Taco (base 5 pts)</div><div class="hint">Corn tortilla + protein + dry toppings. Strict mode requires more toppings.</div>');
    lines.push('<div class="label">Soft Taco (base 5 pts)</div><div class="hint">Flour tortilla + protein + dry toppings.</div>');
    lines.push('<div class="label">Chorizo Taco (base 8 pts)</div><div class="hint">Tortilla + Chorizo + Onion + Cilantro.</div>');
    lines.push('<div class="label">Chips & Dip (5 pts)</div><div class="hint">Tortilla Chips + (Salsa/Guac/Queso). Starter Pass usable once before kitchen opens.</div>');
    lines.push('<div class="label">Pico de Gallo (8 pts)</div><div class="hint">Tomato + Onion + Cilantro + Lime Juice. No extras.</div>');
    lines.push('<div class="label">Enchiladas (base 10 pts)</div><div class="hint">Tortillas + Protein + Sauce + Cheese. Up to 3 toppings.</div>');

    var sep = '<div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>';
    $("menuGuideBody").innerHTML = lines.join(sep);
  }

  // --- rendering ---
  function phaseText(){
    var m = state.match;
    if(m.kitchenOpen) return {title:"Kitchen Open", desc:"Wet toppings unlocked. Remix is enabled."};
    if(m.publicLine.length > 0) return {title:"Appetizers Out", desc:"Build toward 10+ points in a single turn to open the kitchen."};
    return {title:"Not Seated Yet", desc:"Serve 10+ points in one turn to open the kitchen."};
  }
  function playerColor(pid){
    var m = state.match;
    return (m.players[pid] && m.players[pid].color) ? m.players[pid].color : "#ffffff";
  }

  function renderPublicLine(){
    var m = state.match;
    var el = $("publicLine");
    $("lineSummary").textContent = m.publicLine.length + " dish" + (m.publicLine.length===1 ? "" : "es");

    if(!m.publicLine.length){
      el.innerHTML = '<div class="muted small">No dishes in the window yet.</div>';
      return;
    }

    var groups = groupBy(m.publicLine, function(d){ return d.name; });
    var html = "";

    for(var menuItem in groups){
      if(!groups.hasOwnProperty(menuItem)) continue;
      var dishes = groups[menuItem];
      var total = 0;
      for(var i=0;i<dishes.length;i++) total += (dishes[i].points||0);

      html += '<div class="pubGroup">' +
                '<div class="pubGroupTitle">' +
                  '<div>' + escapeHtml(menuItem) + '</div>' +
                  '<span class="badge">Total <span class="mono">' + total + '</span></span>' +
                '</div>';

      for(i=0;i<dishes.length;i++){
        var d = dishes[i];
        var col = playerColor(d.owner);
        var tintA = hexToRgba(col, 0.28);
        var tiles = "";
        var arr = d.tiles || [];
        for(var j=0;j<arr.length;j++){
          var nm = arr[j].name;
          var cat = ingredientCategory(nm);
          var wild = isWild(nm) ? "wild" : "";
          tiles += '<span class="tile ' + wild + ' cat-' + cat + '" style="cursor:default;">' + escapeHtml(nm) + '</span>';
        }
        html += '<div class="pubDishRow" style="--tintA:' + tintA + ';">' +
                  '<div class="pubDishMeta">' +
                    '<div>' + escapeHtml(d.ownerName) + (d.isRemix ? " ‚Ä¢ Remix" : "") + '</div>' +
                    '<span class="badge">' + (d.points||0) + ' pts</span>' +
                  '</div>' +
                  '<div class="tiles" style="margin-top:8px;">' + tiles + '</div>' +
                '</div>';
      }

      html += '</div>';
    }

    el.innerHTML = html;
  }

  function renderGameplay(){
    var m = state.match;
    var myTurn = (m.activePid === "P1");

    document.documentElement.style.setProperty("--accent", state.settings.accent);
    document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, 0.14));

    $("navGame").querySelector(".tx").textContent = t("gameplay");
    $("navPrep").querySelector(".tx").textContent = t("prep");
    $("navScores").querySelector(".tx").textContent = t("scores");
    $("navSettings").querySelector(".tx").textContent = t("settings");

    $("btnPrep").textContent = t("prepDish");
    $("btnEndTurn").textContent = t("endTurn");
    $("btnOrderUp").textContent = t("orderUp");

    $("btnPrep").classList.toggle("pulse", myTurn);

    $("tilesRemainBadge").textContent = "Tiles Remaining " + m.bag.length;
    $("kitchenBadge").textContent = m.kitchenOpen ? "Kitchen Open" : "Kitchen Closed";
    $("handBadge").textContent = "Hand " + m.handIndex + "/" + (state.settings.handsTotal || 12);
    $("turnBadge").textContent = myTurn ? "Your Turn" : (m.players[m.activePid].name + "'s Turn");

    var ph = phaseText();
    $("phaseTitle").textContent = ph.title;
    $("phaseDesc").textContent = ph.desc;

    var sel = selectedTilesFor("P1");
    var best = detectBestDish(sel, diffCtx());
    var canOrder = myTurn && best.ok;

    $("btnOrderUp").disabled = !canOrder;
    $("btnOrderUp").classList.toggle("pulseOrder", canOrder);

    $("btnPrep").disabled = !myTurn;
    $("btnEndTurn").disabled = !myTurn;

    renderPublicLine();
  }

  function renderPrep(){
    var m = state.match;
    var pl = p1();
    var myTurn = (m.activePid === "P1");

    $("prepTurnBadge").textContent = myTurn ? "Your Turn" : (m.players[m.activePid].name + "'s Turn");
    $("handCountHint").textContent = (pl.hand ? pl.hand.length : 0) + " tiles";

    $("btnDraw").textContent = t("drawTile");
    $("btnDraw").disabled = (!myTurn) || pl.didDrawThisTurn || (m.bag.length===0);
    $("btnDraw").classList.toggle("pulse", myTurn && !pl.didDrawThisTurn && m.bag.length>0);

    var diff = state.settings.difficulty || "Easy";
    var showAutoPlate = myTurn && (diff==="Beginner" || diff==="Easy");
    $("btnAutoPlate").style.display = showAutoPlate ? "inline-flex" : "none";

    var showAutoRemix = myTurn && diff==="Beginner" && m.kitchenOpen;
    $("btnAutoRemix").style.display = showAutoRemix ? "inline-flex" : "none";

    var ids = (pl.prepSelectedIds || []).slice(0,10);
    $("prepLoadedHint").textContent = ids.length + "/10 loaded";

    var selected = selectedTilesFor("P1");
    var ctx = diffCtx();
    var best = detectBestDish(selected, ctx);

    // slots
    var slotsHtml = "";
    for(var i=0;i<10;i++){
      var tObj = selected[i];
      if(!tObj){
        slotsHtml += '<div class="slot"><div class="sHint">Empty</div></div>';
      }else{
        var cat = ingredientCategory(tObj.name);
        slotsHtml += '<div class="slot filled" data-prep-remove="' + escapeHtml(tObj.id) + '">' +
                       '<div class="sName">' + escapeHtml(tObj.name) + '</div>' +
                       '<div class="muted2 small" style="margin-top:6px;">' + escapeHtml(categoryLabel(cat)) + '</div>' +
                     '</div>';
      }
    }
    $("prepSlots").innerHTML = slotsHtml;

    $("prepStatus").textContent = best.ok ? (best.name + " detected.") : best.reason;

    var canOrder = myTurn && best.ok;
    $("btnOrderUpFromPrep").disabled = !canOrder;
    $("btnOrderUpFromPrep").classList.toggle("pulseOrder", canOrder);
    $("btnOrderUpFromPrep").textContent = t("orderUp");

    // auto-plate enable
    if(showAutoPlate){
      var plate = computeBestPlateFromHand("P1");
      $("btnAutoPlate").disabled = !plate;
    }
    if(showAutoRemix){
      var plan = findBestRemix("P1");
      $("btnAutoRemix").disabled = !plan;
    }

    // hand groups
    var grouped = groupBy(pl.hand || [], function(ti){ return ingredientCategory(ti.name); });
    var order = ["tortilla","protein","cheese","wet","drytop","wild","other"];
    var handHtml = '<div class="handGroups">';
    for(var oi=0;oi<order.length;oi++){
      var cat2 = order[oi];
      var tiles = grouped[cat2] || [];
      if(!tiles.length) continue;

      handHtml += '<div class="handGroup">' +
                    '<div class="handGroupTitle">' +
                      '<span>' + escapeHtml(categoryLabel(cat2)) + '</span>' +
                      '<span class="count">' + tiles.length + '</span>' +
                    '</div>' +
                    '<div class="tiles">';

      for(var j=0;j<tiles.length;j++){
        var ti = tiles[j];
        var inPrep = false;
        var selIds = pl.prepSelectedIds || [];
        for(var s=0;s<selIds.length;s++){ if(selIds[s]===ti.id){ inPrep=true; break; } }
        var wild = isWild(ti.name) ? "wild" : "";
        handHtml += '<span class="tile ' + (inPrep ? "sel " : "") + wild + ' cat-' + cat2 + '" data-htile="' + escapeHtml(ti.id) + '">' +
                      escapeHtml(ti.name) +
                    '</span>';
      }

      handHtml += '</div></div>';
    }
    handHtml += '</div>';
    $("handTiles").innerHTML = handHtml;

    renderMenuGuide();
  }

  function renderScores(){
    var m = state.match;
    var pl = p1();

    $("scoreModePill").textContent = (state.settings.mode === "campaign") ? "Campaign" : "Standard";
    $("scoreCurrent").textContent = "Current: " + pl.score;
    $("scoreServedMuted").textContent = "Served this hand: " + pl.servedThisHand;

    var players = [];
    for(var pid in m.players) if(m.players.hasOwnProperty(pid)) players.push(m.players[pid]);
    players.sort(function(a,b){ return a.id < b.id ? -1 : 1; });

    var out = "";
    for(var i=0;i<players.length;i++){
      var p = players[i];
      var col = playerColor(p.id);
      var tintA = hexToRgba(col, 0.18);

      var dishLines = "";
      if(p.logThisHand && p.logThisHand.length){
        for(var j=0;j<p.logThisHand.length;j++){
          var ev = p.logThisHand[j];
          var extra = (ev.type==="remix") ? ' <span class="muted2 small">(from ' + escapeHtml(ev.from || "‚Äî") + ')</span>' : '';
          dishLines += '<div class="row sp" style="gap:12px; margin-top:8px;">' +
                         '<div style="font-weight:900;">' + escapeHtml(ev.name) + extra + '</div>' +
                         '<span class="badge">' + ev.points + '</span>' +
                       '</div>';
        }
      }else{
        dishLines = '<div class="muted small">No dishes served yet this hand.</div>';
      }

      var net = (p.remixGainThisHand||0) - (p.remixLossThisHand||0);
      var netTxt = (net===0) ? "0" : (net>0 ? ("+"+net) : String(net));

      out +=
        '<details class="acc" style="margin-top:12px; background: rgba(255,255,255,.03);">' +
          '<summary>' +
            '<span>' + escapeHtml(p.name) + (p.id==="P1" ? " (You)" : "") + '</span>' +
            '<span class="badge">Score ' + p.score + '</span>' +
          '</summary>' +
          '<div class="accBody" style="position:relative; overflow:hidden;">' +
            '<div style="position:absolute; inset:0; background: linear-gradient(135deg, ' + tintA + ', transparent 70%); opacity:.9; pointer-events:none;"></div>' +
            '<div style="position:relative; z-index:1;">' +
              '<div class="row wrap" style="gap:10px; margin-top:6px;">' +
                '<span class="pill">Served: ' + p.servedThisHand + '</span>' +
                '<span class="pill">Remix Net: ' + netTxt + '</span>' +
              '</div>' +
              '<div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>' +
              dishLines +
            '</div>' +
          '</div>' +
        '</details>';
    }
    $("scoreList").innerHTML = out;
  }

  function fillSettings(){
    // difficulty
    var sd = $("selDifficulty");
    if(sd){
      sd.innerHTML = "";
      for(var i=0;i<DIFFS.length;i++){
        var op = document.createElement("option");
        op.value = DIFFS[i];
        op.textContent = DIFFS[i];
        sd.appendChild(op);
      }
      sd.value = state.settings.difficulty;
    }

    // accent
    var sa = $("selAccent");
    if(sa){
      sa.innerHTML = "";
      for(i=0;i<ACCENTS.length;i++){
        op = document.createElement("option");
        op.value = ACCENTS[i].val;
        op.textContent = ACCENTS[i].name + " (" + ACCENTS[i].val + ")";
        sa.appendChild(op);
      }
      sa.value = state.settings.accent;
    }

    $("selMode").value = state.settings.mode;
    $("selPlayers").value = String(state.settings.players);
    $("inpHands").value = state.settings.handsTotal;
    $("inpTilesPerPlayer").value = state.settings.tilesPerPlayer;
    $("selDecks").value = String(state.settings.decks);
    $("selLang").value = state.settings.lang;
  }

  function setNavActive(btnId){
    var ids = ["navGame","navPrep","navScores","navSettings"];
    for(var i=0;i<ids.length;i++){
      $(ids[i]).classList.toggle("active", ids[i]===btnId);
    }
  }

  function setPage(p){
    state.ui.page = p;
    persist();
    render();
  }

  function render(){
    if(!state.match) newMatch();

    $("pageGameplay").classList.remove("on");
    $("pagePrep").classList.remove("on");
    $("pageScores").classList.remove("on");
    $("pageSettings").classList.remove("on");

    if(state.ui.page==="gameplay"){ $("pageGameplay").classList.add("on"); setNavActive("navGame"); }
    if(state.ui.page==="prep"){ $("pagePrep").classList.add("on"); setNavActive("navPrep"); }
    if(state.ui.page==="scores"){ $("pageScores").classList.add("on"); setNavActive("navScores"); }
    if(state.ui.page==="settings"){ $("pageSettings").classList.add("on"); setNavActive("navSettings"); }

    fillSettings();
    renderGameplay();
    renderPrep();
    renderScores();
  }

  // --- wire UI ---
  function wire(){
    $("navGame").onclick = function(){ setPage("gameplay"); };
    $("navPrep").onclick = function(){ setPage("prep"); };
    $("navScores").onclick = function(){ setPage("scores"); };
    $("navSettings").onclick = function(){ setPage("settings"); };

    $("btnNewMatchTop").onclick = function(){
      openModal("New Match", "Start a fresh match? This overwrites current match state.", [
        {text:t("cancel"), className:"ghost", onClick: closeModal},
        {text:t("start"), className:"primary", onClick: function(){ closeModal(); newMatch(); }}
      ]);
    };

    $("btnPrep").onclick = function(){
      if(state.match.activePid !== "P1"){ toast("Not your turn."); return; }
      setPage("prep");
    };

    $("btnEndTurn").onclick = function(){
      if(state.match.activePid !== "P1"){ toast("Not your turn."); return; }
      endTurn("P1");
    };

    $("btnOrderUp").onclick = function(){
      if(state.match.activePid !== "P1"){ toast("Not your turn."); return; }

      var sel = selectedTilesFor("P1");
      var best = detectBestDish(sel, diffCtx());
      if(best.ok){
        var res = publishSelectionAsDish("P1");
        if(!res.ok){ toast(res.msg || "No qualifying dish."); return; }
        persist(); render();
        toast("Order up!");
        return;
      }

      var plan = findBestRemix("P1");
      if(plan){
        var out = applyRemix("P1", plan);
        if(out.ok){ persist(); render(); toast("Remix!", 1400); return; }
      }
      toast("No qualifying dish.");
    };

    $("btnDraw").onclick = openDrawModal;

    $("btnOrderUpFromPrep").onclick = function(){
      if(state.match.activePid !== "P1"){ toast("Not your turn."); return; }

      var sel = selectedTilesFor("P1");
      var best = detectBestDish(sel, diffCtx());
      if(best.ok){
        var res = publishSelectionAsDish("P1");
        if(!res.ok){ toast(res.msg || "No qualifying dish."); return; }
        persist(); render(); setPage("gameplay"); toast("Order up!");
        return;
      }
      var plan = findBestRemix("P1");
      if(plan){
        var out = applyRemix("P1", plan);
        if(out.ok){ persist(); render(); setPage("gameplay"); return; }
      }
      toast("No qualifying dish.");
    };

    $("btnClearPrep").onclick = function(){ clearPrep("P1"); };

    $("btnAutoPlate").onclick = function(){
      if(state.match.activePid !== "P1"){ toast("Not your turn."); return; }
      var diff = state.settings.difficulty || "Easy";
      if(!(diff==="Beginner" || diff==="Easy")) return;

      var best = computeBestPlateFromHand("P1");
      if(!best){ toast("No valid plate found."); return; }

      p1().prepSelectedIds = best.ids.slice(0,10);
      persist(); render();
      toast("Auto-Plate loaded.");
    };

    $("btnAutoRemix").onclick = function(){
      if(state.match.activePid !== "P1"){ toast("Not your turn."); return; }
      if(!state.match.kitchenOpen){ toast("Kitchen is closed."); return; }
      if(state.settings.difficulty !== "Beginner") return;

      var plan = findBestRemix("P1");
      if(!plan){ toast("No remix detected."); return; }

      // per-player delta UI (only additive in this MVP)
      var m = state.match;
      var deltaLines = "";
      for(var pid in m.players){
        if(!m.players.hasOwnProperty(pid)) continue;
        var nm = m.players[pid].name;
        var delta = (pid==="P1") ? plan.gain : 0;
        deltaLines +=
          '<div class="row sp" style="gap:10px; margin-top:8px;">' +
            '<div style="font-weight:900;">' + escapeHtml(nm) + '</div>' +
            '<span class="badge">' + (delta>=0 ? "+" : "") + delta + '</span>' +
          '</div>';
      }

      openModal("Auto-Remix",
        '<div class="muted">Proposed: add ' + plan.gain + ' tile(s) onto <b>' + escapeHtml(plan.dishName) + '</b>.</div>' +
        '<div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>' +
        '<div class="muted2 small">Score deltas</div>' + deltaLines,
        [
          {text:t("cancel"), className:"ghost", onClick: closeModal},
          {text:"Accept", className:"primary", onClick:function(){ closeModal(); var out = applyRemix("P1", plan); if(out.ok){ persist(); render(); } }}
        ]
      );
    };

    // hand click (event delegation)
    $("handTiles").addEventListener("click", function(e){
      var el = e.target.closest("[data-htile]");
      if(!el) return;
      togglePrepSelect("P1", el.getAttribute("data-htile"));
    });

    $("prepSlots").addEventListener("click", function(e){
      var el = e.target.closest("[data-prep-remove]");
      if(!el) return;
      var id = el.getAttribute("data-prep-remove");
      var pl = p1();
      var next = [];
      for(var i=0;i<(pl.prepSelectedIds||[]).length;i++){
        if(pl.prepSelectedIds[i] !== id) next.push(pl.prepSelectedIds[i]);
      }
      pl.prepSelectedIds = next;
      persist(); render();
    });

    // settings
    $("selMode").onchange = function(){ state.settings.mode = $("selMode").value; persist(); render(); toast("Mode updated."); };
    $("selPlayers").onchange = function(){ state.settings.players = parseInt($("selPlayers").value,10) || 4; persist(); newMatch(); };
    $("selDifficulty").onchange = function(){ state.settings.difficulty = $("selDifficulty").value; persist(); render(); };
    $("inpHands").onchange = function(){ state.settings.handsTotal = clamp(parseInt($("inpHands").value,10) || 12, 1, 12); persist(); render(); };
    $("inpTilesPerPlayer").onchange = function(){ state.settings.tilesPerPlayer = clamp(parseInt($("inpTilesPerPlayer").value,10) || 16, 8, 24); persist(); newMatch(); };
    $("selDecks").onchange = function(){ state.settings.decks = parseInt($("selDecks").value,10) || 2; persist(); newMatch(); };
    $("selAccent").onchange = function(){
      state.settings.accent = $("selAccent").value;
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, 0.14));
      if(state.match){
        state.match.players["P1"].color = state.settings.accent;
        var cpuCols = ensureUniqueCpuColors();
        if(state.match.players["P2"]) state.match.players["P2"].color = cpuCols[0];
        if(state.match.players["P3"]) state.match.players["P3"].color = cpuCols[1];
        if(state.match.players["P4"]) state.match.players["P4"].color = cpuCols[2];
      }
      persist(); render();
    };
    $("selLang").onchange = function(){ state.settings.lang = $("selLang").value; persist(); render(); };
    $("btnViewTutorial").onclick = openTutorialModal;
  }

  // --- boot ---
  function boot(){
    // set accent vars
    document.documentElement.style.setProperty("--accent", state.settings.accent);
    document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, 0.14));

    // ensure match arrays exist (older saves)
    if(state.match && state.match.players){
      if(state.match.players["P1"]) state.match.players["P1"].color = state.settings.accent;
      var cpuCols = ensureUniqueCpuColors();
      if(state.match.players["P2"]) state.match.players["P2"].color = cpuCols[0];
      if(state.match.players["P3"]) state.match.players["P3"].color = cpuCols[1];
      if(state.match.players["P4"]) state.match.players["P4"].color = cpuCols[2];

      for(var pid in state.match.players){
        if(!state.match.players.hasOwnProperty(pid)) continue;
        var p = state.match.players[pid];
        if(!p.prepSelectedIds) p.prepSelectedIds = [];
        if(!p.hand) p.hand = [];
        if(!p.logThisHand) p.logThisHand = [];
      }
    }

    wire();
    if(!state.match) newMatch();
    render();
  }

  boot();

})();
</script>
</body>
</html>
