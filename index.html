<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Taco Ria</title>
  <style>
    :root{
      --bg:#050608;
      --bg2:#0a0c10;
      --text:#f3f4f6;
      --muted:rgba(243,244,246,.70);
      --muted2:rgba(243,244,246,.55);
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.14);
      --danger:#ff3b30;

      --accent:#00e5ff; /* user-configurable secondary */
      --accentSoft: rgba(0,229,255,.14);

      --radius:20px;
      --pad:16px;
      --gap:12px;
      --shadow: 0 18px 45px rgba(0,0,0,.55);

      --navH:56px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(900px 380px at 18% 0%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(780px 360px at 85% 10%, rgba(255,255,255,.05), transparent 65%),
        radial-gradient(820px 420px at 50% 115%, rgba(0,0,0,.75), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow-x:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    /* Mobile guideline widths */
    .shell{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      width:100%;
      margin:0 auto;
      max-width: 980px;
    }
    @media (max-width: 430px){
      .shell{ max-width: 375px; }
    }
    @media (max-width: 390px){
      .shell{ max-width: 360px; }
    }

    header{
      padding: 14px 14px 10px;
      min-height:56px;
    }
    main{
      flex:1;
      padding: 0 14px calc(var(--navH) + env(safe-area-inset-bottom) + 18px);
    }

    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ min-width:0; }
    .wrap{ flex-wrap:wrap; }
    .sp{ justify-content:space-between; }

    .pageTitle{
      font-weight:1000;
      letter-spacing:.2px;
      line-height:1.08;
      font-size: clamp(20px, 4.7vw, 28px);
    }
    .small{ font-size:12px; }
    .muted{ color:var(--muted); }
    .muted2{ color:var(--muted2); }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.065), rgba(255,255,255,.035));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: var(--shadow);
    }

    .heroPhase{
      position:relative;
      overflow:hidden;
    }
    .heroPhase::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(600px 240px at 20% 0%, rgba(255,255,255,.08), transparent 65%),
        radial-gradient(520px 240px at 85% 10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(540px 260px at 50% 120%, rgba(0,0,0,.60), transparent 55%);
      pointer-events:none;
    }
    .heroPhase > *{ position:relative; z-index:1; }

    .pills{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    button{
      border:1px solid var(--stroke2);
      background: rgba(0,0,0,.35);
      color:var(--text);
      border-radius: 18px;
      padding: 12px 14px;
      font-weight:1000;
      letter-spacing:.2px;
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }
    .btnTiny{ padding:8px 10px; border-radius:14px; font-size:12px; }
    .ghost{ background: rgba(0,0,0,.20); }
    .primary{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border-color: rgba(255,255,255,.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 20px rgba(0,0,0,.55);
    }
    .danger{
      background: linear-gradient(180deg, rgba(255,59,48,.22), rgba(255,59,48,.10));
      border-color: rgba(255,59,48,.35);
    }

    /* Sticky action tray above bottom nav */
    .actionsTray{
      position: sticky;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom));
      z-index: 30;
    }
    .actionsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .actionsGrid button{ min-height:52px; }

    /* Tiles */
    .tiles{ display:flex; flex-wrap:wrap; gap:8px; }
    .tile{
      max-width:100%;
      overflow-wrap:anywhere;
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      font-weight: 900;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
    }
    .tile.sel{
      outline: 2px solid rgba(0,229,255,.55);
      transform: translateY(-1px);
    }
    .tile.wild{ border-color: rgba(255,255,255,.28); box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset; }
    .tile.wet{ border-color: rgba(0,229,255,.25); }

    /* Public grouping */
    .pubGroups{
      display:grid;
      grid-template-columns: 1fr 1fr; /* 50% width */
      gap:10px;
    }
    @media (max-width: 420px){
      .pubGroups{ grid-template-columns: 1fr; }
    }
    .pubGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      padding:12px;
    }
    .pubGroupTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
      margin-bottom: 8px;
    }
    .pubDishRow{
      border:1px solid var(--stroke);
      border-radius:16px;
      background: rgba(0,0,0,.45);
      padding:10px;
      margin-top:10px;
      position:relative;
      overflow:hidden;
    }
    .pubDishRow::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, var(--tintA), transparent 70%);
      opacity:.95;
      pointer-events:none;
    }
    .pubDishRow > *{ position:relative; z-index:1; }
    .pubDishMeta{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
    }

    /* Now Serving strip */
    .serveStrip{
      display:flex;
      gap:10px;
      overflow-x:auto;
      padding-bottom:6px;
      -webkit-overflow-scrolling:touch;
      scroll-snap-type:x mandatory;
    }
    .serveCard{
      flex:0 0 auto;
      width:min(240px,78vw);
      scroll-snap-align:start;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      padding:12px;
      box-shadow: 0 12px 30px rgba(0,0,0,.45);
      position:relative;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
    }
    .serveCard::before{
      content:"";
      position:absolute; inset:-40px;
      background: radial-gradient(380px 160px at 20% 0%, rgba(255,255,255,.07), transparent 60%);
      pointer-events:none;
    }
    .serveCard > *{ position:relative; z-index:1; }
    .serveTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; font-weight:1000; }
    .serveMeta{ margin-top:6px; font-size:12px; color:var(--muted); }
    .serveBad{
      display:inline-flex; align-items:center; gap:8px;
      margin-top:8px;
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.30);
    }
    .serveCard.sel{ outline: 2px solid rgba(0,229,255,.55); transform: translateY(-1px); }
    .serveCard.invalid{ opacity:.72; }

    /* Accordion */
    details.acc{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    details.acc + details.acc{ margin-top:10px; }
    details.acc summary{
      list-style:none;
      cursor:pointer;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:1000;
    }
    details.acc summary::-webkit-details-marker{ display:none; }
    .accBody{ padding: 0 14px 14px; }
    .field{ margin-top:10px; }
    .label{ font-size:12px; color:var(--muted); margin-bottom:6px; font-weight:900; }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; line-height: 1.35; }

    /* Dark select fix (best-effort) */
    :root{ color-scheme: dark; }
    select, input[type="number"]{
      width:100%;
      padding:12px 40px 12px 14px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background:#0b0b0b;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      appearance:none;
      -webkit-appearance:none;
      outline:none;
    }
    select option{
      background:#0b0b0b;
      color: rgba(255,255,255,.92);
    }
    .selectWrap{ position:relative; }
    .selectWrap::after{
      content:"‚ñæ";
      position:absolute;
      right:14px; top:50%;
      transform: translateY(-50%);
      opacity:.75;
      pointer-events:none;
      font-weight:1000;
    }

    /* Footer nav */
    nav.footer{
      position:fixed;
      left:0; right:0; bottom:0;
      height: var(--navH);
      padding-bottom: env(safe-area-inset-bottom);
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      z-index: 40;
    }
    .navBtn{
      flex:1;
      min-height:56px;
      border:none;
      border-right: 1px solid rgba(255,255,255,.06);
      background: transparent;
      color: rgba(255,255,255,.86);
      font-weight:1000;
      border-radius: 0;
      padding: 8px 6px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:2px;
    }
    .navBtn:last-child{ border-right:none; }
    .navBtn.active{
      color:#fff;
      background: radial-gradient(320px 120px at 50% 0%, rgba(0,229,255,.20), transparent 60%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .navBtn .ic{ font-size:16px; }
    .navBtn .tx{ font-size:12px; }

    /* Toast */
    #toastWrap{
      position:fixed;
      left:0; right:0;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom) + 12px);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 80;
    }
    .toast{
      max-width:min(560px, calc(100% - 24px));
      background: rgba(0,0,0,.78);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,.65);
      font-weight: 900;
      pointer-events:none;
    }

    /* Modal */
    #modalWrap{
      position:fixed; inset:0;
      background: rgba(0,0,0,.65);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 90;
    }
    #modalWrap.on{ display:flex; }
    .modal{
      width: min(560px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: 0 22px 60px rgba(0,0,0,.70);
      padding: 14px;
    }
    .modal h3{ margin: 4px 0 8px; font-size: 18px; }
    .modal .body{ color: var(--muted); font-weight: 900; line-height: 1.35; }
    .modal .foot{ margin-top: 12px; display:flex; gap:10px; justify-content:flex-end; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    /* Page visibility */
    .page{ display:none; }
    .page.on{ display:block; }

    /* Wrap safety */
    h1,h2,h3,p,div,span{ overflow-wrap:anywhere; word-break:break-word; }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="row sp">
        <div>
          <div class="row" style="gap:10px;">
            <div class="pageTitle">Taco Ria</div>
            <span class="pill"><span class="mono" id="verPill">v0.9.2</span></span>
          </div>
          <div class="muted small" id="subTitle">Rummikub-style recipe drafting ‚Ä¢ Private Prep + Public Line + Remix</div>
        </div>
        <button class="ghost btnTiny" id="btnNewMatchTop">New Match</button>
      </div>
    </header>

    <main>
      <!-- GAMEPLAY -->
      <section class="page on" id="pageGameplay">
        <div class="card heroPhase" style="margin-bottom:12px;">
          <div class="pills" style="margin-top:2px;">
            <span class="pill" id="tilesRemainBadge">Tiles Remaining 0</span>
            <span class="pill" id="kitchenBadge">Kitchen Closed</span>
            <span class="pill" id="handBadge">Hand 1/12</span>
            <span class="pill" id="diffBadge">Difficulty Easy</span>
            <span class="pill" id="modeBadge">Standard</span>
          </div>

          <div style="margin-top:12px;">
            <div style="font-weight:1000; font-size:16px;" id="phaseTitle">Not Seated Yet</div>
            <div class="muted" id="phaseDesc">Serve 10+ points in one turn to open the kitchen. No remixes yet.</div>
          </div>
        </div>

        <div class="actionsTray">
          <div class="card">
            <div class="muted small" style="margin-bottom:10px;" id="turnHint">Your Turn Controls</div>
            <div class="actionsGrid">
              <button class="primary" id="btnDraw">Draw Tile</button>
              <button class="primary" id="btnPublishDraft">Order Up!</button>
              <button class="ghost" id="btnServeSel">Serve Selected</button>
              <button class="danger" id="btnEndTurn">End Turn</button>
            </div>
            <div class="muted small" style="margin-top:10px;" id="actionSubHint">
              Draw 1 tile, then publish/serve from your drafts. Starter Pass allowed once per hand (Chips & Dip).
            </div>
            <div class="row" style="margin-top:10px; justify-content:flex-end; display:none;" id="campaignSkipRow">
              <button class="ghost btnTiny" id="btnSkipCPU">Skip CPU</button>
            </div>
          </div>
        </div>

        <!-- NOW SERVING -->
        <div class="card" id="nowServingWrap" style="margin-top:12px; display:none;">
          <div class="row wrap sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Now Serving</div>
            <div class="pills">
              <span class="pill" id="serveSelPill">Selected 0 ‚Ä¢ 0 pts</span>
              <span class="pill" id="serveNeedPill" style="display:none;">Need 10+ to open</span>
            </div>
          </div>
          <div class="serveStrip" id="nowServingList"></div>
          <div class="muted small" style="margin-top:10px;">
            Tap dishes to select for <b>Serve Selected</b>.
          </div>
        </div>

        <!-- PUBLIC LINE -->
        <div class="card" style="margin-top:12px;">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Public Line / Window</div>
            <span class="pill" id="lineSummary">0 dishes</span>
          </div>
          <div id="publicLine"></div>
        </div>
      </section>

      <!-- PREP -->
      <section class="page" id="pagePrep">
        <div class="card">
          <div class="row sp" style="margin-bottom:8px;">
            <div style="font-weight:1000;">Prep</div>
            <span class="badge">Private Drafting</span>
          </div>

          <details class="acc" open>
            <summary>
              <span>Your Hand</span>
              <span class="muted2 small" id="handCountHint">0 tiles</span>
            </summary>
            <div class="accBody">
              <div class="tiles" id="handTiles"></div>

              <div class="row wrap" style="margin-top:12px; justify-content:space-between;">
                <div class="row wrap" style="gap:10px;">
                  <button class="ghost btnTiny" id="btnNewDish">+ New Dish</button>
                  <button class="ghost btnTiny" id="btnClearDish">Clear Dish</button>
                </div>
                <div class="row wrap" style="gap:10px;">
                  <button class="primary btnTiny" id="btnAutoPlate" style="display:none;">Auto-Plate</button>
                  <button class="primary btnTiny" id="btnAutoRemix" style="display:none;">Auto-Remix</button>
                </div>
              </div>

              <div class="hint" id="autoHint" style="margin-top:10px;">
                Tap hand tiles to add/remove from your current dish.
              </div>
            </div>
          </details>

          <details class="acc" open>
            <summary>
              <span>Current Dish</span>
              <span class="muted2 small" id="dishMeta">‚Äî</span>
            </summary>
            <div class="accBody">
              <div class="field">
                <div class="label">Recipe</div>
                <div class="selectWrap">
                  <select id="selRecipe"></select>
                </div>
              </div>

              <div class="field">
                <div class="label">Dish Tiles</div>
                <div class="tiles" id="dishTiles"></div>
              </div>

              <div class="row wrap" style="margin-top:12px; justify-content:flex-end;">
                <button class="ghost btnTiny" id="btnRemoveDish">Remove Dish</button>
              </div>

              <div class="hint" id="dishHint"></div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Public Tiles (for Remix)</span>
              <span class="muted2 small">Grouped</span>
            </summary>
            <div class="accBody">
              <div id="publicTiles"></div>
              <div class="hint">
                Once Kitchen is open, you may select public tiles to remix into a new dish (no loose ingredients).
              </div>
            </div>
          </details>
        </div>
      </section>

      <!-- SCORES -->
      <section class="page" id="pageScores">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Scores</div>
            <span class="badge" id="scoreModePill">Standard</span>
          </div>

          <div class="row wrap" style="gap:10px; margin-bottom:12px;">
            <span class="pill" id="scoreCurrent">Current: 0</span>
            <span class="pill" id="scorePending">Pending: 0</span>
            <span class="pill" id="scoreServed">Served this hand: 0</span>
          </div>

          <div id="scoreList"></div>

          <details class="acc" id="campaignBoxAcc" style="margin-top:12px; display:none;">
            <summary>
              <span>Box Score</span>
              <span class="muted2 small">Chapters + Total</span>
            </summary>
            <div class="accBody" id="campaignBoxBody"></div>
          </details>

          <div class="hint" style="margin-top:10px;">
            End-of-hand penalty is <b>-1</b> per tile remaining in your hand.
          </div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="page" id="pageSettings">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Settings</div>
            <span class="badge">v<span class="mono">0.9.2</span></span>
          </div>
          <div class="muted small">Primary theme stays black. Choose a high-contrast accent.</div>

          <details class="acc" open style="margin-top:12px;">
            <summary>
              <span>Match</span>
              <span class="muted2 small">Mode + Players</span>
            </summary>
            <div class="accBody">
              <div class="row wrap" style="gap:12px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Mode</div>
                  <div class="selectWrap">
                    <select id="selMode">
                      <option value="standard">Standard Match</option>
                      <option value="campaign">Campaign</option>
                    </select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Players</div>
                  <div class="selectWrap">
                    <select id="selPlayers">
                      <option value="2">2 Players</option>
                      <option value="3">3 Players</option>
                      <option value="4" selected>4 Players</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">CPU Difficulty (Standard only)</div>
                  <div class="selectWrap">
                    <select id="selDifficulty"></select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Hands (Standard only)</div>
                  <input type="number" id="inpHands" min="1" max="12" value="12" />
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Tiles per Player</div>
                  <input type="number" id="inpTilesPerPlayer" min="8" max="24" value="16" />
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Decks</div>
                  <div class="selectWrap">
                    <select id="selDecks">
                      <option value="1">1 Deck</option>
                      <option value="2" selected>2 Decks (Recommended)</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="hint">
                Campaign auto-walks difficulty: Beginner ‚Üí Easy ‚Üí Medium ‚Üí Difficult ‚Üí Master Chef.
                Skip button appears during CPU turns in Campaign only. Kitchen stays open after first unlock.
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Theme</span>
              <span class="muted2 small">Accent Color</span>
            </summary>
            <div class="accBody">
              <div class="label">Accent</div>
              <div class="selectWrap">
                <select id="selAccent"></select>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Language</span>
              <span class="muted2 small">English / Espa√±ol</span>
            </summary>
            <div class="accBody">
              <div class="label">App Language</div>
              <div class="selectWrap">
                <select id="selLang">
                  <option value="en">English</option>
                  <option value="es">Espa√±ol</option>
                </select>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Menu Reference</span>
              <span class="muted2 small">What ‚Äúvalid‚Äù looks like</span>
            </summary>
            <div class="accBody" id="menuRef"></div>
          </details>

          <div class="hint" style="margin-top:12px;">
            Starter Pass: before you unlock, you may serve one Chips & Dip per hand without unlocking remix.
            <br/>First laydown: tacos must use dry toppings (no salsa/queso/guac).
          </div>
        </div>
      </section>
    </main>
  </div>

  <nav class="footer">
    <button class="navBtn active" id="navGame"><div class="ic">üé≠</div><div class="tx">Gameplay</div></button>
    <button class="navBtn" id="navPrep"><div class="ic">üç≥</div><div class="tx">Prep</div></button>
    <button class="navBtn" id="navScores"><div class="ic">üèÜ</div><div class="tx">Scores</div></button>
    <button class="navBtn" id="navSettings"><div class="ic">‚öôÔ∏è</div><div class="tx">Settings</div></button>
  </nav>

  <div id="toastWrap"></div>

  <div id="modalWrap">
    <div class="modal">
      <h3 id="modalTitle">Modal</h3>
      <div class="body" id="modalBody"></div>
      <div class="foot" id="modalFoot"></div>
    </div>
  </div>

  <script>
    /* =========================
       Taco Ria v0.9.2 (Atomic)
       ========================= */

    const VERSION = "v0.9.2";
    const LS_KEY = "taco_ria_state_v092";

    const DIFFS = ["Beginner","Easy","Medium","Difficult","Master Chef"];
    const DIFF_DELAY_MS = { "Beginner":5000, "Easy":3500, "Medium":2200, "Difficult":1200, "Master Chef":500 };

    const CPU_CHARACTERS = {
      chefMike:  { name:"Chef Mike",  speedFixedMs:650,  jitterMs:120, sloppyRate:0.28, appetizerBias:0.10, remixBias:0.90, color:"#ff3b30" },
      salsaSam:  { name:"Salsa Sam",  speedMult:1.00,   jitterMs:220, sloppyRate:0.10, appetizerBias:0.20, remixBias:1.00, color:"#b36bff" },
      quesoQueen:{ name:"Queso Queen",speedMult:1.12,   jitterMs:260, sloppyRate:0.08, appetizerBias:0.78, remixBias:0.95, color:"#ffcc00" },
      grillGuru: { name:"Grill Guru", speedMult:0.85,   jitterMs:160, sloppyRate:0.04, appetizerBias:0.15, remixBias:1.35, color:"#a3ff12" }
    };

    const ACCENTS = [
      { name:"Neon Cyan", val:"#00e5ff" },
      { name:"Signal Yellow", val:"#ffcc00" },
      { name:"Lime", val:"#a3ff12" },
      { name:"Hot Pink", val:"#ff2bd6" },
      { name:"Orange", val:"#ff8a00" },
      { name:"Ice", val:"#b3f6ff" },
      { name:"Violet", val:"#b36bff" },
      { name:"Red", val:"#ff3b30" }
    ];

    const I18N = {
      en: {
        gameplay:"Gameplay", prep:"Prep", scores:"Scores", settings:"Settings",
        orderUp:"Order Up!", drawTile:"Draw Tile", serveSelected:"Serve Selected", endTurn:"End Turn",
        yourTurn:"Your Turn Controls", notYourTurn:"Not your turn.",
        kitchenOpen:"Kitchen Open", kitchenClosed:"Kitchen Closed",
        tilesRemaining:"Tiles Remaining",
      },
      es: {
        gameplay:"Juego", prep:"Preparaci√≥n", scores:"Puntos", settings:"Ajustes",
        orderUp:"¬°Orden lista!", drawTile:"Robar ficha", serveSelected:"Servir seleccionadas", endTurn:"Terminar turno",
        yourTurn:"Controles de turno", notYourTurn:"No es tu turno.",
        kitchenOpen:"Cocina abierta", kitchenClosed:"Cocina cerrada",
        tilesRemaining:"Fichas restantes",
      }
    };

    /* ===== Menu / Recipes ===== */
    const RULES = {
      remixMinPoints: 5,
      tacoToppingCount: 3,   // tortilla + protein + 3 toppings
      wetLockedUntilKitchen: true,
      starterPassDishKey: "chipsDip", // 1 per hand, doesn't unlock kitchen
    };

    const RECIPES = [
      { key:"hardTaco", name:"Hard Shell Taco", pts:5, kind:"taco", tortilla:"Corn Tortillas" },
      { key:"softTaco", name:"Soft Taco", pts:5, kind:"taco", tortilla:"Flour Tortillas" },
      { key:"chorizoTaco", name:"Chorizo Taco", pts:8, kind:"chorizoTaco" },
      { key:"chipsDip", name:"Chips & Dip", pts:5, kind:"chipsDip" },
      { key:"pico", name:"Pico de Gallo", pts:8, kind:"pico" },
      { key:"ench", name:"Enchiladas", pts:10, kind:"ench" },
    ];

    const MENU_REFERENCE = [
      { title:"Hard Shell Taco", pts:5, desc:"Corn Tortilla + Protein + 3 Toppings. Wet toppings lock until Kitchen Open." },
      { title:"Soft Taco", pts:5, desc:"Flour Tortilla + Protein + 3 Toppings. Wet toppings lock until Kitchen Open." },
      { title:"Chorizo Taco", pts:8, desc:"Tortilla + Chorizo + Onion + Cilantro" },
      { title:"Chips & Dip", pts:5, desc:"Tortilla Chips + 1 Dip (Salsa Roja, Salsa Verde, Guacamole, or Queso)" },
      { title:"Pico de Gallo", pts:8, desc:"Tomato + Onion + Cilantro + Lime" },
      { title:"Enchiladas", pts:10, desc:"Tortilla + Protein + Cheese + Sauce (Chorizo allowed if Sauce included)" },
    ];

    /* ===== Deck definition (single deck counts from user list) ===== */
    const DECK_ING_COUNTS = [
      ["Fish",1],
      ["Ground Beef",2],
      ["Shredded Chicken",2],
      ["Carne Guisada",1],
      ["Al Pastor",1],
      ["Carnitas",1],
      ["Egg",2],
      ["Chicken Fajita",2],
      ["Chorizo",1],
      ["Tortilla Chips",3],
      ["Flour Tortillas",2],
      ["Corn Tortillas",2],
      ["Shredded yellow Cheese",2],
      ["Shredded white cheese",2],
      ["Rice",2],
      ["Charro Beans",1],
      ["Refried Beans",1],
      ["Black Beans",1],
      ["Cilantro",2],
      ["Jalapenos",2],
      ["Lettuce",1],
      ["Lime Juice",2],
      ["Onion",2],
      ["Tomato",2],
      ["Sour Cream",2],
      ["Avocado",2],
      ["Salsa Roja",2],
      ["Salsa Verde",2],
      ["Queso",2],
      ["Guacamole",2],
      ["Grocery Run",2], // wildcard
    ];

    /* ===== Utilities ===== */
    const $ = (id)=> document.getElementById(id);

    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;").replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }
    function randInt(n){ return Math.floor(Math.random()*n); }
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }
    function nowId(prefix="id"){
      return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }

    function hexToRgba(hex, a){
      const h = (hex || "#ffffff").replace("#","").trim();
      const full = h.length===3 ? h.split("").map(c=>c+c).join("") : h.padEnd(6,"0").slice(0,6);
      const n = parseInt(full,16);
      const r=(n>>16)&255, g=(n>>8)&255, b=n&255;
      return `rgba(${r},${g},${b},${a})`;
    }

    function groupBy(arr, keyFn){
      const m = {};
      for(const it of arr){
        const k = keyFn(it);
        (m[k] ||= []).push(it);
      }
      return m;
    }

    function toast(msg, ms=2200){
      const wrap = $("toastWrap");
      wrap.innerHTML = `<div class="toast">${escapeHtml(msg)}</div>`;
      clearTimeout(toast._t);
      toast._t = setTimeout(()=> wrap.innerHTML="", ms);
    }

    // Simple sequential toast helper (keeps CPU "dish toast" from getting instantly overwritten)
    function toastSeq(seq){
      if(!seq || !seq.length) return;
      let i = 0;
      const run = ()=>{
        if(i >= seq.length) return;
        const [msg, ms] = seq[i++];
        toast(msg, ms);
        setTimeout(run, (ms || 0) + 80);
      };
      run();
    }

    function openModal(title, html, footButtons){
      $("modalTitle").textContent = title;
      $("modalBody").innerHTML = html;
      $("modalFoot").innerHTML = "";
      for(const b of footButtons){
        const btn = document.createElement("button");
        btn.className = b.className || "ghost";
        btn.textContent = b.text;
        btn.onclick = ()=> b.onClick?.();
        $("modalFoot").appendChild(btn);
      }
      $("modalWrap").classList.add("on");
    }
    function closeModal(){
      $("modalWrap").classList.remove("on");
    }
    $("modalWrap").addEventListener("click",(e)=>{
      if(e.target.id==="modalWrap") closeModal();
    });

    /* ===== Ingredient classification ===== */
    function isWild(name){ return name==="Grocery Run"; }

    function isTortilla(name){
      return name==="Corn Tortillas" || name==="Flour Tortillas";
    }
    function isProtein(name){
      return ["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"].includes(name);
    }
    function isCheese(name){
      return name==="Shredded yellow Cheese" || name==="Shredded white cheese";
    }
    function isSauce(name){
      return name==="Salsa Roja" || name==="Salsa Verde";
    }
    function isWet(name){
      return ["Salsa Roja","Salsa Verde","Queso","Guacamole"].includes(name);
    }
    function isDip(name){
      return ["Salsa Roja","Salsa Verde","Guacamole","Queso"].includes(name);
    }
    function isTopping(name){
      return isWet(name) || [
        "Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream",
        "Shredded yellow Cheese","Shredded white cheese","Avocado"
      ].includes(name);
    }

    function recipeByKey(k){ return RECIPES.find(r=>r.key===k); }

    /* ===== State ===== */
    function defaultState(){
      return {
        settings:{
          accent:"#00e5ff",
          lang:"en",
          mode:"standard",          // standard | campaign
          players:4,
          difficulty:"Easy",        // standard only
          handsTotal:12,
          tilesPerPlayer:16,
          decks:2,
        },
        campaign:{
          active:false,
          chapterIndex:0,
          chapterHands:12,
          chapterScores:[], // {diff, p1, cpus}
          kitchenUnlockedEver:false,
        },
        match: null,
        ui:{
          page:"gameplay",
          serveSel: [],
          handSel: new Set(),
          currentDishId: null,
          remixSelPublic: new Set(),
          pendingAutoRemix: null,
        }
      };
    }

    function persist(){
      const s = structuredClone(state);
      s.ui.handSel = [...state.ui.handSel];
      s.ui.remixSelPublic = [...state.ui.remixSelPublic];
      localStorage.setItem(LS_KEY, JSON.stringify(s));
    }

    function load(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return null;
        const s = JSON.parse(raw);
        s.ui.handSel = new Set(s.ui.handSel || []);
        s.ui.remixSelPublic = new Set(s.ui.remixSelPublic || []);
        return s;
      }catch(e){
        return null;
      }
    }

    let state = load() || defaultState();

    /* ===== Match / Hand ===== */
    function buildDeck(decks=2){
      const tiles = [];
      for(let d=0; d<decks; d++){
        for(const [name,count] of DECK_ING_COUNTS){
          for(let i=0;i<count;i++){
            tiles.push({ id: nowId("t"), name });
          }
        }
      }
      return shuffle(tiles);
    }

    function cpuRoster(n){
      const chars = Object.values(CPU_CHARACTERS);
      const ids = ["P2","P3","P4"];
      return ids.slice(0, n-1).map((pid, i)=>({
        id: pid,
        charKey: Object.keys(CPU_CHARACTERS)[i % Object.keys(CPU_CHARACTERS).length],
        name: chars[i % chars.length].name
      }));
    }

    function newMatch(){
      const m = {
        id: nowId("m"),
        handIndex: 1,
        kitchenOpen: false,
        bag: buildDeck(state.settings.decks),
        discard: [],
        publicLine: [],
        players: {},
        activePid: "P1",
        servedThisTurnPts: 0,
      };

      const roster = cpuRoster(state.settings.players);
      m.players["P1"] = mkPlayer("P1","You", true);
      roster.forEach(r=>{
        m.players[r.id] = mkPlayer(r.id, r.name, false, r.charKey);
      });

      dealInitial(m);
      initDraftingForP1(m);

      if(state.settings.mode==="campaign"){
        state.campaign.active = true;
        state.campaign.chapterHands = 12;
        state.campaign.chapterIndex = state.campaign.chapterIndex || 0;
        state.campaign.chapterScores = state.campaign.chapterScores || [];
      }else{
        state.campaign.active = false;
        state.campaign.chapterIndex = 0;
        state.campaign.chapterScores = [];
        state.campaign.kitchenUnlockedEver = false;
      }

      state.match = m;
      state.ui.page = "gameplay";
      state.ui.serveSel = [];
      state.ui.handSel = new Set();
      state.ui.remixSelPublic = new Set();
      persist();
      render();
      toast("New match started.");
    }

    function mkPlayer(id, name, isHuman, charKey=null){
      return {
        id, name, isHuman,
        charKey,
        score: 0,
        servedThisHand: 0,
        pending: 0,
        hand: [],
        drafts: [],
        starterPassUsed: false,
        didDraw: false,
        didPublish: false,
        didRemix: false,
      };
    }

    function dealInitial(m){
      const tilesPer = state.settings.tilesPerPlayer;
      for(const pid of Object.keys(m.players)){
        m.players[pid].hand = [];
        m.players[pid].didDraw = false;
        for(let i=0;i<tilesPer;i++){
          const t = m.bag.pop();
          if(!t) break;
          m.players[pid].hand.push(t);
        }
      }
    }

    function initDraftingForP1(m){
      const p1 = m.players["P1"];
      p1.drafts = [];
      const d = newDraftDish("hardTaco");
      p1.drafts.push(d);
      state.ui.currentDishId = d.id;
    }

    function newDraftDish(recipeKey){
      const r = recipeByKey(recipeKey);
      return {
        id: nowId("d"),
        recipeKey,
        name: r?.name || recipeKey,
        pts: r?.pts || 0,
        tileIds: [],
      };
    }

    /* ===== Difficulty resolution ===== */
    function effectiveDifficulty(){
      if(state.settings.mode==="campaign"){
        const order = ["Beginner","Easy","Medium","Difficult","Master Chef"];
        const idx = state.campaign.chapterIndex || 0;
        return order[Math.min(order.length-1, idx)];
      }
      return state.settings.difficulty || "Easy";
    }

    function cpuTurnDelayMs(pid){
      const diff = effectiveDifficulty();
      const base = DIFF_DELAY_MS[diff] ?? 2200;
      const p = state.match.players[pid];
      const ch = CPU_CHARACTERS[p.charKey] || CPU_CHARACTERS.salsaSam;

      if(ch.speedFixedMs != null){
        return Math.max(350, Math.min(base, ch.speedFixedMs)) + randInt(ch.jitterMs||0);
      }
      const mult = ch.speedMult ?? 1;
      const jit = ch.jitterMs || 0;
      return Math.max(350, Math.floor(base * mult) + randInt(jit));
    }

    function cpuCanRemix(){
      const diff = effectiveDifficulty();
      if(diff==="Beginner" || diff==="Easy" || diff==="Medium") return false;
      return true;
    }

    function autoPlateAllowed(){
      const diff = effectiveDifficulty();
      return diff==="Beginner" || diff==="Easy";
    }

    function autoRemixAllowed(){
      return effectiveDifficulty()==="Beginner";
    }

    /* ===== Draw rule (ONE per turn, MUST draw before ending/serving if bag has tiles) ===== */
    function drawOneTileFor(pid, opts={}){
      const m = state.match;
      const pl = m.players[pid];
      if(!pl) return null;

      if(pl.didDraw){
        if(pid==="P1") toast("You already drew 1 tile this turn.");
        return null;
      }
      if(m.bag.length === 0){
        if(pid==="P1") toast("No tiles left.");
        return null;
      }

      const t0 = m.bag.pop();
      if(!t0) return null;

      pl.hand.push(t0);
      pl.didDraw = true;

      if(opts.announce){
        const who = (pid==="P1") ? "Drew" : `${pl.name} drew`;
        toast(`${who}: ${t0.name}`);
      }
      return t0;
    }

    function mustDrawBeforePlay(){
      const m = state.match;
      if(!m) return false;
      if(m.activePid !== "P1") return false;
      const pl = m.players["P1"];
      return (m.bag.length > 0) && !pl.didDraw;
    }

    /* ===== Validation ===== */
    function validateDish(recipeKey, tileObjs, ctx){
      const r = recipeByKey(recipeKey);
      const names = tileObjs.map(t=>t.name);

      const wildCount = names.filter(isWild).length;
      const nonWild = names.filter(n=>!isWild(n));

      function count(fn){ return nonWild.filter(fn).length; }
      function need(n){ return n>0 ? n : 0; }

      if(r.kind==="taco"){
        const tortillaOk = (count(isTortilla) >= 1) || (wildCount >= 1);
        const hasReqTortilla = nonWild.includes(r.tortilla) || (wildCount>0 && count(isTortilla)===0);
        const proteinOk = (count(isProtein) >= 1) || (wildCount >= 1);
        const toppingsCnt = count(isTopping);

        if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          if(nonWild.some(isWet)) return { ok:false, reason:"Wet toppings are locked until Kitchen Open." };
        }

        if(!tortillaOk) return { ok:false, reason:"Tacos need 1 tortilla." };
        if(!hasReqTortilla) return { ok:false, reason:`Use ${r.tortilla} for this taco.` };
        if(!proteinOk) return { ok:false, reason:"Tacos need 1 protein." };

        const missingToppings = need(RULES.tacoToppingCount - toppingsCnt);
        if(missingToppings > wildCount) return { ok:false, reason:`Tacos need exactly ${RULES.tacoToppingCount} toppings.` };

        if(tileObjs.length !== 5) return { ok:false, reason:"Tacos must have 5 tiles (tortilla + protein + 3 toppings)." };

        return { ok:true };
      }

      if(r.kind==="chorizoTaco"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Chorizo Taco needs 4 tiles." };
        const hasTort = count(isTortilla) >= 1 || wildCount>=1;
        const hasChor = nonWild.includes("Chorizo") || wildCount>=1;
        const hasOnion = nonWild.includes("Onion") || wildCount>=1;
        const hasCil = nonWild.includes("Cilantro") || wildCount>=1;
        if(!hasTort) return { ok:false, reason:"Needs a tortilla." };
        if(!hasChor) return { ok:false, reason:"Needs chorizo." };
        if(!hasOnion) return { ok:false, reason:"Needs onion." };
        if(!hasCil) return { ok:false, reason:"Needs cilantro." };
        return { ok:true };
      }

      if(r.kind==="chipsDip"){
        if(tileObjs.length !== 2) return { ok:false, reason:"Chips & Dip needs 2 tiles." };
        const hasChips = nonWild.includes("Tortilla Chips") || wildCount>=1;
        const hasDip = count(isDip) >= 1 || wildCount>=1;
        if(!hasChips) return { ok:false, reason:"Needs Tortilla Chips." };
        if(!hasDip) return { ok:false, reason:"Needs 1 dip (salsa/queso/guac)." };
        return { ok:true };
      }

      if(r.kind==="pico"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Pico needs 4 tiles." };
        const okTom = nonWild.includes("Tomato") || wildCount>=1;
        const okOn  = nonWild.includes("Onion") || wildCount>=1;
        const okCil = nonWild.includes("Cilantro") || wildCount>=1;
        const okLim = nonWild.includes("Lime Juice") || wildCount>=1;
        if(!okTom || !okOn || !okCil || !okLim) return { ok:false, reason:"Needs Tomato, Onion, Cilantro, Lime." };
        return { ok:true };
      }

      if(r.kind==="ench"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Enchiladas need 4 tiles." };
        const hasTort = count(isTortilla) >= 1 || wildCount>=1;
        const hasProt = count(isProtein) >= 1 || wildCount>=1;
        const hasChee = count(isCheese) >= 1 || wildCount>=1;
        const hasSau  = count(isSauce) >= 1 || wildCount>=1;
        if(!hasTort) return { ok:false, reason:"Needs tortillas." };
        if(!hasProt) return { ok:false, reason:"Needs protein." };
        if(!hasChee) return { ok:false, reason:"Needs shredded cheese." };
        if(!hasSau)  return { ok:false, reason:"Needs sauce." };
        return { ok:true };
      }

      return { ok:false, reason:"Unknown recipe." };
    }

    /* ===== Publishing / Scoring ===== */
    function publishSelectedDrafts(pid, draftIds){
      const m = state.match;
      const pl = m.players[pid];
      if(!pl) return { ok:false, msg:"No player." };

      const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };

      const drafts = pl.drafts.filter(d=> draftIds.includes(d.id));
      if(!drafts.length) return { ok:false, msg:"No drafts selected." };

      const resolved = drafts.map(d=>{
        const tiles = d.tileIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
        return { d, tiles, v: validateDish(d.recipeKey, tiles, ctx) };
      });

      const invalid = resolved.find(x=>!x.v.ok);
      if(invalid){
        return { ok:false, msg:`${invalid.d.name}: ${invalid.v.reason}` };
      }

      let starterPassPts = 0;
      let nonStarterPts = 0;

      for(const x of resolved){
        if(!m.kitchenOpen){
          if(x.d.recipeKey === RULES.starterPassDishKey && !pl.starterPassUsed){
            starterPassPts += x.d.pts;
          }else{
            nonStarterPts += x.d.pts;
          }
        }else{
          nonStarterPts += x.d.pts;
        }
      }

      for(const x of resolved){
        const pub = {
          id: nowId("pub"),
          owner: pid,
          ownerName: pl.name,
          recipeKey: x.d.recipeKey,
          name: x.d.name,
          points: x.d.pts,
          tiles: x.tiles.map(t=>({id:t.id, name:t.name})),
          isRemix: false,
          from: null
        };
        m.publicLine.push(pub);

        for(const t of x.tiles){
          const idx = pl.hand.findIndex(h=>h.id===t.id);
          if(idx>=0) pl.hand.splice(idx,1);
        }

        pl.score += x.d.pts;
        pl.servedThisHand += x.d.pts;
        pl.didPublish = true;
      }

      if(!m.kitchenOpen){
        const used = resolved.some(x=> x.d.recipeKey===RULES.starterPassDishKey);
        if(used && !pl.starterPassUsed){
          pl.starterPassUsed = true;
        }
      }

      m.servedThisTurnPts += nonStarterPts;
      if(!m.kitchenOpen){
        if(m.servedThisTurnPts >= 10){
          m.kitchenOpen = true;
          if(state.campaign.active) state.campaign.kitchenUnlockedEver = true;
          toast("üî• Kitchen Open!");
        }
      }

      pl.drafts = pl.drafts.filter(d=> !draftIds.includes(d.id));
      if(pid==="P1" && pl.drafts.length===0){
        const nd = newDraftDish("hardTaco");
        pl.drafts.push(nd);
        state.ui.currentDishId = nd.id;
      }else if(pid==="P1"){
        if(!pl.drafts.some(d=>d.id===state.ui.currentDishId)){
          state.ui.currentDishId = pl.drafts[0]?.id || null;
        }
      }

      return { ok:true };
    }

    function endHandIfNeeded(){
      const m = state.match;
      const someoneOut = Object.values(m.players).some(p=>p.hand.length===0);
      if(!someoneOut) return false;

      for(const p of Object.values(m.players)){
        const pen = p.hand.length;
        p.score -= pen;
        if(p.id==="P1") toast(`Hand over. Penalty: -${pen}`);
      }

      if(state.settings.mode==="campaign"){
        state.campaign.chapterHands = 12;
        state.campaign._handsInChapter = (state.campaign._handsInChapter || 1);
        if(state.campaign._handsInChapter >= 12){
          state.campaign.chapterScores.push({
            diff: effectiveDifficulty(),
            total: state.match.players["P1"].score
          });
          state.campaign.chapterIndex = Math.min(4, (state.campaign.chapterIndex||0) + 1);
          state.campaign._handsInChapter = 1;
        }else{
          state.campaign._handsInChapter += 1;
        }
      }

      startNextHand();
      return true;
    }

    function startNextHand(){
      const m = state.match;

      m.handIndex += 1;
      m.servedThisTurnPts = 0;
      m.activePid = "P1";
      for(const p of Object.values(m.players)){
        p.servedThisHand = 0;
        p.starterPassUsed = false;
        p.didDraw = false;
        p.didPublish = false;
        p.didRemix = false;
        p.drafts = [];
      }

      if(state.settings.mode==="standard"){
        m.kitchenOpen = false;
      }else{
        m.kitchenOpen = !!state.campaign.kitchenUnlockedEver;
      }

      if(m.bag.length < 10){
        m.bag = buildDeck(state.settings.decks);
      }

      dealInitial(m);
      initDraftingForP1(m);
      state.ui.serveSel = [];
      state.ui.handSel = new Set();
      state.ui.remixSelPublic = new Set();
      persist();
      render();
    }

    /* ===== Drafting (P1) ===== */
    function p1(){ return state.match.players["P1"]; }
    function currentDish(){
      const pl = p1();
      return pl.drafts.find(d=>d.id===state.ui.currentDishId) || pl.drafts[0] || null;
    }
    function setCurrentDish(id){
      state.ui.currentDishId = id;
      state.ui.handSel = new Set();
      persist();
      render();
    }

    function toggleHandTileForDish(tileId){
      const m = state.match;
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      const pl = p1();
      const dish = currentDish();
      if(!dish) return;

      const tile = pl.hand.find(t=>t.id===tileId);
      if(!tile) return;

      const inDish = dish.tileIds.includes(tileId);
      if(inDish){
        dish.tileIds = dish.tileIds.filter(id=>id!==tileId);
        persist(); render();
        return;
      }

      const r = recipeByKey(dish.recipeKey);
      const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };
      if(r.kind==="taco"){
        const curNames = dish.tileIds.map(id => pl.hand.find(t=>t.id===id)?.name).filter(Boolean);
        const curTop = curNames.filter(isTopping).length;

        if(isWet(tile.name) && RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          toast("Wet toppings are locked until Kitchen Open.");
          return;
        }
        if(isTopping(tile.name) && curTop >= RULES.tacoToppingCount){
          toast(`Tacos can have only ${RULES.tacoToppingCount} toppings.`);
          return;
        }
        if(dish.tileIds.length >= 5){
          toast("Tacos must have 5 tiles total.");
          return;
        }
      }

      if(r.kind==="chipsDip" && dish.tileIds.length >= 2){ toast("Chips & Dip is 2 tiles."); return; }
      if(r.kind==="pico" && dish.tileIds.length >= 4){ toast("Pico is 4 tiles."); return; }
      if(r.kind==="ench" && dish.tileIds.length >= 4){ toast("Enchiladas are 4 tiles."); return; }
      if(r.kind==="chorizoTaco" && dish.tileIds.length >= 4){ toast("Chorizo Taco is 4 tiles."); return; }

      dish.tileIds.push(tileId);
      persist(); render();
    }

    function clearCurrentDish(){
      const d = currentDish();
      if(!d) return;
      d.tileIds = [];
      persist(); render();
    }

    function newDish(){
      const pl = p1();
      const d = newDraftDish("hardTaco");
      pl.drafts.push(d);
      setCurrentDish(d.id);
      toast("New dish added.");
    }

    function removeCurrentDish(){
      const pl = p1();
      if(pl.drafts.length <= 1){
        clearCurrentDish();
        toast("Cleared.");
        return;
      }
      const id = state.ui.currentDishId;
      pl.drafts = pl.drafts.filter(d=>d.id!==id);
      setCurrentDish(pl.drafts[0].id);
      toast("Dish removed.");
    }

    function updateCurrentDishRecipe(recipeKey){
      const d = currentDish();
      if(!d) return;
      d.recipeKey = recipeKey;
      const r = recipeByKey(recipeKey);
      d.name = r?.name || recipeKey;
      d.pts = r?.pts || 0;
      d.tileIds = [];
      state.ui.serveSel = [];
      persist(); render();
    }

    /* ===== Auto-Plate (Beginner/Easy only) ===== */
    function autoPlate(){
      if(!autoPlateAllowed()) return;
      const m = state.match;
      if(m.activePid!=="P1"){ toast(t("notYourTurn")); return; }
      const pl = p1();
      const d = currentDish();
      if(!d) return;

      const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };
      const best = findBestDishFromHand(pl.hand, d.recipeKey, ctx);
      if(!best){ toast("No auto-plate found."); return; }

      d.tileIds = best.tileIds;
      persist(); render();
      toast("‚úÖ Auto-plate complete.");
    }

    /* ===== Beginner Auto-Remix (preview) ===== */
    function autoRemixPreview(){
      if(!autoRemixAllowed()) return;
      const m = state.match;
      if(m.activePid!=="P1"){ toast(t("notYourTurn")); return; }
      if(!m.kitchenOpen && !(state.campaign.active && state.campaign.kitchenUnlockedEver)){
        toast("Kitchen must be open to remix.");
        return;
      }

      const cand = m.publicLine
        .filter(d=>d.points >= RULES.remixMinPoints)
        .sort((a,b)=> b.points - a.points);

      const target = cand.find(x=>x.owner!=="P1") || cand[0];
      if(!target){ toast("No remix targets (5+ pts)."); return; }

      state.ui.pendingAutoRemix = target.id;

      openModal(
        "Auto Remix Preview",
        `<div class="muted">
          <div><b>Target:</b> ${escapeHtml(target.name)} (${target.points} pts)</div>
          <div><b>From:</b> ${escapeHtml(target.ownerName)}</div>
          <div style="margin-top:10px"><b>Tiles:</b> ${target.tiles.map(t=>escapeHtml(t.name)).join(", ")}</div>
          <div class="muted2" style="margin-top:8px">Submit to steal and re-plate this dish as your remix, or cancel.</div>
        </div>`,
        [
          { text:"Cancel", className:"ghost", onClick: ()=>{ state.ui.pendingAutoRemix=null; closeModal(); } },
          { text:"Submit Remix", className:"primary", onClick: commitAutoRemix }
        ]
      );
    }

    function commitAutoRemix(){
      const m = state.match;
      const pid = "P1";
      const pl = m.players[pid];
      const id = state.ui.pendingAutoRemix;
      if(!id){ closeModal(); return; }

      const idx = m.publicLine.findIndex(d=>d.id===id);
      if(idx<0){ toast("Target gone."); state.ui.pendingAutoRemix=null; closeModal(); return; }

      const target = m.publicLine[idx];
      m.publicLine.splice(idx,1);

      const pub = {
        id: nowId("pub"),
        owner: pid,
        ownerName: pl.name,
        recipeKey: target.recipeKey,
        name: target.name,
        points: target.points,
        tiles: target.tiles.map(t=>({id: nowId("rt"), name:t.name})),
        isRemix: true,
        from: target.owner
      };
      m.publicLine.push(pub);

      pl.score += pub.points;
      pl.servedThisHand += pub.points;
      pl.didRemix = true;

      state.ui.pendingAutoRemix = null;
      closeModal();
      persist(); render();
      toastSeq([["üîÄ Remix plated.", 1400], ["‚úÖ", 900]]);
    }

    /* ===== Find dish combinations ===== */
    function findBestDishFromHand(hand, recipeKey, ctx){
      const r = recipeByKey(recipeKey);
      const byName = {};
      for(const t of hand){
        (byName[t.name] ||= []).push(t.id);
      }

      function pick(name){
        const arr = byName[name];
        if(arr && arr.length) return arr[0];
        return null;
      }

      function anyFrom(names){
        for(const n of names){
          const id = pick(n);
          if(id) return id;
        }
        return pick("Grocery Run");
      }

      if(r.kind==="taco"){
        const ids = [];
        let tort = pick(r.tortilla) || pick("Grocery Run");
        if(!tort) return null;
        ids.push(tort);

        let prot = anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]);
        if(!prot) return null;
        ids.push(prot);

        const TOPS_DRY = ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Shredded yellow Cheese","Shredded white cheese","Avocado"];
        const TOPS_WET = ["Salsa Roja","Salsa Verde","Queso","Guacamole"];
        const pool = (RULES.wetLockedUntilKitchen && !ctx.kitchenOpen) ? TOPS_DRY : TOPS_DRY.concat(TOPS_WET);

        const used = new Set(ids);
        for(let i=0;i<3;i++){
          let found = null;
          for(const n of pool){
            const arr = byName[n] || [];
            const id = arr.find(x=>!used.has(x));
            if(id){ found = id; break; }
          }
          if(!found){
            const w = (byName["Grocery Run"]||[]).find(x=>!used.has(x));
            if(!w) return null;
            found = w;
          }
          used.add(found);
          ids.push(found);
        }

        if(ids.length!==5) return null;
        const tiles = ids.map(id=> hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      if(r.kind==="chipsDip"){
        const chips = pick("Tortilla Chips") || pick("Grocery Run");
        if(!chips) return null;
        const dip = anyFrom(["Salsa Roja","Salsa Verde","Guacamole","Queso"]);
        if(!dip) return null;
        const ids = [chips,dip];
        const tiles = ids.map(id=> hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      if(r.kind==="pico"){
        const ids = [
          pick("Tomato") || pick("Grocery Run"),
          pick("Onion") || pick("Grocery Run"),
          pick("Cilantro") || pick("Grocery Run"),
          pick("Lime Juice") || pick("Grocery Run"),
        ].filter(Boolean);
        if(ids.length!==4) return null;
        const tiles = ids.map(id=> hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      if(r.kind==="ench"){
        const ids = [
          anyFrom(["Flour Tortillas","Corn Tortillas"]),
          anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]),
          anyFrom(["Shredded yellow Cheese","Shredded white cheese"]),
          anyFrom(["Salsa Roja","Salsa Verde"]),
        ].filter(Boolean);
        if(ids.length!==4) return null;
        const tiles = ids.map(id=> hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      if(r.kind==="chorizoTaco"){
        const ids = [
          anyFrom(["Flour Tortillas","Corn Tortillas"]),
          pick("Chorizo") || pick("Grocery Run"),
          pick("Onion") || pick("Grocery Run"),
          pick("Cilantro") || pick("Grocery Run"),
        ].filter(Boolean);
        if(ids.length!==4) return null;
        const tiles = ids.map(id=> hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(recipeKey, tiles, ctx);
        if(!v.ok) return null;
        return { tileIds: ids };
      }

      return null;
    }

    /* ===== CPU turn ===== */
    let cpuTimer = null;

    function cpuChar(pid){
      const p = state.match.players[pid];
      const key = p.charKey || "salsaSam";
      return CPU_CHARACTERS[key] || CPU_CHARACTERS.salsaSam;
    }

    function playerColor(pid){
      if(pid==="P1") return state.settings.accent || "#00e5ff";
      return cpuChar(pid).color || "#ffffff";
    }

    function scheduleCpuTurn(pid){
      clearTimeout(cpuTimer);
      const delay = cpuTurnDelayMs(pid);

      const showSkip = (state.settings.mode==="campaign");
      $("campaignSkipRow").style.display = showSkip ? "flex" : "none";
      $("btnSkipCPU").onclick = ()=>{
        clearTimeout(cpuTimer);
        cpuTimer = null;
        doCpuTurn(pid, true);
      };

      toast(`${state.match.players[pid].name} is thinking...`, Math.max(900, delay));
      cpuTimer = setTimeout(()=>{
        doCpuTurn(pid);
      }, delay);
    }

    function doCpuTurn(pid, skipped=false){
      const m = state.match;
      const pl = m.players[pid];
      if(!pl || pl.isHuman) return;

      const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };

      // MUST draw once per turn (if tiles remain)
      let drawnTile = null;
      if(m.bag.length > 0 && !pl.didDraw){
        drawnTile = drawOneTileFor(pid, { announce:false });
      }

      let action = "drew";
      let platedInfo = null; // {name, tilesCount, points}

      if(ctx.kitchenOpen && cpuCanRemix()){
        const ch = cpuChar(pid);
        const wantRemix = Math.random() < Math.min(0.95, 0.35 * ch.remixBias);
        if(wantRemix){
          const cand = m.publicLine
            .filter(d=> d.points >= RULES.remixMinPoints && d.owner !== pid)
            .sort((a,b)=> b.points - a.points);
          const target = cand[0];
          if(target){
            const diff = effectiveDifficulty();
            const masterBoost = diff==="Master Chef" ? 0.85 : 0.55;
            if(Math.random() < masterBoost){
              const idx = m.publicLine.findIndex(x=>x.id===target.id);
              if(idx>=0){
                m.publicLine.splice(idx,1);
                const pub = {
                  id: nowId("pub"),
                  owner: pid,
                  ownerName: pl.name,
                  recipeKey: target.recipeKey,
                  name: target.name,
                  points: target.points,
                  tiles: target.tiles.map(t=>({id: nowId("rt"), name:t.name})),
                  isRemix: true,
                  from: target.owner
                };
                m.publicLine.push(pub);
                pl.score += pub.points;
                pl.servedThisHand += pub.points;
                pl.didRemix = true;
                action = "remixed";
                platedInfo = { name: pub.name + " (Remix)", tilesCount: pub.tiles.length, points: pub.points };
              }
            }
          }
        }
      }

      if(action !== "remixed"){
        const ch = cpuChar(pid);
        const prefApp = Math.random() < ch.appetizerBias;
        const tryOrder = prefApp ? ["chipsDip","pico","ench","hardTaco","softTaco","chorizoTaco"] : ["ench","pico","hardTaco","softTaco","chorizoTaco","chipsDip"];

        let plated = null;
        for(const rk of tryOrder){
          const best = findBestDishFromHand(pl.hand, rk, ctx);
          if(best){
            plated = { rk, tileIds: best.tileIds };
            break;
          }
        }

        if(plated){
          const r = recipeByKey(plated.rk);
          const tiles = plated.tileIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
          const v = validateDish(plated.rk, tiles, ctx);
          if(v.ok){
            const pub = {
              id: nowId("pub"),
              owner: pid,
              ownerName: pl.name,
              recipeKey: plated.rk,
              name: r.name,
              points: r.pts,
              tiles: tiles.map(t=>({id:t.id, name:t.name})),
              isRemix:false,
              from:null
            };
            m.publicLine.push(pub);

            for(const t of tiles){
              const idx = pl.hand.findIndex(h=>h.id===t.id);
              if(idx>=0) pl.hand.splice(idx,1);
            }
            pl.score += r.pts;
            pl.servedThisHand += r.pts;
            pl.didPublish = true;

            m.servedThisTurnPts += r.pts;
            if(!m.kitchenOpen && m.servedThisTurnPts >= 10){
              m.kitchenOpen = true;
              if(state.campaign.active) state.campaign.kitchenUnlockedEver = true;
              toast("üî• Kitchen Open!", 2200);
            }

            action = "plated";
            platedInfo = { name: r.name, tilesCount: tiles.length, points: r.pts };
          }
        }else{
          // No plate found; per rule, CPU already drew (if possible) ‚Äî now just ends turn.
          action = "drew";
        }
      }

      // Announce CPU outcome (requested format)
      const msgs = [];
      if(action==="plated" && platedInfo){
        msgs.push([`${pl.name} ‚Ä¢ ${platedInfo.name} ‚Ä¢ Tiles: ${platedInfo.tilesCount} ‚Ä¢ Points: ${platedInfo.points}`, 2400]);
      }else if(action==="remixed" && platedInfo){
        msgs.push([`${pl.name} ‚Ä¢ ${platedInfo.name} ‚Ä¢ Tiles: ${platedInfo.tilesCount} ‚Ä¢ Points: ${platedInfo.points}`, 2400]);
      }else{
        if(drawnTile){
          msgs.push([`${pl.name} drew: ${drawnTile.name}`, 1700]);
        }else{
          msgs.push([`${pl.name} ends their turn.`, 1400]);
        }
      }
      msgs.push(["‚úÖ", 900]);
      toastSeq(msgs);

      endTurn(pid, true);
    }

    /* ===== Turn flow ===== */
    function endTurn(pid, fromCpu=false){
      const m = state.match;
      if(m.activePid !== pid) return;

      const pl = m.players[pid];

      // MUST draw before ending turn if tiles remain
      if(m.bag.length > 0 && !pl.didDraw){
        if(pid==="P1") toast("Draw 1 tile before ending your turn.");
        return;
      }

      if(endHandIfNeeded()){
        persist(); render();
        return;
      }

      m.servedThisTurnPts = 0;

      const order = Object.keys(m.players);
      const i = order.indexOf(pid);
      const next = order[(i+1)%order.length];
      m.activePid = next;

      // Reset didDraw at start of the next player's turn
      m.players[next].didDraw = false;

      if(pid==="P1"){
        state.ui.serveSel = [];
        state.ui.remixSelPublic = new Set();
      }

      persist();
      render();

      if(next !== "P1"){
        scheduleCpuTurn(next);
      }else{
        toast("Your turn.");
      }
    }

    /* ===== UI / Pages ===== */
    function t(key){
      const lang = state.settings.lang || "en";
      return (I18N[lang] && I18N[lang][key]) || I18N.en[key] || key;
    }

    function setPage(p){
      state.ui.page = p;
      persist();
      render();
    }

    function setNavActive(btnId){
      ["navGame","navPrep","navScores","navSettings"].forEach(id=>{
        $(id).classList.toggle("active", id===btnId);
      });
    }

    $("navGame").onclick = ()=> setPage("gameplay");
    $("navPrep").onclick = ()=> setPage("prep");
    $("navScores").onclick = ()=> setPage("scores");
    $("navSettings").onclick = ()=> setPage("settings");

    /* ===== Wire buttons ===== */
    $("btnNewMatchTop").onclick = ()=>{
      openModal(
        "New Match",
        "Start a fresh match? This will overwrite the current match state.",
        [
          { text:"Cancel", className:"ghost", onClick: closeModal },
          { text:"Start", className:"primary", onClick: ()=>{ closeModal(); newMatch(); } }
        ]
      );
    };

    $("btnDraw").onclick = ()=>{
      const m = state.match;
      if(!m){ newMatch(); return; }
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      const tile = drawOneTileFor("P1", { announce:true });
      if(!tile) return;
      persist(); render();
    };

    $("btnPublishDraft").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      if(mustDrawBeforePlay()){ toast("Draw 1 tile first."); return; }

      const pl = p1();
      const ids = pl.drafts.map(d=>d.id);
      if(!ids.length){ toast("No drafts."); return; }
      const res = publishSelectedDrafts("P1", ids);
      if(!res.ok){ toast(res.msg); return; }
      persist(); render();
      toast("Order up!");
    };

    $("btnServeSel").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      if(mustDrawBeforePlay()){ toast("Draw 1 tile first."); return; }

      const pl = p1();
      let sel = state.ui.serveSel || [];
      if(sel.length===0){
        const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };
        sel = pl.drafts
          .filter(d=>{
            const tiles = d.tileIds.map(id=>pl.hand.find(t=>t.id===id)).filter(Boolean);
            return validateDish(d.recipeKey, tiles, ctx).ok;
          })
          .map(d=>d.id);
      }

      if(sel.length===0){ toast("No valid drafts selected."); return; }
      const res = publishSelectedDrafts("P1", sel);
      if(!res.ok){ toast(res.msg); return; }
      state.ui.serveSel = [];
      persist(); render();
      toast("Served selected.");
    };

    $("btnEndTurn").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast(t("notYourTurn")); return; }
      endTurn("P1");
    };

    $("btnNewDish").onclick = newDish;
    $("btnClearDish").onclick = clearCurrentDish;
    $("btnRemoveDish").onclick = removeCurrentDish;
    $("btnAutoPlate").onclick = autoPlate;
    $("btnAutoRemix").onclick = autoRemixPreview;

    $("selRecipe").onchange = ()=> updateCurrentDishRecipe($("selRecipe").value);

    $("handTiles").addEventListener("click",(e)=>{
      const el = e.target.closest("[data-htile]");
      if(!el) return;
      toggleHandTileForDish(el.getAttribute("data-htile"));
    });

    $("nowServingList").addEventListener("click",(e)=>{
      const el = e.target.closest("[data-serve]");
      if(!el) return;
      const id = el.getAttribute("data-serve");
      const a = state.ui.serveSel || [];
      const i = a.indexOf(id);
      if(i>=0) a.splice(i,1); else a.push(id);
      state.ui.serveSel = a;
      persist(); render();
    });

    /* ===== Settings wiring ===== */
    function fillSettings(){
      $("selDifficulty").innerHTML = DIFFS.map(d=> `<option value="${d}">${d}</option>`).join("");
      $("selDifficulty").value = state.settings.difficulty;

      $("selAccent").innerHTML = ACCENTS.map(a=> `<option value="${a.val}">${a.name} (${a.val})</option>`).join("");
      $("selAccent").value = state.settings.accent;

      $("selRecipe").innerHTML = RECIPES.map(r=> `<option value="${r.key}">${r.name} (${r.pts} pts)</option>`).join("");

      $("selMode").value = state.settings.mode;
      $("selPlayers").value = String(state.settings.players);
      $("inpHands").value = state.settings.handsTotal;
      $("inpTilesPerPlayer").value = state.settings.tilesPerPlayer;
      $("selDecks").value = String(state.settings.decks);
      $("selLang").value = state.settings.lang;
    }

    $("selMode").onchange = ()=>{
      state.settings.mode = $("selMode").value;
      persist();
      render();
      toast("Mode updated.");
    };
    $("selPlayers").onchange = ()=>{
      state.settings.players = parseInt($("selPlayers").value,10);
      persist();
      render();
      toast("Players updated.");
    };
    $("selDifficulty").onchange = ()=>{
      state.settings.difficulty = $("selDifficulty").value;
      persist(); render();
    };
    $("inpHands").onchange = ()=>{
      state.settings.handsTotal = Math.max(1, Math.min(12, parseInt($("inpHands").value,10) || 12));
      persist(); render();
    };
    $("inpTilesPerPlayer").onchange = ()=>{
      state.settings.tilesPerPlayer = Math.max(8, Math.min(24, parseInt($("inpTilesPerPlayer").value,10) || 16));
      persist(); render();
    };
    $("selDecks").onchange = ()=>{
      state.settings.decks = parseInt($("selDecks").value,10) || 2;
      persist(); render();
    };
    $("selAccent").onchange = ()=>{
      state.settings.accent = $("selAccent").value;
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));
      persist(); render();
    };
    $("selLang").onchange = ()=>{
      state.settings.lang = $("selLang").value;
      persist(); render();
    };

    /* ===== Render ===== */
    function render(){
      if(!state.match) newMatch();

      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      $("verPill").textContent = VERSION;
      $("btnPublishDraft").textContent = t("orderUp");
      $("btnDraw").textContent = t("drawTile");
      $("btnServeSel").textContent = t("serveSelected");
      $("btnEndTurn").textContent = t("endTurn");
      $("turnHint").textContent = t("yourTurn");

      $("navGame").querySelector(".tx").textContent = t("gameplay");
      $("navPrep").querySelector(".tx").textContent = t("prep");
      $("navScores").querySelector(".tx").textContent = t("scores");
      $("navSettings").querySelector(".tx").textContent = t("settings");

      ["pageGameplay","pagePrep","pageScores","pageSettings"].forEach(id=> $(id).classList.remove("on"));
      if(state.ui.page==="gameplay"){ $("pageGameplay").classList.add("on"); setNavActive("navGame"); }
      if(state.ui.page==="prep"){ $("pagePrep").classList.add("on"); setNavActive("navPrep"); }
      if(state.ui.page==="scores"){ $("pageScores").classList.add("on"); setNavActive("navScores"); }
      if(state.ui.page==="settings"){ $("pageSettings").classList.add("on"); setNavActive("navSettings"); }

      fillSettings();
      renderMenuRef();

      renderGameplay();
      renderPrep();
      renderScores();

      const m = state.match;
      if(m.activePid !== "P1"){
        scheduleCpuTurn(m.activePid);
      }else{
        $("campaignSkipRow").style.display = "none";
      }
    }

    function renderMenuRef(){
      $("menuRef").innerHTML = MENU_REFERENCE.map(x=>`
        <div class="row sp" style="margin-bottom:10px;">
          <div style="font-weight:1000;">${escapeHtml(x.title)}</div>
          <span class="badge">${x.pts} pts</span>
        </div>
        <div class="muted small" style="margin-bottom:12px;">${escapeHtml(x.desc)}</div>
        <div style="height:1px; background: rgba(255,255,255,.06); margin: 0 0 12px;"></div>
      `).join("");
    }

    function phaseText(){
      const m = state.match;
      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);
      if(!kitchen){
        return {
          title:"Not Seated Yet",
          desc:"Serve 10+ points in one turn to open the kitchen. No remixes yet."
        };
      }
      return {
        title:"Kitchen Open",
        desc:"Remix is enabled. Public line dishes may be rebuilt into new dishes."
      };
    }

    function renderGameplay(){
      const m = state.match;
      const diff = effectiveDifficulty();
      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);

      $("tilesRemainBadge").textContent = `${t("tilesRemaining")} ${m.bag.length}`;
      $("kitchenBadge").textContent = kitchen ? t("kitchenOpen") : t("kitchenClosed");
      $("handBadge").textContent = `Hand ${m.handIndex}/${state.settings.handsTotal}`;
      $("diffBadge").textContent = `Difficulty ${diff}`;
      $("modeBadge").textContent = state.settings.mode==="campaign" ? "Campaign" : "Standard";
      $("lineSummary").textContent = `${m.publicLine.length} dish${m.publicLine.length===1?"":"es"}`;

      const ph = phaseText();
      $("phaseTitle").textContent = ph.title;
      $("phaseDesc").textContent = ph.desc;

      const myTurn = (m.activePid==="P1");
      const pl = m.players["P1"];
      const mustDraw = myTurn && (m.bag.length > 0) && !pl.didDraw;

      $("btnDraw").disabled = !myTurn || pl.didDraw || (m.bag.length===0);
      $("btnPublishDraft").disabled = !myTurn || mustDraw;
      $("btnServeSel").disabled = !myTurn || mustDraw;
      $("btnEndTurn").disabled = !myTurn || mustDraw;

      renderNowServing();
      renderPublicLine();
    }

    function renderNowServing(){
      const wrap = $("nowServingWrap");
      const list = $("nowServingList");
      const m = state.match;
      const pl = m.players["P1"];
      const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };

      if(!pl.drafts.length){
        wrap.style.display = "none";
        return;
      }
      wrap.style.display = "block";

      const annotated = pl.drafts.map(d=>{
        const tiles = d.tileIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(d.recipeKey, tiles, ctx);
        return { d, tiles, ok:v.ok, reason:v.reason||"" };
      });

      const selIds = state.ui.serveSel || [];
      const sel = annotated.filter(x=> selIds.includes(x.d.id) && x.ok);
      const selPts = sel.reduce((t,x)=> t + x.d.pts, 0);

      $("serveSelPill").textContent = `Selected ${sel.length} ‚Ä¢ ${selPts} pts`;
      $("serveNeedPill").style.display = (!ctx.kitchenOpen && selPts < 10) ? "inline-flex" : "none";

      list.innerHTML = annotated.map(x=>{
        const d = x.d;
        const selected = selIds.includes(d.id);
        const tilesText = x.tiles.map(t=>t.name).join(", ");
        return `
          <div class="serveCard ${selected?"sel":""} ${x.ok?"":"invalid"}" data-serve="${escapeHtml(d.id)}">
            <div class="serveTop">
              <div>${escapeHtml(d.name)}</div>
              <div>${d.pts} pts</div>
            </div>
            <div class="serveMeta">${escapeHtml(tilesText || "No tiles yet")}</div>
            <div class="serveBad">${x.ok ? "‚úÖ Ready" : "‚ö†Ô∏è " + escapeHtml(x.reason)}</div>
          </div>
        `;
      }).join("");
    }

    function renderPublicLine(){
      const m = state.match;
      const el = $("publicLine");
      if(!m.publicLine.length){
        el.innerHTML = `<div class="muted small">No dishes in the window yet.</div>`;
        return;
      }

      const groups = groupBy(m.publicLine, d=> d.name);

      el.innerHTML = Object.entries(groups).map(([menuItem, dishes])=>{
        const total = dishes.reduce((t,d)=>t+d.points,0);
        return `
          <div class="pubGroup" style="margin-bottom:12px;">
            <div class="pubGroupTitle">
              <div>${escapeHtml(menuItem)}</div>
              <span class="badge">Total <span class="mono">${total}</span></span>
            </div>
            ${dishes.map(d=>{
              const col = playerColor(d.owner);
              const tintA = hexToRgba(col,.28);
              const tiles = d.tiles.map(t=>{
                const wet = isWet(t.name) ? "wet" : "";
                const wild = isWild(t.name) ? "wild" : "";
                return `<span class="tile ${wet} ${wild}" style="--tintA:${tintA};">${escapeHtml(t.name)}</span>`;
              }).join("");
              return `
                <div class="pubDishRow" style="--tintA:${tintA};">
                  <div class="pubDishMeta">
                    <div>${escapeHtml(d.ownerName)}${d.isRemix ? " ‚Ä¢ Remix" : ""}</div>
                    <span class="badge">Pts <span class="mono">${d.points}</span></span>
                  </div>
                  <div class="tiles" style="margin-top:8px;">${tiles}</div>
                </div>
              `;
            }).join("")}
          </div>
        `;
      }).join("");
    }

    function renderPrep(){
      const m = state.match;
      const pl = m.players["P1"];
      const d = currentDish();

      $("handCountHint").textContent = `${pl.hand.length} tiles`;

      $("btnAutoPlate").style.display = autoPlateAllowed() ? "inline-flex" : "none";
      $("btnAutoRemix").style.display = autoRemixAllowed() ? "inline-flex" : "none";

      const kitchen = m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver);
      $("btnAutoPlate").disabled = !(m.activePid==="P1");
      $("btnAutoRemix").disabled = !(m.activePid==="P1" && kitchen);

      $("autoHint").innerHTML = autoPlateAllowed()
        ? "Auto-Plate is enabled for Beginner/Easy. Tap tiles or auto-fill a valid dish."
        : "Tap hand tiles to add/remove from your current dish.";

      if(d){
        $("selRecipe").value = d.recipeKey;
        $("dishMeta").textContent = `${d.name} ‚Ä¢ ${d.pts} pts`;
      }else{
        $("dishMeta").textContent = "‚Äî";
      }

      $("handTiles").innerHTML = pl.hand.map(t=>{
        const inDish = d?.tileIds.includes(t.id);
        const wet = isWet(t.name) ? "wet" : "";
        const wild = isWild(t.name) ? "wild" : "";
        return `<span class="tile ${inDish?"sel":""} ${wet} ${wild}" data-htile="${escapeHtml(t.id)}">${escapeHtml(t.name)}</span>`;
      }).join("");

      if(!d){
        $("dishTiles").innerHTML = `<div class="muted small">No draft selected.</div>`;
        $("dishHint").textContent = "";
      }else{
        const tiles = d.tileIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
        $("dishTiles").innerHTML = tiles.map(t=>{
          const wet = isWet(t.name) ? "wet" : "";
          const wild = isWild(t.name) ? "wild" : "";
          return `<span class="tile ${wet} ${wild}">${escapeHtml(t.name)}</span>`;
        }).join("") || `<div class="muted small">No tiles yet.</div>`;

        const ctx = { kitchenOpen: kitchen };
        const v = validateDish(d.recipeKey, tiles, ctx);
        $("dishHint").textContent = v.ok ? "‚úÖ Ready to serve." : `‚ö†Ô∏è ${v.reason}`;
      }

      renderPublicTilesGrouped();
    }

    function renderPublicTilesGrouped(){
      const m = state.match;
      const el = $("publicTiles");
      if(!m.publicLine.length){
        el.innerHTML = `<div class="muted small">No public dishes yet.</div>`;
        return;
      }
      const groups = groupBy(m.publicLine, d=> d.name);
      el.innerHTML = `<div class="pubGroups">${
        Object.entries(groups).map(([menuItem, dishes])=>{
          return `
            <div class="pubGroup">
              <div class="pubGroupTitle">
                <div>${escapeHtml(menuItem)}</div>
                <span class="badge">${dishes.length} dish${dishes.length===1?"":"es"}</span>
              </div>
              ${dishes.map(d=>{
                const col = playerColor(d.owner);
                const tintA = hexToRgba(col,.28);
                const tiles = d.tiles.map(t=>{
                  const wet = isWet(t.name) ? "wet" : "";
                  const wild = isWild(t.name) ? "wild" : "";
                  return `<span class="tile ${wet} ${wild}" style="--tintA:${tintA};">${escapeHtml(t.name)}</span>`;
                }).join("");
                return `
                  <div class="pubDishRow" style="--tintA:${tintA};">
                    <div class="pubDishMeta">
                      <div>${escapeHtml(d.ownerName)}${d.isRemix ? " ‚Ä¢ Remix" : ""}</div>
                      <span class="badge">${d.points} pts</span>
                    </div>
                    <div class="tiles" style="margin-top:8px;">${tiles}</div>
                  </div>
                `;
              }).join("")}
            </div>
          `;
        }).join("")
      }</div>`;
    }

    function renderScores(){
      const m = state.match;
      const pl = m.players["P1"];

      $("scoreModePill").textContent = state.settings.mode==="campaign" ? "Campaign" : "Standard";

      const ctx = { kitchenOpen: m.kitchenOpen || (state.campaign.active && state.campaign.kitchenUnlockedEver) };
      const pendingPts = pl.drafts.reduce((sum,d)=>{
        const tiles = d.tileIds.map(id=>pl.hand.find(t=>t.id===id)).filter(Boolean);
        const v = validateDish(d.recipeKey, tiles, ctx);
        return sum + (v.ok ? d.pts : 0);
      },0);

      $("scoreCurrent").textContent = `Current: ${pl.score}`;
      $("scorePending").textContent = `Pending: ${pendingPts}`;
      $("scoreServed").textContent = `Served this hand: ${pl.servedThisHand}`;

      const players = Object.values(m.players);
      $("scoreList").innerHTML = players.map(p=>{
        const isMe = p.id==="P1";
        const c = playerColor(p.id);
        const tintA = hexToRgba(c,.18);
        return `
          <div class="card" style="margin-top:12px; padding:14px; --tintA:${tintA}; position:relative; overflow:hidden;">
            <div style="position:absolute; inset:0; background: linear-gradient(135deg, ${tintA}, transparent 70%); opacity:.9; pointer-events:none;"></div>
            <div style="position:relative; z-index:1;">
              <div class="row sp">
                <div style="font-weight:1000;">${escapeHtml(p.name)}${isMe ? " (You)" : ""}</div>
                <span class="badge">${p.score} match</span>
              </div>
              <div class="muted small" style="margin-top:6px;">
                Hand net: ${p.servedThisHand} served ‚Ä¢ penalty ${p.hand.length}
              </div>
            </div>
          </div>
        `;
      }).join("");

      const show = (state.settings.mode==="campaign");
      $("campaignBoxAcc").style.display = show ? "block" : "none";
      if(show){
        const rows = (state.campaign.chapterScores || []).map((c,i)=>`
          <div class="row sp" style="margin-top:10px;">
            <div style="font-weight:1000;">Chapter ${i+1} ‚Ä¢ ${escapeHtml(c.diff)}</div>
            <span class="badge">${c.total}</span>
          </div>
        `).join("");

        const running = players.find(p=>p.id==="P1")?.score ?? 0;
        $("campaignBoxBody").innerHTML = `
          ${rows || `<div class="muted small">No completed chapters yet.</div>`}
          <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>
          <div class="row sp">
            <div style="font-weight:1000;">Running Total</div>
            <span class="badge">${running}</span>
          </div>
        `;
      }
    }

    /* ===== Init + boot ===== */
    function boot(){
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      $("selDifficulty").innerHTML = DIFFS.map(d=> `<option value="${d}">${d}</option>`).join("");
      $("selAccent").innerHTML = ACCENTS.map(a=> `<option value="${a.val}">${a.name} (${a.val})</option>`).join("");

      render();
    }

    boot();
  </script>
</body>
</html>
