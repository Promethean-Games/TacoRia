<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Taco Ria — MVP</title>
  <style>
    :root{
      --bg:#000;
      --panel:#0b0b0b;
      --panel2:#111;
      --text:#fff;
      --muted:rgba(255,255,255,.72);
      --muted2:rgba(255,255,255,.55);
      --border:rgba(255,255,255,.14);
      --shadow: 0 16px 40px rgba(0,0,0,.55);
      --radius:16px;
      --radius2:12px;
      --accent:#d11111;
      --accent2: rgba(209,17,17,.18);
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --safe: env(safe-area-inset-bottom, 0px);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 20% -10%, rgba(255,255,255,.06), transparent 55%),
                  radial-gradient(1000px 800px at 110% 10%, rgba(255,255,255,.05), transparent 55%),
                  var(--bg);
      color:var(--text);
      overflow-x:hidden;
      -webkit-tap-highlight-color: transparent;
    }
    .app{max-width:980px;margin:0 auto;padding:14px 14px calc(88px + var(--safe))}
    .topbar{
      position:sticky;top:0;z-index:20;
      padding:12px 0 10px;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(0,0,0,.78), rgba(0,0,0,.15));
    }
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .brand, .stats{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius:var(--radius);
      padding:12px;
      box-shadow: var(--shadow);
      min-width:260px;
      flex:1 1 320px;
      min-width:0;
    }
    .brand .head{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .title{font-weight:1000;letter-spacing:.5px}
    .subtitle{font-size:12px;color:var(--muted);margin-top:2px;word-break:break-word;overflow-wrap:anywhere}
    .pill{
      font-size:12px;color:var(--text);
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      padding:8px 10px;border-radius:999px;
      display:flex;gap:8px;align-items:center;
      max-width:100%;
      white-space:nowrap;
    }
    .dot{width:10px;height:10px;border-radius:999px;background:var(--accent);box-shadow:0 0 0 3px var(--accent2)}
    .phase{
      margin-top:10px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius:14px;
      padding:10px;
    }
    .phase .pname{font-weight:900;word-break:break-word}
    .phase .phelp{margin-top:4px;font-size:12px;color:var(--muted);word-break:break-word;overflow-wrap:anywhere}
    .minirow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .card{
      border:1px solid var(--border);
      background: rgba(0,0,0,.35);
      border-radius:14px;
      padding:10px;
      min-width:0;
    }
    .k{font-size:11px;color:var(--muted);word-break:break-word}
    .v{font-size:18px;font-weight:1000;margin-top:4px;word-break:break-word;overflow-wrap:anywhere}
    .v.small{font-size:13px;font-weight:850;color:var(--muted);margin-top:4px;word-break:break-word}

    .main{display:grid;grid-template-columns:1fr;gap:12px;margin-top:10px}
    @media(min-width:860px){ .main{grid-template-columns:1.25fr .75fr} }

    .panel{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-width:0;
    }
    .ph{
      padding:12px;
      border-bottom:1px solid var(--border);
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      background: rgba(0,0,0,.25);
      min-width:0;
    }
    .ph .h{font-weight:1000;word-break:break-word}
    .ph .sub{font-size:12px;color:var(--muted);word-break:break-word;overflow-wrap:anywhere}
    .pb{padding:12px;min-width:0}

    .btnrow{display:flex;gap:8px;flex-wrap:wrap}
    button{
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
      cursor:pointer;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      max-width:100%;
    }
    button:active{transform: scale(.985)}
    button.primary{
      border-color: rgba(255,255,255,.22);
      background: linear-gradient(180deg, var(--accent), rgba(0,0,0,.35));
      box-shadow: 0 10px 24px rgba(0,0,0,.35), 0 0 0 4px var(--accent2);
    }
    button.ghost{background: rgba(255,255,255,.03)}
    button.danger{background: rgba(239,68,68,.12); border-color: rgba(239,68,68,.35)}
    button:disabled{opacity:.45;cursor:not-allowed}

    .tiles{display:flex;flex-wrap:wrap;gap:8px;max-width:100%}
    .tile{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      padding:10px 10px;
      border-radius:14px;
      font-weight:900;
      font-size:12px;
      line-height:1.15;
      cursor:pointer;
      user-select:none;
      display:flex;gap:10px;align-items:center;
      flex: 1 1 160px;
      min-width: 0;
      max-width: 100%;
    }
    .tile .name{flex:1;min-width:0;word-break:break-word;overflow-wrap:anywhere}
    .tile .tag{font-size:11px;color:var(--muted);font-weight:750;word-break:break-word;overflow-wrap:anywhere;margin-top:3px}
    .tile.sel{outline:2px solid rgba(255,255,255,.26); background: rgba(255,255,255,.08)}
    .tile.small{padding:8px 10px;flex: 1 1 140px}
    .chip{width:10px;height:10px;border-radius:999px;background:rgba(255,255,255,.22);flex:0 0 auto}
    .chip.accent{background:var(--accent);box-shadow:0 0 0 3px var(--accent2)}

    .badge{
      font-size:12px;font-weight:1000;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      white-space:nowrap;
      max-width:100%;
    }
    .badge.good{border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.12)}
    .badge.warn{border-color: rgba(245,158,11,.35); background: rgba(245,158,11,.12)}
    .badge.bad{border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.12)}
    .hint{font-size:12px;color:var(--muted);margin-top:8px;word-break:break-word;overflow-wrap:anywhere}
    .hr{height:1px;background:var(--border);margin:12px 0}
    .muted{color:var(--muted);font-size:12px;word-break:break-word;overflow-wrap:anywhere}

    .footerNav{
      position:fixed;left:0;right:0;bottom:0;
      padding:10px 10px calc(10px + var(--safe));
      background: linear-gradient(to top, rgba(0,0,0,.90), rgba(0,0,0,.45));
      border-top:1px solid var(--border);
      backdrop-filter: blur(10px);
      z-index:30;
    }
    .tabs{max-width:980px;margin:0 auto;display:flex;gap:8px;justify-content:space-between}
    .tab{
      flex:1 1 auto;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      padding:10px 10px;
      border-radius:16px;
      font-weight:1000;
      font-size:12px;
      text-align:center;
      cursor:pointer;
      user-select:none;
      min-width:0;
      word-break:break-word;
      overflow-wrap:anywhere;
    }
    .tab.on{
      background: rgba(255,255,255,.09);
      border-color: rgba(255,255,255,.20);
      box-shadow: 0 0 0 4px var(--accent2);
    }

    details.acc{
      border:1px solid var(--border);
      background: rgba(0,0,0,.28);
      border-radius:16px;
      padding:10px;
      margin-bottom:10px;
      min-width:0;
    }
    details.acc > summary{
      list-style:none;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:1000;
      user-select:none;
      min-width:0;
      word-break:break-word;
      overflow-wrap:anywhere;
    }
    details.acc > summary::-webkit-details-marker{display:none}
    .acc .sumHint{font-size:12px;color:var(--muted);font-weight:800}
    .acc .accBody{margin-top:10px}
    .chev{opacity:.75}

    .modalWrap{
      position:fixed;inset:0;
      background: rgba(0,0,0,.68);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:16px 16px calc(16px + var(--safe));
      z-index:100;
    }
    .modalWrap.on{display:flex}
    .modal{
      width:min(760px, 100%);
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(12,12,12,.98), rgba(0,0,0,.92));
      border-radius:20px;
      box-shadow: var(--shadow);
      overflow:hidden;
      max-height: 88vh;
      display:flex;
      flex-direction:column;
      min-width:0;
    }
    .modal .mh{
      padding:12px 12px;
      border-bottom:1px solid var(--border);
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      min-width:0;
    }
    .modal .mh .t{font-weight:1100;word-break:break-word}
    .modal .mb{padding:12px; overflow:auto; min-width:0}
    .modal .mf{padding:12px;border-top:1px solid var(--border);display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap}
    .blankGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .blank{
      border:1px dashed rgba(255,255,255,.25);
      background: rgba(255,255,255,.03);
      border-radius:16px;
      padding:16px;
      text-align:center;
      font-weight:1100;
      cursor:pointer;
      user-select:none;
      min-width:0;
      word-break:break-word;
    }
    .blank.on{
      border-color: rgba(255,255,255,.55);
      background: rgba(255,255,255,.09);
      box-shadow: 0 0 0 4px var(--accent2);
    }
    .toast{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:86px;
      max-width:min(760px, calc(100% - 24px));
      background: rgba(0,0,0,.75);
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px 12px;
      color:var(--text);
      box-shadow: var(--shadow);
      display:none;
      z-index:200;
      word-break:break-word;
      overflow-wrap:anywhere;
    }
    .toast.on{display:block; animation: pop .18s ease-out}
    @keyframes pop{from{transform:translateX(-50%) translateY(8px);opacity:.0}to{transform:translateX(-50%) translateY(0);opacity:1}}

    select,input{
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      color:var(--text);
      border-radius:14px;
      padding:10px 12px;
      font-weight:900;
      outline:none;
      max-width:100%;
    }
    .field{display:flex;flex-direction:column;gap:6px;margin-bottom:12px;min-width:0}
    .label{font-size:12px;color:var(--muted);font-weight:900;word-break:break-word}

    .remixGrid{display:grid;gap:12px;min-width:0}
    @media(min-width:860px){ .remixGrid{grid-template-columns: 1fr 1fr} }
    .pool{
      border:1px solid var(--border);
      background: rgba(0,0,0,.22);
      border-radius:16px;
      padding:12px;
      min-width:0;
    }
    .poolHead{
      display:flex;justify-content:space-between;gap:10px;align-items:center;margin-bottom:10px;
      min-width:0;
    }

    .dishShell{
      border:1px solid var(--border);
      background: rgba(0,0,0,.28);
      border-radius:16px;
      padding:12px;
      min-width:0;
      max-width:100%;
    }
    .dishHead{
      display:flex;justify-content:space-between;gap:10px;align-items:center;margin-bottom:10px;
      min-width:0;
    }
    .dishTitle{font-weight:1100;word-break:break-word}
    .dishMeta{font-size:12px;color:var(--muted);margin-top:2px;word-break:break-word;overflow-wrap:anywhere}

    .feed{display:flex;flex-direction:column;gap:10px}
    .feedItem{
      border:1px solid var(--border);
      background: rgba(0,0,0,.28);
      border-radius:16px;
      padding:10px;
      min-width:0;
    }
    .feedTop{display:flex;justify-content:space-between;gap:10px;align-items:flex-start;min-width:0}
    .feedTop .txt{font-weight:1000;word-break:break-word;overflow-wrap:anywhere}
    .feedTop .tm{font-size:11px;color:var(--muted);white-space:nowrap}

    /* Pending breakdown: hidden by default (portrait). Shown in landscape only. */
    .pendingBreakdown{display:none}
    @media (orientation: landscape){
      .pendingBreakdown{display:block}
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="row">
        <div class="brand">
          <div class="head">
            <div>
              <div class="title">Taco Ria</div>
              <div class="subtitle">Private Prep • Publish 10+ to open kitchen • Public Line • Remix • End-of-round scoring</div>
            </div>
            <div class="pill"><span class="dot"></span><span id="activePlayerLabel">P1</span></div>
          </div>

          <div class="phase">
            <div class="pname" id="phaseName">Not Seated Yet</div>
            <div class="phelp" id="phaseHelp">Kitchen closed. Publish 10+ points in one turn to open it. No remix yet.</div>
          </div>

          <div class="minirow">
            <div class="pill"><span class="k">Hand</span> <span id="handIndex" class="mono">1</span>/<span id="handsTarget" class="mono">12</span></div>
            <div class="pill"><span class="k">Turn</span> <span id="turnIndex" class="mono">1</span>/<span id="turnsPerRound" class="mono">4</span></div>
            <div class="pill"><span class="k">Draw pile</span> <span id="drawCount" class="mono">108</span></div>
          </div>
        </div>

        <div class="stats">
          <div class="grid2">
            <div class="card">
              <div class="k">Current score (match)</div>
              <div class="v" id="scoreNow">0</div>
              <div class="v small" id="scoreByPlayers"></div>
            </div>
            <div class="card">
              <div class="k">Pending (this round)</div>
              <div class="v" id="pendingNow">0</div>
              <div class="v small" id="pendingByPlayers"></div>

              <div class="pendingBreakdown" style="margin-top:10px">
                <div class="k">Pending breakdown (landscape)</div>
                <div class="muted" id="pendingBreakdown"></div>
              </div>
            </div>
          </div>

          <div style="margin-top:10px" class="btnrow">
            <button class="primary" id="btnDraw">Draw</button>
            <button id="btnPublishAll">Publish All</button>
            <button id="btnEndTurn">End Turn</button>
          </div>

          <div class="hint" id="actionHint">Publish gives pending points; round commit happens after the last player ends their turn.</div>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="panel" id="mainPanel">
        <div class="ph">
          <div>
            <div class="h" id="panelTitle">Gameplay</div>
            <div class="sub" id="panelSub">Public Line + Remix + CPU plays.</div>
          </div>
          <div class="badge" id="turnBadge">Your turn</div>
        </div>
        <div class="pb" id="panelBody"></div>
      </div>

      <div class="panel">
        <div class="ph">
          <div>
            <div class="h">Menu Reference</div>
            <div class="sub">What “valid” looks like</div>
          </div>
        </div>
        <div class="pb" id="rulesBody"></div>
      </div>
    </div>
  </div>

  <div class="footerNav">
    <div class="tabs">
      <div class="tab on" data-tab="gameplay">Gameplay</div>
      <div class="tab" data-tab="prep">Prep</div>
      <div class="tab" data-tab="scores">Scores</div>
      <div class="tab" data-tab="settings">Settings</div>
    </div>
  </div>

  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="mh">
        <div class="t" id="modalTitle">Modal</div>
        <button class="ghost" id="modalClose">Close</button>
      </div>
      <div class="mb" id="modalBody"></div>
      <div class="mf" id="modalFoot"></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
/* =========================
   Taco Ria — Atomic Update
   - Publish earns pending (this round)
   - End-of-round commits pending to match score
   - Kitchen opens when any player publishes 10+ in one turn (Starter Pass does not open)
   - Once kitchen open: Line must be valid to end a turn; Remix allowed
   - 2 decks (108) + bigger deal
   - CPU difficulty + Master Chef aggressive remix (>=5) + draw-boost attempt
   - Auto-Plate gated to Beginner/Easy only
   - Pending A always, Pending B only in landscape
   ========================= */

const APP_VERSION = "0.2.0";

/* --- Theme presets --- */
const THEME_PRESETS = [
  { key:"red",    label:"Red (classic)",    accent:"#d11111" },
  { key:"cyan",   label:"Cyan (hi-vis)",    accent:"#22d3ee" },
  { key:"lime",   label:"Lime (hi-vis)",    accent:"#84cc16" },
  { key:"amber",  label:"Amber (hi-vis)",   accent:"#f59e0b" },
  { key:"magenta",label:"Magenta (hi-vis)", accent:"#e879f9" },
  { key:"violet", label:"Violet (hi-vis)",  accent:"#a78bfa" }
];

/* --- CPU difficulty --- */
const CPU_DIFFICULTIES = ["Beginner","Easy","Medium","Difficult","Master Chef"];
const CPU_CFG = {
  "Beginner": { comboLimit: 8000,  canRemix:false, remixChance:0,   publishAggro:0.30 },
  "Easy":     { comboLimit: 12000, canRemix:false, remixChance:0,   publishAggro:0.45 },
  "Medium":   { comboLimit: 16000, canRemix:false, remixChance:0,   publishAggro:0.60 },
  "Difficult":{ comboLimit: 22000, canRemix:true,  remixChance:0.35,publishAggro:0.75 },
  "Master Chef":{ comboLimit: 28000, canRemix:true, remixChance:1.0, publishAggro:0.95 }
};
function getCpuCfg(){ return CPU_CFG[state.settings.cpuDifficulty] || CPU_CFG["Easy"]; }
function autoPlateAllowed(){
  const d = state.settings.cpuDifficulty || "Easy";
  return d==="Beginner" || d==="Easy";
}

/* =========================
   Rules + Data
   ========================= */
const GAME = {
  rules: {
    numDecks: 2,
    defaultHandsTarget: 12,
    handsTargetMin: 1,
    handsTargetMax: 12,
    publishToOpenKitchenThreshold: 10,
    tacoMaxCards: 3,
    endHandPenaltyPerCard: 1,
    starterPassMaxPerHand: 1
  },
  roles: {
    tortilla_any: ["Corn Tortillas","Flour Tortillas"],
    protein: ["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"],
    cheese: ["Shredded yellow Cheese","Shredded white cheese"],
    dry_topping: ["Onion","Cilantro","Jalapenos","Lettuce","Tomato","Sour Cream","Avocado","Shredded yellow Cheese","Shredded white cheese"],
    wet_topping: ["Salsa Roja","Salsa Verde","Queso","Guacamole"],
    dip: ["Salsa Roja","Salsa Verde","Queso","Guacamole"],
    sauce_enchiladas: ["Salsa Roja","Salsa Verde","Queso"],
    pico: ["Tomato","Onion","Cilantro","Lime Juice"],
    wild: ["Grocery Run"]
  },
  baseDeckCounts: {
    "Fish":1,
    "Ground Beef":2,
    "Shredded Chicken":2,
    "Carne Guisada":1,
    "Al Pastor":1,
    "Carnitas":1,
    "Egg":2,
    "Chicken Fajita":2,
    "Chorizo":1,
    "Tortilla Chips":3,
    "Flour Tortillas":2,
    "Corn Tortillas":2,
    "Shredded yellow Cheese":2,
    "Shredded white cheese":2,
    "Rice":2,
    "Charro Beans":1,
    "Refried Beans":1,
    "Black Beans":1,
    "Cilantro":2,
    "Jalapenos":2,
    "Lettuce":1,
    "Lime Juice":2,
    "Onion":2,
    "Tomato":2,
    "Sour Cream":2,
    "Avocado":2,
    "Salsa Roja":2,
    "Salsa Verde":2,
    "Queso":2,
    "Guacamole":2,
    "Grocery Run":2
  },
  recipes: {
    hard_shell_taco: { points:5, type:"taco", slots:["Corn Tortillas","protein","taco_topper"], exactCards:3 },
    soft_taco:       { points:5, type:"taco", slots:["Flour Tortillas","protein","taco_topper"], exactCards:3 },
    chips_and_dip:   { points:5, type:"app",  slots:["Tortilla Chips","dip"], exactCards:2 },
    pico_de_gallo:   { points:8, type:"app",  slots:["Tomato","Onion","Cilantro","Lime Juice"], exactCards:4 },
    enchiladas:      { points:10,type:"main", slots:["tortilla_any","protein","cheese","sauce_enchiladas"], exactCards:4 }
  },
  toasts: {
    publishNeeds10: "Kitchen is closed. You must publish 10+ points in one turn to open it (or use Starter Pass: Chips & Dip once per hand).",
    starterPassUsed: "Starter Pass already used this hand.",
    starterPassOk: "Starter Pass: Chips & Dip published (does not open the kitchen).",
    kitchenOpened: "Kitchen Open! Remix is now live.",
    lineInvalid: "Line is not valid. Fix the public window before ending your turn.",
    wildNeedsPick: "Grocery Run needs a pick—tell us what ingredient it’s standing in for.",
    autoPlateLocked: "Auto-Plate is only available on Beginner/Easy.",
    autoPlateNoMoves: "Auto-Plate couldn’t find complete dishes.",
    autoPlateDone: "Auto-Plate fired. Check the line-up.",
    remixOnlyWhenOpen: "Remix is only available once the kitchen is open.",
    remixCommitBlocked: "No loose ingredients—everything must be a real dish to commit.",
    roundCommitted: "Round served! Pending points committed."
  }
};

/* =========================
   Util
   ========================= */
const $ = (id)=>document.getElementById(id);
const uid = ()=>Math.random().toString(16).slice(2)+Date.now().toString(16);
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function clamp(n,min,max){return Math.max(min,Math.min(max,n));}
function sum(arr, fn){let s=0;for(const x of arr)s+=fn?fn(x):x;return s;}
function pick(arr){return arr[Math.floor(Math.random()*arr.length)];}
function deepCopy(x){return JSON.parse(JSON.stringify(x));}
function nowHM(){ const d=new Date(); return d.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"}); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m])); }
function escapeAttr(s){ return escapeHtml(s).replace(/"/g,"&quot;"); }

/* =========================
   Theme
   ========================= */
function setTheme(themeKey){
  const t = THEME_PRESETS.find(x=>x.key===themeKey) || THEME_PRESETS[0];
  state.settings.themeKey = t.key;
  document.documentElement.style.setProperty("--accent", t.accent);
  document.documentElement.style.setProperty("--accent2", hexToRgba(t.accent, .18));
}
function hexToRgba(hex, a){
  const h = hex.replace("#","").trim();
  const r = parseInt(h.slice(0,2),16);
  const g = parseInt(h.slice(2,4),16);
  const b = parseInt(h.slice(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}

/* =========================
   Deck (2 decks)
   ========================= */
function buildDeck(){
  const cards=[];
  let n=0;
  for(let deck=1; deck<=GAME.rules.numDecks; deck++){
    for(const [name,qty] of Object.entries(GAME.baseDeckCounts)){
      for(let i=0;i<qty;i++){
        cards.push({ id:`d${deck}_c${String(n++).padStart(4,"0")}`, name, wildAs:null });
      }
    }
  }
  return cards;
}
function isWild(card){ return card.name === "Grocery Run"; }

/* =========================
   Validation
   - Kitchen closed: tacos cannot use wet toppings
   ========================= */
function validateDish(dishOrCards, ctx){
  const list = Array.isArray(dishOrCards) ? dishOrCards : (dishOrCards.cards||[]);
  if(!list || list.length===0) return { valid:false, recipeKey:null, points:0, reason:"Empty" };

  if(list.some(c => isWild(c) && !c.wildAs)) return { valid:false, recipeKey:null, points:0, reason:"WildNeedsPick" };

  const eff = list.map(c => (isWild(c) ? c.wildAs : c.name));

  for(const [rk, r] of Object.entries(GAME.recipes)){
    if(eff.length !== r.exactCards) continue;

    const match = matchRecipe(eff, r.slots);
    if(!match.ok) continue;

    if(r.type==="taco"){
      if(eff.length > GAME.rules.tacoMaxCards) return { valid:false, recipeKey:rk, points:r.points, reason:"TacoCap" };
      if(ctx?.kitchenClosed){
        const usedWet = eff.some(n => GAME.roles.wet_topping.includes(n));
        if(usedWet) return { valid:false, recipeKey:rk, points:r.points, reason:"WetBlocked" };
      }
    }
    return { valid:true, recipeKey:rk, points:r.points, reason:"OK" };
  }

  return { valid:false, recipeKey:null, points:0, reason:"NoMatch" };
}

function matchRecipe(effNames, slots){
  const names = [...effNames];
  const used = new Array(names.length).fill(false);

  for(const s of slots){
    let idx = -1;

    if(GAME.roles[s]){
      for(let i=0;i<names.length;i++){
        if(used[i]) continue;
        if(GAME.roles[s].includes(names[i])) { idx=i; break; }
      }
    } else if(s==="taco_topper"){
      const pool = [...GAME.roles.dry_topping, ...GAME.roles.wet_topping];
      for(let i=0;i<names.length;i++){
        if(used[i]) continue;
        if(pool.includes(names[i])) { idx=i; break; }
      }
    } else if(s==="tortilla_any"){
      for(let i=0;i<names.length;i++){
        if(used[i]) continue;
        if(GAME.roles.tortilla_any.includes(names[i])) { idx=i; break; }
      }
    } else {
      for(let i=0;i<names.length;i++){
        if(used[i]) continue;
        if(names[i]===s) { idx=i; break; }
      }
    }

    if(idx<0) return { ok:false };
    used[idx]=true;
  }

  if(used.some(u => !u)) return { ok:false };
  return { ok:true };
}

function isLineFullyValid(){
  const ctx = { kitchenClosed: !state.hand.kitchenOpen };
  for(const d of state.hand.kitchenLine.dishes){
    const v = validateDish(d.cards, ctx);
    if(!v.valid) return false;
  }
  return true;
}

/* =========================
   State
   ========================= */
let state = null;
let currentTab = "gameplay";
let selectedHandCardIds = new Set();
let cpuBusy = false;

function mkPlayer(){
  return {
    hand: [],
    prep: { dishIndex: 0, dishes: [ mkDish(0) ] }
  };
}
function mkDish(idx, labelPrefix="Dish"){
  return { id:`dish_${uid()}`, label:`${labelPrefix} ${idx+1}`, cards:[] };
}

function defaultState(){
  const deck = shuffle(buildDeck());
  return {
    settings: {
      themeKey:"red",
      handsTarget: GAME.rules.defaultHandsTarget,
      numPlayers: 4,
      cpuDifficulty: "Easy"
    },
    match: { handIndex: 1, scores: { P1:0, P2:0, P3:0, P4:0 } },
    hand: {
      drawPile: deck,
      players: { P1: mkPlayer(), P2: mkPlayer(), P3: mkPlayer(), P4: mkPlayer() },
      kitchenLine: { dishes: [] },
      kitchenOpen: false,
      kitchenOpenedBy: null,
      starterPassUsed: { P1:false, P2:false, P3:false, P4:false },

      // Round / turn tracking
      active: "P1",
      turnInRoundIndex: 1,   // 1..numPlayers
      pendingRound: { P1:0, P2:0, P3:0, P4:0 },
      pendingDetail: { P1:[], P2:[], P3:[], P4:[] }, // shown in landscape
      publishedPtsThisTurn: 0,

      // Remix (P1 UI)
      remix: { active:false, originalLineSnapshot:[], poolCards:[], dishes:[], dishIndex:0 },

      // Log
      log: []
    }
  };
}

/* =========================
   Logging / Toast
   ========================= */
function logAction(text, dishSnapshot=null){
  const item = { id:`log_${uid()}`, tm: nowHM(), text, dish: dishSnapshot ? deepCopy(dishSnapshot) : null };
  state.hand.log.unshift(item);
  if(state.hand.log.length>14) state.hand.log.length = 14;
}
let toastTimer=null;
function toast(msg){
  const el = $("toast");
  el.textContent = msg;
  el.classList.add("on");
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>el.classList.remove("on"), 2200);
}
function prettyRecipe(key){
  const map = {
    hard_shell_taco:"Hard Shell Taco",
    soft_taco:"Soft Taco",
    chips_and_dip:"Chips & Dip",
    pico_de_gallo:"Pico de Gallo",
    enchiladas:"Enchiladas"
  };
  return map[key] || key;
}

/* =========================
   Deal / Hand
   ========================= */
function dealNewHand(){
  cancelRemixIfActive(true);

  state.hand.drawPile = shuffle(buildDeck());
  state.hand.kitchenLine.dishes = [];
  state.hand.kitchenOpen = false;
  state.hand.kitchenOpenedBy = null;
  state.hand.log = [];

  for(const pid of ["P1","P2","P3","P4"]){
    state.hand.players[pid] = mkPlayer();
    state.hand.starterPassUsed[pid] = false;
    state.hand.pendingRound[pid] = 0;
    state.hand.pendingDetail[pid] = [];
  }

  const n = state.settings.numPlayers;
  const pids = ["P1","P2","P3","P4"].slice(0,n);

  // bigger deal for 2 decks
  const dealCount = (n===2)?18 : (n===3)?16 : 14;

  for(let i=0;i<dealCount;i++){
    for(const pid of pids){
      const c = state.hand.drawPile.pop();
      if(!c) break;
      state.hand.players[pid].hand.push(c);
    }
  }

  state.hand.active = "P1";
  state.hand.turnInRoundIndex = 1;
  state.hand.publishedPtsThisTurn = 0;

  logAction("New hand dealt. P1 up first.");
  toast("New hand dealt.");
}

function nextPlayer(pid){
  const pids = ["P1","P2","P3","P4"].slice(0,state.settings.numPlayers);
  const idx = pids.indexOf(pid);
  return pids[(idx+1)%pids.length];
}
function isLastPlayerInRound(pid){
  const pids = ["P1","P2","P3","P4"].slice(0,state.settings.numPlayers);
  return pid === pids[pids.length-1];
}

/* =========================
   Draw
   ========================= */
function drawOne(pid){
  if(state.hand.drawPile.length===0) return false;
  const c = state.hand.drawPile.pop();
  state.hand.players[pid].hand.push(c);
  logAction(`${pid} drew 1 ingredient.`);
  return true;
}

/* =========================
   Publish (score as pending)
   ========================= */
function publishDishToLine(pid, dish, recipeKey){
  const lineDish = {
    id:`L_${uid()}`,
    recipeKey,
    cards: dish.cards.map(c=>({...c})),
    publishedBy: pid
  };
  state.hand.kitchenLine.dishes.push(lineDish);
  logAction(`${pid} published ${prettyRecipe(recipeKey)}.`, lineDish);
  return lineDish;
}

function publishAllFromPrep(pid){
  const p = state.hand.players[pid];
  normalizePrep(pid);

  const kitchenClosed = !state.hand.kitchenOpen;
  const ctx = { kitchenClosed };

  // Collect all valid dishes from prep (for this action)
  const candidates = [];
  for(const d of p.prep.dishes){
    if(d.cards.length===0) continue;
    const v = validateDish(d, ctx);
    if(v.valid) candidates.push({ dish:d, v });
  }

  if(candidates.length===0){
    toast("No valid dishes to publish.");
    return { published:0, totalPts:0, openedKitchen:false };
  }

  const totalPts = sum(candidates, x=>x.v.points);

  // Gate: kitchen closed => need 10+ OR Starter Pass (chips&dip only)
  if(kitchenClosed){
    const isStarterPassPlay =
      candidates.length===1 &&
      candidates[0].v.recipeKey==="chips_and_dip" &&
      totalPts === GAME.recipes.chips_and_dip.points;

    if(isStarterPassPlay){
      if(state.hand.starterPassUsed[pid]){
        toast(GAME.toasts.starterPassUsed);
        return { published:0, totalPts:0, openedKitchen:false };
      }
      // Starter Pass publishes + earns pending, but does NOT open kitchen
      state.hand.starterPassUsed[pid] = true;
      toast(GAME.toasts.starterPassOk);
    } else {
      if(totalPts < GAME.rules.publishToOpenKitchenThreshold){
        toast(GAME.toasts.publishNeeds10);
        return { published:0, totalPts:0, openedKitchen:false };
      }
      // This action opens the kitchen (global)
      state.hand.kitchenOpen = true;
      state.hand.kitchenOpenedBy = pid;
      toast(GAME.toasts.kitchenOpened);
      logAction(`${pid} opened the kitchen!`);
    }
  }

  // Publish + score to pending
  let published = 0;
  for(const item of candidates){
    publishDishToLine(pid, item.dish, item.v.recipeKey);

    state.hand.pendingRound[pid] += item.v.points;
    state.hand.pendingDetail[pid].push({ recipeKey:item.v.recipeKey, points:item.v.points });

    // clear dish cards
    item.dish.cards = [];
    published++;
    state.hand.publishedPtsThisTurn += item.v.points;
  }

  normalizePrep(pid);
  toast(published ? `Published ${published} dish${published===1?"":"es"} (+${totalPts} pending).` : "Nothing published.");

  return { published, totalPts, openedKitchen: !kitchenClosed && false };
}

/* =========================
   End Turn & Round Commit
   ========================= */
function canEndTurn(pid){
  if(state.hand.remix.active) return false;
  if(state.hand.kitchenOpen && !isLineFullyValid()) return false;
  return true;
}

function commitRound(){
  // When kitchen open, the line must be valid at commit.
  if(state.hand.kitchenOpen && !isLineFullyValid()){
    toast(GAME.toasts.lineInvalid);
    return false;
  }

  const pids = ["P1","P2","P3","P4"].slice(0,state.settings.numPlayers);
  for(const pid of pids){
    state.match.scores[pid] += (state.hand.pendingRound[pid] || 0);
    state.hand.pendingRound[pid] = 0;
    state.hand.pendingDetail[pid] = [];
  }
  logAction("Round committed (served).");
  toast(GAME.toasts.roundCommitted);
  return true;
}

function endTurn(){
  const pid = state.hand.active;

  if(!canEndTurn(pid)){
    toast(state.hand.remix.active ? "Finish Remix first." : GAME.toasts.lineInvalid);
    return;
  }

  // End-of-hand check happens after round commit, so people don't lose pending
  const last = isLastPlayerInRound(pid);

  // Advance player
  const nxt = nextPlayer(pid);
  state.hand.active = nxt;

  // Advance turn index
  if(last){
    // commit round automatically
    commitRound();
    state.hand.turnInRoundIndex = 1;
  } else {
    state.hand.turnInRoundIndex += 1;
  }

  state.hand.publishedPtsThisTurn = 0;

  render();
  persist();

  if(state.hand.active !== "P1") runCpuLoop();
  else endHandIfNeeded(); // if P1 comes back around, check for empty-out conditions
}

/* =========================
   End Hand / Penalty
   ========================= */
function endHandIfNeeded(){
  const pids = ["P1","P2","P3","P4"].slice(0,state.settings.numPlayers);

  let winner = null;
  for(const pid of pids){
    const p = state.hand.players[pid];
    const prepCount = sum(p.prep.dishes, d=>d.cards.length);
    if(p.hand.length===0 && prepCount===0){
      winner = pid; break;
    }
  }
  if(!winner) return false;

  // Ensure round pending is committed before penalties
  commitRound();

  // Apply penalties
  for(const pid of pids){
    const p = state.hand.players[pid];
    const prepCount = sum(p.prep.dishes, d=>d.cards.length);
    const penalty = (p.hand.length + prepCount) * GAME.rules.endHandPenaltyPerCard;
    state.match.scores[pid] -= penalty;
  }

  logAction(`${winner} emptied out! Hand penalties applied.`);
  toast(`${winner} emptied out! Hand penalties applied.`);
  state.match.handIndex += 1;

  if(state.match.handIndex > state.settings.handsTarget){
    showMatchSummary();
    return true;
  }

  dealNewHand();
  render();
  persist();
  return true;
}

/* =========================
   Remix (P1 UI) — only when kitchen open
   ========================= */
function canRemixNow(){
  return state.hand.active==="P1" && state.hand.kitchenOpen && !cpuBusy;
}
function startRemix(){
  if(!state.hand.kitchenOpen){ toast(GAME.toasts.remixOnlyWhenOpen); return; }
  if(state.hand.remix.active){ toast("Already remixing."); return; }
  if(state.hand.kitchenLine.dishes.length===0){ toast("Public line is empty."); return; }

  const snap = deepCopy(state.hand.kitchenLine.dishes);
  const pool = [];
  for(const d of state.hand.kitchenLine.dishes) for(const c of d.cards) pool.push({...c});

  state.hand.remix.active = true;
  state.hand.remix.originalLineSnapshot = snap;
  state.hand.remix.poolCards = pool;
  state.hand.remix.dishes = [ mkDish(0, "Remix Dish") ];
  state.hand.remix.dishIndex = 0;

  // Clear line during remix
  state.hand.kitchenLine.dishes = [];

  logAction("P1 started a Kitchen Remix.");
  toast("Remix started. Rebuild, then Commit.");
}
function cancelRemixIfActive(silent=false){
  if(!state.hand.remix.active) return;
  state.hand.kitchenLine.dishes = deepCopy(state.hand.remix.originalLineSnapshot || []);
  state.hand.remix.active = false;
  state.hand.remix.originalLineSnapshot = [];
  state.hand.remix.poolCards = [];
  state.hand.remix.dishes = [];
  state.hand.remix.dishIndex = 0;
  if(!silent) toast("Remix canceled. Original line restored.");
  logAction("Remix canceled.");
}

function commitRemix(){
  if(!state.hand.remix.active){ toast("Not in remix mode."); return; }
  if(state.hand.remix.poolCards.length>0){ toast(GAME.toasts.remixCommitBlocked); return; }

  const ctx = { kitchenClosed:false };
  const dishes = state.hand.remix.dishes.filter(d=>d.cards.length>0);
  if(dishes.length===0){ toast("You need at least one dish on the line."); return; }

  for(const d of dishes){
    const v = validateDish(d, ctx);
    if(!v.valid){
      toast(v.reason==="WildNeedsPick" ? GAME.toasts.wildNeedsPick : "Invalid dish in remix.");
      return;
    }
  }

  state.hand.kitchenLine.dishes = dishes.map(d=>{
    const v = validateDish(d, ctx);
    return { id:`L_${uid()}`, recipeKey: v.recipeKey, cards: d.cards.map(c=>({...c})), publishedBy:"Remix" };
  });

  state.hand.remix.active = false;
  state.hand.remix.originalLineSnapshot = [];
  state.hand.remix.poolCards = [];
  state.hand.remix.dishes = [];
  state.hand.remix.dishIndex = 0;

  logAction("Remix committed. New line is live.");
  toast("Remix committed.");
}

/* --- Auto-Plate (during remix; Beginner/Easy only) --- */
function autoPlateRemix(){
  if(!autoPlateAllowed()){ toast(GAME.toasts.autoPlateLocked); return; }
  const rm = state.hand.remix;
  if(!rm.active){ toast("Auto-Plate works during Remix."); return; }

  for(const d of rm.dishes){
    if(d.cards && d.cards.length){ rm.poolCards.push(...d.cards); d.cards = []; }
  }

  const ctx = { kitchenClosed:false };
  const order = ["enchiladas","pico_de_gallo","hard_shell_taco","soft_taco","chips_and_dip"];
  const plated = [];

  let safety = 0;
  while(safety++ < 280){
    let moved = false;
    for(const rk of order){
      const recipe = GAME.recipes[rk];
      const pickedCards = findCardsForRecipeFromPool(rm.poolCards, recipe, ctx);
      if(pickedCards){
        const nd = mkDish(plated.length, "Remix Dish");
        nd.cards = pickedCards;
        plated.push(nd);
        moved = true;
      }
    }
    if(!moved) break;
  }

  if(plated.length===0){ toast(GAME.toasts.autoPlateNoMoves); return; }

  rm.dishes = plated.map((d,i)=>({ ...d, label:`Remix Dish ${i+1}` }));
  rm.dishes.push(mkDish(rm.dishes.length, "Remix Dish"));
  rm.dishIndex = 0;

  logAction(`Auto-Plate created ${plated.length} dish${plated.length===1?"":"es"} in Remix.`);
  toast(GAME.toasts.autoPlateDone);
}

/* =========================
   Pool recipe picking helpers (used by remix + CPU remix)
   ========================= */
function cleanupWilds(cards){
  for(const c of cards) if(isWild(c)) c.wildAs = null;
}
function tryAssignWildsForRecipe(cards, recipe){
  const wilds = cards.filter(isWild);
  if(wilds.length===0) return true;

  let pool = [];
  for(const s of recipe.slots){
    if(s==="taco_topper") pool.push(...GAME.roles.dry_topping, ...GAME.roles.wet_topping);
    else if(s==="tortilla_any") pool.push(...GAME.roles.tortilla_any);
    else if(GAME.roles[s]) pool.push(...GAME.roles[s]);
    else pool.push(s);
  }
  pool = [...new Set(pool)];

  function backtrack(i){
    if(i>=wilds.length) return true;
    const w = wilds[i];
    for(const cand of pool){
      w.wildAs = cand;
      const eff = cards.map(card => isWild(card) ? card.wildAs : card.name);
      if(matchRecipe(eff, recipe.slots).ok) return true;
    }
    w.wildAs = null;
    return false;
  }
  return backtrack(0);
}

function findCardsForRecipeFromPool(pool, recipe, ctx){
  const slotCands = recipe.slots.map(s => {
    const cands = [];
    for(let i=0;i<pool.length;i++){
      const c = pool[i];
      if(isWild(c)) { cands.push(i); continue; }
      const name = c.name;

      if(GAME.roles[s]){
        if(GAME.roles[s].includes(name)) cands.push(i);
      } else if(s==="taco_topper"){
        if([...GAME.roles.dry_topping, ...GAME.roles.wet_topping].includes(name)) cands.push(i);
      } else if(s==="tortilla_any"){
        if(GAME.roles.tortilla_any.includes(name)) cands.push(i);
      } else {
        if(name===s) cands.push(i);
      }
    }
    return cands;
  });

  if(slotCands.some(list=>list.length===0)) return null;

  const slotOrder = [...Array(recipe.slots.length).keys()].sort((a,b)=>slotCands[a].length-slotCands[b].length);
  const used = new Set();
  const chosenIdx = new Array(recipe.slots.length).fill(undefined);

  function backtrack(pos){
    if(pos>=slotOrder.length) return true;
    const si = slotOrder[pos];
    for(const idx of slotCands[si]){
      if(used.has(idx)) continue;
      used.add(idx);
      chosenIdx[si] = idx;
      if(backtrack(pos+1)) return true;
      used.delete(idx);
      chosenIdx[si] = undefined;
    }
    return false;
  }
  if(!backtrack(0)) return null;

  const uniqIdx = Array.from(new Set(chosenIdx.filter(v=>v!==undefined)));
  if(uniqIdx.length !== recipe.exactCards) return null;

  const cards = uniqIdx.map(i=>pool[i]);

  if(!tryAssignWildsForRecipe(cards, recipe)) { cleanupWilds(cards); return null; }
  const vd = validateDish(cards, ctx);
  if(!vd.valid){ cleanupWilds(cards); return null; }

  const ids = new Set(cards.map(c=>c.id));
  const taken = [];
  for(let i=pool.length-1;i>=0;i--){
    if(ids.has(pool[i].id)) taken.push(pool.splice(i,1)[0]);
  }
  taken.reverse();
  return taken;
}

/* =========================
   CPU Remix (Difficult+)
   - Only if kitchen open
   - Only commit if max dish points >= 5
   - Master Chef: tries every eligible turn
   ========================= */
function cpuMaybeRemixLine(pid){
  const cfg = getCpuCfg();
  if(!cfg.canRemix) return false;
  if(!state.hand.kitchenOpen) return false;

  const line = state.hand.kitchenLine.dishes;
  if(!line || line.length===0) return false;

  const isMaster = (state.settings.cpuDifficulty === "Master Chef");
  if(!isMaster){
    if(line.length < 2) return false;
    if(Math.random() > cfg.remixChance) return false;
  }

  const snapshot = deepCopy(line);
  const pool = [];
  for(const d of snapshot) for(const c of d.cards) pool.push({...c});

  const ctx = { kitchenClosed:false };
  const order = ["enchiladas","pico_de_gallo","hard_shell_taco","soft_taco","chips_and_dip"];
  const plated = [];

  let safety = 0;
  while(safety++ < 300){
    let moved = false;
    for(const rk of order){
      const recipe = GAME.recipes[rk];
      const pickedCards = findCardsForRecipeFromPool(pool, recipe, ctx);
      if(pickedCards){
        plated.push({ cards: pickedCards });
        moved = true;
      }
    }
    if(!moved) break;
  }

  // max dish points >= 5
  const maxPts = plated.reduce((m,d)=>Math.max(m, (validateDish(d, ctx).points||0)), 0);

  if(pool.length !== 0 || plated.length === 0 || maxPts < 5){
    state.hand.kitchenLine.dishes = snapshot;
    return false;
  }

  for(const d of plated){
    const vd = validateDish(d, ctx);
    if(!vd.valid){
      state.hand.kitchenLine.dishes = snapshot;
      return false;
    }
  }

  state.hand.kitchenLine.dishes = plated.map(d=>{
    const vd = validateDish(d, ctx);
    return { id:`L_${uid()}`, recipeKey: vd.recipeKey, cards: d.cards.map(c=>({...c})), publishedBy: pid };
  });

  logAction(`${pid} remixed the public line${isMaster ? " (Master Chef)" : ""}.`);
  return true;
}

// Master Chef draw-boost remix (one extra attempt)
function cpuMasterChefBoostRemix(pid){
  if(state.settings.cpuDifficulty !== "Master Chef") return false;
  if(!state.hand.kitchenOpen) return false;

  const line = state.hand.kitchenLine.dishes;
  if(!line || line.length===0) return false;

  const p = state.hand.players[pid];

  const draws = Math.min(2, state.hand.drawPile.length);
  for(let i=0;i<draws;i++) drawOne(pid);

  const snapshot = deepCopy(line);
  const pool = [];
  for(const d of snapshot) for(const c of d.cards) pool.push({ ...c, _src:"line" });
  for(const c of p.hand) pool.push({ ...c, _src:"hand" });

  const ctx = { kitchenClosed:false };
  const order = ["enchiladas","pico_de_gallo","hard_shell_taco","soft_taco","chips_and_dip"];
  const plated = [];

  let safety = 0;
  while(safety++ < 350){
    let moved = false;
    for(const rk of order){
      const recipe = GAME.recipes[rk];
      const pickedCards = findCardsForRecipeFromPool(pool, recipe, ctx);
      if(pickedCards){
        plated.push({ cards: pickedCards });
        moved = true;
      }
    }
    if(!moved) break;
  }

  const remainingLine = pool.some(c => c._src === "line");
  const maxPts = plated.reduce((m,d)=>Math.max(m, (validateDish(d, ctx).points||0)), 0);

  if(remainingLine || plated.length===0 || maxPts < 5){
    state.hand.kitchenLine.dishes = snapshot;
    return false;
  }

  for(const d of plated){
    const vd = validateDish(d, ctx);
    if(!vd.valid){
      state.hand.kitchenLine.dishes = snapshot;
      return false;
    }
  }

  // Remove hand cards that were used
  const usedHandIds = new Set();
  for(const d of plated) for(const c of d.cards) if(c._src==="hand") usedHandIds.add(c.id);
  p.hand = p.hand.filter(c=>!usedHandIds.has(c.id));

  // Commit new line
  state.hand.kitchenLine.dishes = plated.map(d=>{
    const vd = validateDish(d, ctx);
    return {
      id:`L_${uid()}`,
      recipeKey: vd.recipeKey,
      cards: d.cards.map(c => { const cc = { ...c }; delete cc._src; return cc; }),
      publishedBy: pid
    };
  });

  logAction(`${pid} forced a Master Chef remix (draw boost).`);
  return true;
}

/* =========================
   CPU Draft + Publish logic
   - Kitchen closed: publish only if total >=10 OR Starter Pass chips&dip once
   - Kitchen open: publish any valid dishes
   ========================= */
function kComb(arr, k, limit=24000){
  const res = [];
  const n = arr.length;
  if(k>n) return res;
  const idx = Array.from({length:k}, (_,i)=>i);
  let count = 0;
  while(true){
    res.push(idx.map(i=>arr[i]));
    if(++count>=limit) break;
    let i=k-1;
    while(i>=0 && idx[i]===i+n-k) i--;
    if(i<0) break;
    idx[i]++;
    for(let j=i+1;j<k;j++) idx[j]=idx[j-1]+1;
  }
  return res;
}
function findOneDishFromHandCards(hand, recipeKey, ctx, comboLimit){
  const r = GAME.recipes[recipeKey];
  const idxs = [...Array(hand.length).keys()];
  const combos = kComb(idxs, r.exactCards, comboLimit);

  for(const cidx of combos){
    const cards = cidx.map(i => hand[i]);

    // assign wilds temporarily
    if(!tryAssignWildsForRecipe(cards, r)){ cleanupWilds(cards); continue; }

    const vd = validateDish(cards, ctx);
    if(vd.valid && vd.recipeKey === recipeKey){
      // success: return deep-copied cards so we can remove by id safely
      const out = cards.map(c=>({...c}));
      return { recipeKey, points: vd.points, cards: out };
    }
    cleanupWilds(cards);
  }
  return null;
}

function cpuDraftDishesFromHand(pid){
  const cfg = getCpuCfg();
  const p = state.hand.players[pid];
  const kitchenClosed = !state.hand.kitchenOpen;
  const ctx = { kitchenClosed };

  const order = ["enchiladas","pico_de_gallo","hard_shell_taco","soft_taco","chips_and_dip"];
  const handWork = p.hand.map(c=>({...c})); // working copy
  const drafted = [];
  let safety = 0;

  while(safety++ < 6){
    let best = null;
    for(const rk of order){
      const d = findOneDishFromHandCards(handWork, rk, ctx, cfg.comboLimit);
      if(d){ best = d; break; }
    }
    if(!best) break;

    // Remove used cards (by id) from working hand
    const usedIds = new Set(best.cards.map(c=>c.id));
    for(let i=handWork.length-1;i>=0;i--){
      if(usedIds.has(handWork[i].id)) handWork.splice(i,1);
    }

    drafted.push(best);

    // stop early if kitchen closed and we reached 10+
    if(kitchenClosed && sum(drafted, x=>x.points) >= GAME.rules.publishToOpenKitchenThreshold) break;
  }

  return drafted;
}

function cpuPublishTurn(pid){
  const p = state.hand.players[pid];
  const kitchenClosed = !state.hand.kitchenOpen;
  const ctx = { kitchenClosed };

  // Attempt remix first if allowed (kitchen open only)
  if(state.hand.kitchenOpen){
    let didRemix = cpuMaybeRemixLine(pid);
    if(!didRemix && state.settings.cpuDifficulty==="Master Chef"){
      didRemix = cpuMasterChefBoostRemix(pid);
    }
  }

  // Draft dishes from hand
  const drafted = cpuDraftDishesFromHand(pid);
  const totalPts = sum(drafted, d=>d.points);

  if(kitchenClosed){
    // Starter Pass option
    const starterDish = drafted.find(d=>d.recipeKey==="chips_and_dip");
    const canStarter = starterDish && !state.hand.starterPassUsed[pid];

    if(totalPts >= GAME.rules.publishToOpenKitchenThreshold){
      state.hand.kitchenOpen = true;
      state.hand.kitchenOpenedBy = pid;
      logAction(`${pid} opened the kitchen!`);
    } else if(canStarter){
      state.hand.starterPassUsed[pid] = true;
      // publish ONLY the starter dish
      publishAndScoreDish(pid, starterDish);
      removeCardsFromHand(p, starterDish.cards);
      logAction(`${pid} used Starter Pass (published Chips & Dip).`);
      return true;
    } else {
      // can't publish; draw
      drawOne(pid);
      return false;
    }
  }

  // Kitchen open: publish whatever you drafted (if any)
  if(drafted.length===0){
    drawOne(pid);
    return false;
  }

  // Publish all drafted
  for(const d of drafted){
    publishAndScoreDish(pid, d);
    removeCardsFromHand(p, d.cards);
    state.hand.publishedPtsThisTurn += d.points;
  }

  return true;
}

function publishAndScoreDish(pid, dishDraft){
  const ctx = { kitchenClosed: !state.hand.kitchenOpen };
  const v = validateDish(dishDraft.cards, ctx);
  if(!v.valid) return false;

  publishDishToLine(pid, { cards: dishDraft.cards }, v.recipeKey);
  state.hand.pendingRound[pid] += v.points;
  state.hand.pendingDetail[pid].push({ recipeKey:v.recipeKey, points:v.points });
  return true;
}

function removeCardsFromHand(player, cards){
  const usedIds = new Set(cards.map(c=>c.id));
  player.hand = player.hand.filter(c=>!usedIds.has(c.id));
}

/* =========================
   CPU Loop (auto-complete turns)
   ========================= */
function runCpuLoop(){
  if(cpuBusy) return;
  cpuBusy = true;

  const step = ()=>{
    const pid = state.hand.active;
    if(pid==="P1"){ cpuBusy=false; render(); return; }

    render();

    setTimeout(()=>{
      if(pid!==state.hand.active) { step(); return; }

      // CPUs cannot end turn with invalid line (kitchen open) — they will try one remix to fix
      if(state.hand.kitchenOpen && !isLineFullyValid()){
        // attempt cpu remix if allowed
        const cfg = getCpuCfg();
        if(cfg.canRemix){
          cpuMaybeRemixLine(pid);
          if(state.settings.cpuDifficulty==="Master Chef") cpuMasterChefBoostRemix(pid);
        }
      }

      cpuPublishTurn(pid);

      persist();
      render();

      setTimeout(()=>{
        if(pid!==state.hand.active) { step(); return; }

        // If still invalid, just draw to avoid deadlock (MVP safety)
        if(state.hand.kitchenOpen && !isLineFullyValid()){
          drawOne(pid);
        }

        endTurn();
        setTimeout(()=>step(), 150);
      }, 520);

    }, 520);
  };

  step();
}

/* =========================
   Prep (P1 private drafting)
   ========================= */
function normalizePrep(pid){
  const p = state.hand.players[pid];
  if(p.prep.dishes.length===0){ p.prep.dishes.push(mkDish(0)); p.prep.dishIndex=0; }
  p.prep.dishIndex = clamp(p.prep.dishIndex, 0, p.prep.dishes.length-1);
}

/* =========================
   UI
   ========================= */
function updateTop(){
  const pid = state.hand.active;
  $("activePlayerLabel").textContent = pid;

  const phaseName = state.hand.kitchenOpen ? "Kitchen Open" : "Not Seated Yet";
  const phaseHelp = state.hand.kitchenOpen
    ? "Line must be valid at end of each turn. Remix is live."
    : `Kitchen closed. Publish ${GAME.rules.publishToOpenKitchenThreshold}+ points in one turn to open it. Starter Pass: Chips & Dip once per hand.`;

  $("phaseName").textContent = phaseName;
  $("phaseHelp").textContent = phaseHelp;

  $("handIndex").textContent = state.match.handIndex;
  $("handsTarget").textContent = state.settings.handsTarget;

  $("turnIndex").textContent = state.hand.turnInRoundIndex;
  $("turnsPerRound").textContent = state.settings.numPlayers;

  $("drawCount").textContent = state.hand.drawPile.length;

  const pids = ["P1","P2","P3","P4"].slice(0,state.settings.numPlayers);
  $("scoreByPlayers").innerHTML = pids.map(p=>`<span class="mono">${p}: ${state.match.scores[p]}</span>`).join(" • ");
  $("scoreNow").textContent = state.match.scores[pid];

  $("pendingNow").textContent = state.hand.pendingRound["P1"] || 0;
  $("pendingByPlayers").innerHTML = pids.map(p=>`<span class="mono">${p}: ${state.hand.pendingRound[p]||0}</span>`).join(" • ");

  // Landscape breakdown (B)
  const breakdownLines = pids.map(p=>{
    const arr = state.hand.pendingDetail[p] || [];
    if(arr.length===0) return `<div><span class="mono">${p}</span>: <span class="muted2">—</span></div>`;
    const txt = arr.map(x=>`${prettyRecipe(x.recipeKey)} (+${x.points})`).join(", ");
    return `<div><span class="mono">${p}</span>: ${escapeHtml(txt)}</div>`;
  }).join("");
  $("pendingBreakdown").innerHTML = breakdownLines;

  const yourTurn = (pid==="P1");
  $("turnBadge").textContent = yourTurn ? "Your turn" : `${pid} playing…`;
  $("turnBadge").className = "badge " + (yourTurn ? "good" : "warn");

  $("btnDraw").disabled = !yourTurn || cpuBusy || state.hand.drawPile.length===0 || state.hand.remix.active;
  $("btnPublishAll").disabled = !yourTurn || cpuBusy || state.hand.remix.active;
  $("btnEndTurn").disabled = !yourTurn || cpuBusy;

  if(state.hand.remix.active){
    $("actionHint").textContent = "Remix active: rebuild from the pool, then Commit (no loose ingredients).";
  } else {
    $("actionHint").textContent = state.hand.kitchenOpen
      ? `Kitchen Open. End Turn requires valid public line. CPU: ${state.settings.cpuDifficulty}`
      : `Kitchen Closed. Publish ${GAME.rules.publishToOpenKitchenThreshold}+ to open (or Starter Pass: Chips & Dip). CPU: ${state.settings.cpuDifficulty}`;
  }
}

function renderRules(){
  $("rulesBody").innerHTML = `
    <details class="acc" open>
      <summary>
        <span>Menu (valid dishes)</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody">
        <div class="tiles">
          <div class="tile small"><div class="name">Hard Shell Taco</div><div class="tag">5 pts • Corn + Protein + 1 Topper</div></div>
          <div class="tile small"><div class="name">Soft Taco</div><div class="tag">5 pts • Flour + Protein + 1 Topper</div></div>
          <div class="tile small"><div class="name">Chips & Dip</div><div class="tag">5 pts • Chips + 1 Dip</div></div>
          <div class="tile small"><div class="name">Pico de Gallo</div><div class="tag">8 pts • Tomato + Onion + Cilantro + Lime</div></div>
          <div class="tile small"><div class="name">Enchiladas</div><div class="tag">10 pts • Tortilla + Protein + Cheese + Sauce</div></div>
        </div>
      </div>
    </details>

    <details class="acc">
      <summary>
        <span>Flow</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody muted">
        <div><b>Draft</b> privately in Prep.</div>
        <div style="margin-top:6px"><b>Publish</b> to the public window. Publishing earns <b>pending</b> points.</div>
        <div style="margin-top:6px"><b>Round Commit</b> happens automatically after the last player ends their turn.</div>
        <div style="margin-top:6px"><b>Kitchen Open</b>: once opened, the public window must be valid at end of turn and can be remixed.</div>
      </div>
    </details>

    <details class="acc">
      <summary>
        <span>Gates & limits</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody muted">
        <div><b>Open kitchen:</b> publish <b>${GAME.rules.publishToOpenKitchenThreshold}+ points</b> in one turn.</div>
        <div style="margin-top:6px"><b>Starter Pass:</b> before kitchen opens, you may publish <b>one Chips & Dip</b> per hand (does not open kitchen).</div>
        <div style="margin-top:6px"><b>Taco cap:</b> max <b>${GAME.rules.tacoMaxCards}</b> cards per taco.</div>
        <div style="margin-top:6px"><b>Wet toppings:</b> blocked while kitchen is closed.</div>
        <div style="margin-top:6px"><b>End-of-hand penalty:</b> -1 per remaining card (hand + prep).</div>
      </div>
    </details>

    <details class="acc">
      <summary>
        <span>CPU</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody muted">
        <div><b>Remix:</b> Difficult + Master Chef</div>
        <div style="margin-top:6px"><b>Master Chef:</b> aggressive remix only if it yields <b>≥5</b> points; will draw-boost once if needed.</div>
        <div style="margin-top:6px"><b>Auto-Plate:</b> Beginner + Easy (P1 remix helper)</div>
      </div>
    </details>
  `;
}

function render(){
  updateTop();
  renderRules();
  syncFooterTabs();

  if(currentTab==="gameplay") renderGameplay();
  else if(currentTab==="prep") renderPrep();
  else if(currentTab==="scores") renderScores();
  else if(currentTab==="settings") renderSettings();
}

function syncFooterTabs(){
  for(const t of document.querySelectorAll(".tab")){
    t.classList.toggle("on", t.dataset.tab===currentTab);
  }
  const titleMap = {
    gameplay: ["Gameplay","Public window + remix + CPU plays"],
    prep: ["Prep","Your private drafting carousel (P1 only)"],
    scores: ["Scores","Match score + penalties"],
    settings: ["Settings","Theme, players, hands, CPU difficulty"]
  };
  $("panelTitle").textContent = titleMap[currentTab][0];
  $("panelSub").textContent = titleMap[currentTab][1];
}

/* --- Gameplay --- */
function renderGameplay(){
  const body = $("panelBody");

  if(state.hand.remix.active){
    renderRemixGameplay(body);
    return;
  }

  const yourTurn = state.hand.active==="P1" && !cpuBusy;

  body.innerHTML = `
    <div class="btnrow" style="margin-bottom:10px">
      <button id="btnStartRemix" class="primary">Start Remix</button>
      <button id="btnValidateLine" class="ghost">Validate Line</button>
    </div>

    <details class="acc" open>
      <summary>
        <span>Public Line (Window)</span>
        <span class="sumHint">${state.hand.kitchenLine.dishes.length} dish${state.hand.kitchenLine.dishes.length===1?"":"es"}</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody">
        <div class="muted">${state.hand.kitchenOpen ? "Kitchen open: line must be valid at end of turn." : "Kitchen closed: publish 10+ to open (Starter Pass allowed)."} </div>
        <div class="hr"></div>
        <div id="lineList"></div>
      </div>
    </details>

    <details class="acc">
      <summary>
        <span>Kitchen Cam</span>
        <span class="sumHint">Latest actions</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody">
        <div class="feed" id="feed"></div>
      </div>
    </details>
  `;

  $("btnStartRemix").disabled = !(yourTurn && canRemixNow());
  $("btnStartRemix").onclick = ()=>{ startRemix(); render(); persist(); };

  $("btnValidateLine").onclick = ()=>{
    if(!state.hand.kitchenOpen){
      toast("Kitchen is closed — line validity is still enforced for published dishes, but remix gating is off.");
      return;
    }
    toast(isLineFullyValid() ? "Line is valid ✅" : "Line is invalid ❌");
  };

  renderPublicLineList($("lineList"));
  renderFeed($("feed"));
}

function renderPublicLineList(container){
  const dishes = state.hand.kitchenLine.dishes;
  if(dishes.length===0){
    container.innerHTML = `<div class="muted">Public line is empty. Publish from Prep to start the window.</div>`;
    return;
  }
  const ctx = { kitchenClosed: !state.hand.kitchenOpen };
  container.innerHTML = dishes.map(d=>{
    const pts = GAME.recipes[d.recipeKey]?.points ?? 0;
    const ok = validateDish(d.cards, ctx).valid;
    const badge = ok ? `<span class="badge good">Valid</span>` : `<span class="badge bad">Invalid</span>`;
    const cards = d.cards.map(c=>{
      const name = c.name + (isWild(c) && c.wildAs ? ` (as ${c.wildAs})` : "");
      return `<div class="tile small"><div class="name">${escapeHtml(name)}</div></div>`;
    }).join("");
    return `
      <div class="dishShell" style="margin-bottom:10px">
        <div class="dishHead">
          <div style="min-width:0">
            <div class="dishTitle">${prettyRecipe(d.recipeKey)} <span class="muted">(+${pts})</span></div>
            <div class="dishMeta">Published by <span class="mono">${escapeHtml(d.publishedBy)}</span></div>
          </div>
          ${badge}
        </div>
        <div class="tiles">${cards}</div>
      </div>
    `;
  }).join("");
}

function renderFeed(container){
  const log = state.hand.log || [];
  if(log.length===0){
    container.innerHTML = `<div class="muted">No moves yet. CPU activity will appear here.</div>`;
    return;
  }
  container.innerHTML = log.map(item=>{
    const dish = item.dish;
    const preview = dish?.cards?.length
      ? `<div class="tiles" style="margin-top:8px">${dish.cards.slice(0,6).map(c=>{
          const name = c.name + (isWild(c) && c.wildAs ? ` (as ${c.wildAs})` : "");
          return `<div class="tile small"><div class="name">${escapeHtml(name)}</div></div>`;
        }).join("")}</div>`
      : "";
    return `
      <div class="feedItem">
        <div class="feedTop">
          <div class="txt">${escapeHtml(item.text)}</div>
          <div class="tm">${escapeHtml(item.tm)}</div>
        </div>
        ${preview}
      </div>
    `;
  }).join("");
}

/* --- Remix UI --- */
function normalizeRemix(){
  const rm = state.hand.remix;
  if(!rm.active) return;
  if(rm.dishes.length===0){
    rm.dishes = [ mkDish(0, "Remix Dish") ];
    rm.dishIndex = 0;
  }
  rm.dishIndex = clamp(rm.dishIndex, 0, rm.dishes.length-1);
}
function renderRemixGameplay(body){
  const rm = state.hand.remix;
  normalizeRemix();

  const dish = rm.dishes[rm.dishIndex];
  const ctx = { kitchenClosed:false };
  const vd = validateDish(dish, ctx);

  let badgeClass = "badge";
  let badgeText = "Draft";
  if(dish.cards.length===0){ badgeClass += " warn"; badgeText="Empty"; }
  else if(vd.valid){ badgeClass += " good"; badgeText=`Valid • ${prettyRecipe(vd.recipeKey)} (+${vd.points})`; }
  else { badgeClass += " bad"; badgeText="Invalid"; }

  const apOk = autoPlateAllowed();

  body.innerHTML = `
    <div class="btnrow" style="margin-bottom:10px">
      <button id="btnCommitRemix" class="primary">Commit Remix</button>
      <button id="btnCancelRemix" class="danger">Cancel Remix</button>
      <button id="btnAutoPlate" class="ghost">${apOk ? "Auto-Plate" : "Auto-Plate (Locked)"}</button>
      <button id="btnNewRemixDish">+ New Dish</button>
      <button id="btnClearRemixDish" class="ghost">Clear Dish</button>
      <button id="btnDeleteRemixDish" class="danger">Delete Dish</button>
    </div>

    <div class="muted">
      Commit requires: pool empty + all dishes valid.<br/>
      <span class="muted2">Auto-Plate: <b>${apOk ? "Enabled" : "Disabled"}</b></span>
    </div>

    <div class="hr"></div>

    <div class="remixGrid">
      <div class="pool">
        <div class="poolHead">
          <div>
            <div class="dishTitle">Remix Pool</div>
            <div class="dishMeta"><span class="mono">${rm.poolCards.length}</span> cards waiting</div>
          </div>
          <div class="badge ${rm.poolCards.length===0 ? "good" : "warn"}">${rm.poolCards.length===0 ? "Empty ✅" : "Not empty"}</div>
        </div>
        <div class="tiles" id="poolTiles"></div>
        <div class="hint">Tap a pool card to add it to the current remix dish.</div>
      </div>

      <div class="dishShell" id="remixDishShell">
        <div class="dishHead">
          <div style="min-width:0">
            <div class="dishTitle">${escapeHtml(dish.label)}</div>
            <div class="dishMeta">Slide ${rm.dishIndex+1} of ${rm.dishes.length}</div>
          </div>
          <div class="${badgeClass}">${badgeText}</div>
        </div>

        <div class="tiles" id="remixDishTiles"></div>
        <div class="hint">Tap a dish card to return it to the pool. Tap Grocery Run to choose its substitute.</div>

        <div class="hr"></div>

        <div class="btnrow">
          <button id="btnPrevR" class="ghost">◀</button>
          <button id="btnNextR" class="ghost">▶</button>
        </div>
      </div>
    </div>
  `;

  const poolTiles = $("poolTiles");
  poolTiles.innerHTML = "";
  if(rm.poolCards.length===0){
    poolTiles.innerHTML = `<div class="muted">Pool is empty. Commit when dishes are valid.</div>`;
  } else {
    const sortedPool = [...rm.poolCards].sort((a,b)=>a.name.localeCompare(b.name));
    for(const c of sortedPool){
      const div = document.createElement("div");
      div.className = "tile";
      div.innerHTML = `
        <div class="chip ${isWild(c) ? "accent" : ""}"></div>
        <div class="name">${escapeHtml(c.name)}${isWild(c) ? `<div class="tag">${c.wildAs ? `as: ${escapeHtml(c.wildAs)}` : "Tap to choose"}</div>` : ""}</div>
        <div class="tag">tap to add</div>
      `;
      div.onclick = ()=>{
        const idx = rm.poolCards.findIndex(x=>x.id===c.id);
        if(idx<0) return;
        const card = rm.poolCards.splice(idx,1)[0];
        dish.cards.push(card);
        render();
      };
      poolTiles.appendChild(div);
    }
  }

  const dishTiles = $("remixDishTiles");
  dishTiles.innerHTML = "";
  for(const c of dish.cards){
    const div = document.createElement("div");
    div.className = "tile";
    div.innerHTML = `
      <div class="chip ${isWild(c) ? "accent" : ""}"></div>
      <div class="name">${escapeHtml(c.name)}${isWild(c) ? `<div class="tag">${c.wildAs ? `as: ${escapeHtml(c.wildAs)}` : "Tap to choose"}</div>` : ""}</div>
      <div class="tag">tap to return</div>
    `;
    div.onclick = ()=>{
      if(isWild(c)){ openWildPicker(c, ()=>render()); return; }
      dish.cards = dish.cards.filter(x=>x.id!==c.id);
      rm.poolCards.push(c);
      render();
    };
    dishTiles.appendChild(div);
  }

  $("btnAutoPlate").disabled = !apOk;
  $("btnAutoPlate").onclick = ()=>{ autoPlateRemix(); persist(); render(); };

  $("btnCommitRemix").onclick = ()=>{ commitRemix(); persist(); render(); };
  $("btnCancelRemix").onclick = ()=>confirmModal("Cancel remix?", "Restore the original public line exactly as it was.", "Cancel Remix", ()=>{
    cancelRemixIfActive();
    persist();
    render();
  });

  $("btnNewRemixDish").onclick = ()=>{
    rm.dishes.push(mkDish(rm.dishes.length, "Remix Dish"));
    rm.dishIndex = rm.dishes.length-1;
    toast("New remix dish added.");
    persist(); render();
  };
  $("btnClearRemixDish").onclick = ()=>{
    if(dish.cards.length===0){ toast("Dish is already empty."); return; }
    rm.poolCards.push(...dish.cards);
    dish.cards = [];
    toast("Dish cleared back to pool.");
    persist(); render();
  };
  $("btnDeleteRemixDish").onclick = ()=>{
    if(rm.dishes.length===1){ toast("You need at least one remix dish."); return; }
    confirmModal("Delete remix dish?", "Cards from this dish go back to the pool.", "Delete Dish", ()=>{
      rm.poolCards.push(...dish.cards);
      rm.dishes.splice(rm.dishIndex, 1);
      rm.dishes.forEach((d,i)=>d.label=`Remix Dish ${i+1}`);
      rm.dishIndex = clamp(rm.dishIndex, 0, rm.dishes.length-1);
      toast("Remix dish deleted.");
      persist(); render();
    });
  };

  $("btnPrevR").onclick = ()=>{ rm.dishIndex = clamp(rm.dishIndex-1, 0, rm.dishes.length-1); render(); };
  $("btnNextR").onclick = ()=>{ rm.dishIndex = clamp(rm.dishIndex+1, 0, rm.dishes.length-1); render(); };
}

/* --- Prep --- */
function renderPrep(){
  const body = $("panelBody");
  const yourTurn = state.hand.active==="P1" && !cpuBusy;

  if(state.hand.remix.active){
    body.innerHTML = `<div class="muted">Prep is locked while Remix is active. Finish Remix in Gameplay.</div>`;
    return;
  }

  const p = state.hand.players.P1;
  normalizePrep("P1");
  const dish = p.prep.dishes[p.prep.dishIndex];

  const ctx = { kitchenClosed: !state.hand.kitchenOpen };
  const vd = validateDish(dish, ctx);

  let badgeClass = "badge";
  let badgeText = "Draft";
  if(dish.cards.length===0){ badgeClass += " warn"; badgeText="Empty"; }
  else if(vd.valid){ badgeClass += " good"; badgeText=`Valid • ${prettyRecipe(vd.recipeKey)} (+${vd.points})`; }
  else { badgeClass += " bad"; badgeText="Incomplete"; }

  body.innerHTML = `
    <div class="btnrow" style="margin-bottom:10px">
      <button id="btnMoveSel" class="primary">Move Selected → Dish</button>
      <button id="btnClearSel" class="ghost">Clear Selection</button>
      <button id="btnAutoPick" class="ghost">Auto-Pick Grocery Run</button>
    </div>

    <details class="acc" open>
      <summary>
        <span>Your Hand</span>
        <span class="sumHint">Tap to select</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody">
        <div class="tiles" id="handTiles"></div>
      </div>
    </details>

    <details class="acc" open>
      <summary>
        <span>Your Prep Carousel</span>
        <span class="sumHint">Slide ${p.prep.dishIndex+1} / ${p.prep.dishes.length}</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody">
        <div class="dishShell">
          <div class="dishHead">
            <div style="min-width:0">
              <div class="dishTitle">${escapeHtml(dish.label)}</div>
              <div class="dishMeta">Draft privately. Publish from top buttons.</div>
            </div>
            <div class="${badgeClass}">${badgeText}</div>
          </div>

          <div class="btnrow">
            <button id="btnPrev" class="ghost">◀</button>
            <button id="btnNext" class="ghost">▶</button>
            <button id="btnNewDish">+ New Dish</button>
            <button id="btnClearDish" class="ghost">Clear Dish</button>
            <button id="btnDeleteDish" class="danger">Delete</button>
          </div>

          <div class="hr"></div>
          <div class="tiles" id="prepTiles"></div>
          <div class="hint">Tap a dish card to send it back to your hand. Tap Grocery Run to choose its substitute.</div>
        </div>
      </div>
    </details>

    <div class="muted">Kitchen: <b>${state.hand.kitchenOpen ? "Open" : "Closed"}</b> • Starter Pass used: <b>${state.hand.starterPassUsed.P1 ? "Yes" : "No"}</b></div>
  `;

  const handTiles = $("handTiles");
  handTiles.innerHTML = "";
  const hand = [...p.hand].sort((a,b)=>a.name.localeCompare(b.name));
  for(const c of hand){
    const sel = selectedHandCardIds.has(c.id);
    const div = document.createElement("div");
    div.className = "tile" + (sel ? " sel" : "");
    div.innerHTML = `
      <div class="chip ${sel ? "accent" : ""}"></div>
      <div class="name">${escapeHtml(c.name)}${isWild(c) && c.wildAs ? `<div class="tag">as: ${escapeHtml(c.wildAs)}</div>` : (isWild(c) ? `<div class="tag">Tap to choose</div>` : "")}</div>
    `;
    div.onclick = ()=>{
      if(!yourTurn) return;
      if(selectedHandCardIds.has(c.id)) selectedHandCardIds.delete(c.id);
      else selectedHandCardIds.add(c.id);
      render();
    };
    handTiles.appendChild(div);
  }

  const prepTiles = $("prepTiles");
  prepTiles.innerHTML = "";
  for(const c of dish.cards){
    const div = document.createElement("div");
    div.className = "tile";
    div.innerHTML = `
      <div class="chip ${isWild(c) ? "accent" : ""}"></div>
      <div class="name">${escapeHtml(c.name)}${isWild(c) ? `<div class="tag">${c.wildAs ? `as: ${escapeHtml(c.wildAs)}` : "Tap to choose"}</div>` : ""}</div>
      <div class="tag">tap to remove</div>
    `;
    div.onclick = ()=>{
      if(!yourTurn) return;
      if(isWild(c)){ openWildPicker(c, ()=>render()); return; }
      dish.cards = dish.cards.filter(x=>x.id!==c.id);
      p.hand.push(c);
      render();
    };
    prepTiles.appendChild(div);
  }

  $("btnMoveSel").disabled = !yourTurn;
  $("btnMoveSel").onclick = ()=>{
    if(!yourTurn) return;
    const moved = moveSelectedHandToCurrentDish();
    if(moved===0) toast("Select at least one card.");
    persist();
    render();
  };

  $("btnClearSel").onclick = ()=>{ selectedHandCardIds.clear(); render(); };
  $("btnAutoPick").onclick = ()=>{
    if(!yourTurn) return;
    for(const c of p.hand) if(isWild(c) && !c.wildAs) c.wildAs = pick(GAME.roles.dip);
    toast("Auto-picked Grocery Run (you can change it).");
    persist(); render();
  };

  $("btnPrev").onclick = ()=>{ p.prep.dishIndex = clamp(p.prep.dishIndex-1, 0, p.prep.dishes.length-1); render(); };
  $("btnNext").onclick = ()=>{ p.prep.dishIndex = clamp(p.prep.dishIndex+1, 0, p.prep.dishes.length-1); render(); };
  $("btnNewDish").onclick = ()=>{
    if(!yourTurn) return;
    p.prep.dishes.push(mkDish(p.prep.dishes.length));
    p.prep.dishIndex = p.prep.dishes.length-1;
    toast("New dish added.");
    persist(); render();
  };
  $("btnClearDish").onclick = ()=>{
    if(!yourTurn) return;
    if(dish.cards.length===0){ toast("Dish is already empty."); return; }
    p.hand.push(...dish.cards);
    dish.cards = [];
    toast("Dish cleared back to your hand.");
    persist(); render();
  };
  $("btnDeleteDish").onclick = ()=>{
    if(!yourTurn) return;
    if(p.prep.dishes.length===1){ toast("You need at least one dish slide."); return; }
    confirmModal("Delete dish?", "Returns its cards to your hand.", "Delete Dish", ()=>{
      p.hand.push(...dish.cards);
      p.prep.dishes.splice(p.prep.dishIndex, 1);
      p.prep.dishes.forEach((d,i)=>d.label=`Dish ${i+1}`);
      p.prep.dishIndex = clamp(p.prep.dishIndex, 0, p.prep.dishes.length-1);
      toast("Dish deleted.");
      persist(); render();
    });
  };
}

function moveSelectedHandToCurrentDish(){
  const p = state.hand.players.P1;
  normalizePrep("P1");
  const dish = p.prep.dishes[p.prep.dishIndex];

  const selected = new Set(selectedHandCardIds);
  if(selected.size===0) return 0;

  const toMove = [];
  for(const id of selected){
    const idx = p.hand.findIndex(c=>c.id===id);
    if(idx>=0) toMove.push(p.hand[idx]);
  }

  let moved = 0;
  for(const c of toMove){
    const idx = p.hand.findIndex(x=>x.id===c.id);
    if(idx>=0){
      dish.cards.push(p.hand.splice(idx,1)[0]);
      moved++;
    }
  }

  selectedHandCardIds.clear();
  return moved;
}

/* --- Scores --- */
function renderScores(){
  const body = $("panelBody");
  const pids = ["P1","P2","P3","P4"].slice(0,state.settings.numPlayers);

  body.innerHTML = `
    <div class="btnrow" style="margin-bottom:10px">
      <button id="btnEndHandAdmin" class="danger">End Hand (Admin)</button>
      <button id="btnNewMatch" class="ghost">New Match</button>
    </div>
    <div class="muted">Match score is committed at end of each round. End-of-hand penalty is -1 per remaining card (hand + prep).</div>
    <div class="hr"></div>
    <div id="scoreAcc"></div>
  `;

  const acc = $("scoreAcc");
  acc.innerHTML = pids.map(pid=>{
    const p = state.hand.players[pid];
    const prepCount = sum(p.prep.dishes, d=>d.cards.length);
    const penaltyIfEndedNow = (p.hand.length + prepCount) * GAME.rules.endHandPenaltyPerCard;
    return `
      <details class="acc">
        <summary>
          <span>${pid} • Match ${state.match.scores[pid]}</span>
          <span class="sumHint">cards left ${p.hand.length + prepCount} (pen ${penaltyIfEndedNow})</span>
          <span class="chev">▾</span>
        </summary>
        <div class="accBody muted">
          <div><b>Hand:</b> ${p.hand.length} • <b>Prep:</b> ${prepCount}</div>
          <div style="margin-top:6px"><b>Pending this round:</b> ${state.hand.pendingRound[pid]||0}</div>
        </div>
      </details>
    `;
  }).join("");

  $("btnEndHandAdmin").onclick = ()=>{
    confirmModal("End hand now?", "Commits round pending, applies penalties, then deals a new hand.", "End Hand", ()=>{
      endHandIfNeeded() || (()=>{ // if no natural winner, force end
        commitRound();
        const pids2 = ["P1","P2","P3","P4"].slice(0,state.settings.numPlayers);
        for(const pid of pids2){
          const p = state.hand.players[pid];
          const prepCount = sum(p.prep.dishes, d=>d.cards.length);
          const penalty = (p.hand.length + prepCount) * GAME.rules.endHandPenaltyPerCard;
          state.match.scores[pid] -= penalty;
        }
        state.match.handIndex += 1;
        if(state.match.handIndex > state.settings.handsTarget) showMatchSummary();
        else dealNewHand();
        persist(); render();
      })();
    });
  };

  $("btnNewMatch").onclick = ()=>{
    confirmModal("Start a new match?", "Resets match scores and returns to hand 1.", "New Match", ()=>{
      const keep = {
        themeKey: state.settings.themeKey,
        handsTarget: state.settings.handsTarget,
        numPlayers: state.settings.numPlayers,
        cpuDifficulty: state.settings.cpuDifficulty
      };
      state = defaultState();
      state.settings = keep;
      setTheme(state.settings.themeKey);
      state.settings.handsTarget = clamp(keep.handsTarget, GAME.rules.handsTargetMin, GAME.rules.handsTargetMax);
      dealNewHand();
      persist(); render();
    });
  };
}

/* --- Settings --- */
function renderSettings(){
  const body = $("panelBody");

  body.innerHTML = `
    <details class="acc" open>
      <summary>
        <span>Display</span>
        <span class="sumHint">Theme</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody">
        <div class="field">
          <div class="label">Secondary theme color</div>
          <select id="selTheme"></select>
        </div>
      </div>
    </details>

    <details class="acc" open>
      <summary>
        <span>Match</span>
        <span class="sumHint">Hands + players</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody">
        <div class="field">
          <div class="label">Hands (1–12)</div>
          <input id="inpHands" type="number" min="${GAME.rules.handsTargetMin}" max="${GAME.rules.handsTargetMax}" value="${state.settings.handsTarget}">
        </div>

        <div class="field">
          <div class="label">Players (2–4)</div>
          <select id="selPlayers">
            <option value="2">2 players (deal 18)</option>
            <option value="3">3 players (deal 16)</option>
            <option value="4">4 players (deal 14)</option>
          </select>
        </div>

        <div class="btnrow">
          <button id="btnDeal" class="primary">Deal New Hand</button>
        </div>
      </div>
    </details>

    <details class="acc" open>
      <summary>
        <span>CPU Difficulty</span>
        <span class="sumHint">${escapeHtml(state.settings.cpuDifficulty)}</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody">
        <div class="field">
          <div class="label">Difficulty</div>
          <select id="selCpuDiff">
            ${CPU_DIFFICULTIES.map(d=>`<option value="${escapeAttr(d)}">${escapeHtml(d)}</option>`).join("")}
          </select>
        </div>
        <div class="muted">
          <div><b>Remix:</b> Difficult + Master Chef</div>
          <div style="margin-top:6px"><b>Master Chef:</b> aggressive remix only if ≥5 pts; draw-boost once</div>
          <div style="margin-top:6px"><b>Auto-Plate:</b> Beginner + Easy (P1 remix helper)</div>
        </div>
      </div>
    </details>

    <details class="acc">
      <summary>
        <span>Danger Zone</span>
        <span class="sumHint">Hard reset</span>
        <span class="chev">▾</span>
      </summary>
      <div class="accBody">
        <div class="btnrow">
          <button id="btnReset" class="danger">Hard Reset</button>
        </div>
      </div>
    </details>

    <div class="muted"><b>Version</b>: <span class="mono">${APP_VERSION}</span></div>
  `;

  const selTheme = $("selTheme");
  selTheme.innerHTML = THEME_PRESETS.map(t=>`<option value="${t.key}">${escapeHtml(t.label)}</option>`).join("");
  selTheme.value = state.settings.themeKey;
  selTheme.onchange = ()=>{ setTheme(selTheme.value); persist(); render(); };

  const inpHands = $("inpHands");
  inpHands.onchange = ()=>{
    state.settings.handsTarget = clamp(parseInt(inpHands.value||"12",10), GAME.rules.handsTargetMin, GAME.rules.handsTargetMax);
    persist(); render();
  };

  const selPlayers = $("selPlayers");
  selPlayers.value = String(state.settings.numPlayers);
  selPlayers.onchange = ()=>{
    state.settings.numPlayers = clamp(parseInt(selPlayers.value,10), 2, 4);
    persist(); render();
  };

  const selCpuDiff = $("selCpuDiff");
  selCpuDiff.value = state.settings.cpuDifficulty || "Easy";
  selCpuDiff.onchange = ()=>{
    state.settings.cpuDifficulty = selCpuDiff.value;
    toast(`CPU set to ${state.settings.cpuDifficulty}.`);
    persist(); render();
  };

  $("btnDeal").onclick = ()=>{
    confirmModal("Deal a new hand?", "Resets the current hand. Match scores remain.", "Deal", ()=>{
      dealNewHand();
      persist(); render();
      if(state.hand.active!=="P1") runCpuLoop();
    });
  };

  $("btnReset").onclick = ()=>{
    confirmModal("Hard Reset?", "Wipes saved state and starts fresh.", "Reset", ()=>{
      localStorage.removeItem("tacoRia_state_v2");
      state = defaultState();
      setTheme(state.settings.themeKey);
      dealNewHand();
      persist(); render();
    });
  };
}

/* =========================
   Modals
   ========================= */
function openDrawModal(){
  if(state.hand.active!=="P1" || cpuBusy) return;
  if(state.hand.remix.active){ toast("Finish remix first."); return; }
  if(state.hand.drawPile.length===0){ toast("No cards left to draw."); return; }

  $("modalTitle").textContent = "Draw (pick a blank tile)";
  let chosen = -1;

  $("modalBody").innerHTML = `
    <div class="muted">Tap one blank, then hit <b>Draw</b>. (Your pick is just for the vibe — the draw is random.)</div>
    <div class="hr"></div>
    <div class="blankGrid" id="blankGrid">
      <div class="blank" data-i="0">BLANK</div>
      <div class="blank" data-i="1">BLANK</div>
      <div class="blank" data-i="2">BLANK</div>
    </div>
  `;

  const grid = $("blankGrid");
  grid.onclick = (e)=>{
    const el = e.target.closest(".blank");
    if(!el) return;
    chosen = parseInt(el.dataset.i,10);
    for(const b of grid.querySelectorAll(".blank")){
      b.classList.toggle("on", parseInt(b.dataset.i,10)===chosen);
    }
    $("btnConfirmDraw").disabled = chosen<0;
  };

  $("modalFoot").innerHTML = `
    <button class="ghost" id="btnCancelDraw">Cancel</button>
    <button class="primary" id="btnConfirmDraw" disabled>Draw</button>
  `;

  $("btnCancelDraw").onclick = ()=>closeModal();
  $("btnConfirmDraw").onclick = ()=>{
    closeModal();
    const ok = drawOne("P1");
    if(ok){ toast("Drew 1 ingredient."); persist(); render(); }
  };

  $("modalWrap").classList.add("on");
}

function openWildPicker(card, onDone){
  if(state.hand.active!=="P1" || cpuBusy){ toast("Only P1 can set Grocery Run (MVP)."); return; }

  $("modalTitle").textContent = "Grocery Run (pick a substitute)";
  const options = [
    ...GAME.roles.protein,
    ...GAME.roles.tortilla_any,
    ...GAME.roles.cheese,
    ...GAME.roles.dip,
    ...GAME.roles.dry_topping,
    "Lime Juice","Tomato","Onion","Cilantro"
  ];
  const uniq = [...new Set(options)].sort((a,b)=>a.localeCompare(b));

  $("modalBody").innerHTML = `
    <div class="muted">Choose what <b>Grocery Run</b> stands in for (this card only).</div>
    <div class="hr"></div>
    <div class="field">
      <div class="label">Substitute as</div>
      <select id="wildSel">${uniq.map(n=>`<option value="${escapeAttr(n)}">${escapeHtml(n)}</option>`).join("")}</select>
    </div>
  `;

  const sel = $("wildSel");
  sel.value = card.wildAs || uniq[0];

  $("modalFoot").innerHTML = `
    <button class="ghost" id="wildCancel">Cancel</button>
    <button class="primary" id="wildSave">Save</button>
  `;
  $("wildCancel").onclick = ()=>closeModal();
  $("wildSave").onclick = ()=>{
    card.wildAs = sel.value;
    closeModal();
    toast("Grocery Run set.");
    persist();
    onDone && onDone();
  };

  $("modalWrap").classList.add("on");
}

function confirmModal(title, msg, confirmText, onConfirm){
  $("modalTitle").textContent = title;
  $("modalBody").innerHTML = `<div class="muted">${escapeHtml(msg)}</div>`;
  $("modalFoot").innerHTML = `
    <button class="ghost" id="cmCancel">Cancel</button>
    <button class="danger" id="cmOK">${escapeHtml(confirmText)}</button>
  `;
  $("cmCancel").onclick = ()=>closeModal();
  $("cmOK").onclick = ()=>{
    closeModal();
    onConfirm && onConfirm();
    persist();
  };
  $("modalWrap").classList.add("on");
}
function closeModal(){ $("modalWrap").classList.remove("on"); }

/* =========================
   Persistence
   ========================= */
function persist(){
  try{
    const payload = { state, savedAt: Date.now(), version: APP_VERSION };
    localStorage.setItem("tacoRia_state_v2", JSON.stringify(payload));
  }catch(e){}
}
function load(){
  try{
    const raw = localStorage.getItem("tacoRia_state_v2");
    if(!raw) return null;
    const payload = JSON.parse(raw);
    if(!payload || !payload.state) return null;
    return payload.state;
  }catch(e){ return null; }
}

/* =========================
   Match Summary
   ========================= */
function showMatchSummary(){
  const pids = ["P1","P2","P3","P4"].slice(0,state.settings.numPlayers);
  const sorted = [...pids].sort((a,b)=>state.match.scores[b]-state.match.scores[a]);
  const winner = sorted[0];

  $("modalTitle").textContent = "Match Complete";
  $("modalBody").innerHTML = `
    <div class="muted">Final scores:</div>
    <div class="hr"></div>
    <div class="tiles">
      ${sorted.map(pid=>`<div class="tile small"><div class="name">${pid}</div><div class="tag">${state.match.scores[pid]}</div></div>`).join("")}
    </div>
    <div class="hr"></div>
    <div class="muted"><b>${winner}</b> wins. Run it back?</div>
  `;
  $("modalFoot").innerHTML = `
    <button class="ghost" id="msClose">Close</button>
    <button class="primary" id="msNew">New Match</button>
  `;
  $("msClose").onclick = ()=>closeModal();
  $("msNew").onclick = ()=>{
    closeModal();
    const keep = {
      themeKey: state.settings.themeKey,
      handsTarget: state.settings.handsTarget,
      numPlayers: state.settings.numPlayers,
      cpuDifficulty: state.settings.cpuDifficulty
    };
    state = defaultState();
    state.settings = keep;
    setTheme(state.settings.themeKey);
    state.settings.handsTarget = clamp(keep.handsTarget, GAME.rules.handsTargetMin, GAME.rules.handsTargetMax);
    dealNewHand();
    persist(); render();
  };
  $("modalWrap").classList.add("on");
}

/* =========================
   Wire UI
   ========================= */
function wire(){
  $("btnDraw").onclick = ()=>openDrawModal();

  $("btnPublishAll").onclick = ()=>{
    if(state.hand.active!=="P1" || cpuBusy) return;
    if(state.hand.remix.active){ toast("Finish remix first."); return; }
    publishAllFromPrep("P1");
    persist();
    render();
    endHandIfNeeded();
  };

  $("btnEndTurn").onclick = ()=>{
    if(state.hand.active!=="P1" || cpuBusy) return;
    endTurn();
    persist();
  };

  $("modalClose").onclick = ()=>closeModal();
  $("modalWrap").addEventListener("click",(e)=>{ if(e.target === $("modalWrap")) closeModal(); });

  document.querySelector(".tabs").addEventListener("click",(e)=>{
    const t = e.target.closest(".tab");
    if(!t) return;
    currentTab = t.dataset.tab;
    render();
  });
}

/* =========================
   Boot
   ========================= */
(function boot(){
  state = load() || defaultState();

  state.settings.handsTarget = clamp(state.settings.handsTarget, GAME.rules.handsTargetMin, GAME.rules.handsTargetMax);
  state.settings.numPlayers = clamp(state.settings.numPlayers, 2, 4);
  if(!state.settings.cpuDifficulty || !CPU_DIFFICULTIES.includes(state.settings.cpuDifficulty)){
    state.settings.cpuDifficulty = "Easy";
  }

  setTheme(state.settings.themeKey || "red");

  // If remix was saved mid-state, cancel to avoid broken UI
  if(state.hand?.remix?.active) cancelRemixIfActive(true);

  // Ensure a dealt hand exists
  const pids = ["P1","P2","P3","P4"].slice(0,state.settings.numPlayers);
  const anyCards = pids.some(pid=>state.hand.players?.[pid]?.hand?.length>0);
  if(!anyCards) dealNewHand();

  wire();
  render();
  persist();

  if(state.hand.active!=="P1") runCpuLoop();
})();
</script>
</body>
</html>
