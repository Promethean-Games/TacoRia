<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Taco Ria</title>
  <style>
    :root{
      --bg:#050608;
      --bg2:#0a0c10;
      --text:#f3f4f6;
      --muted:rgba(243,244,246,.70);
      --muted2:rgba(243,244,246,.55);
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.14);
      --danger:#ff3b30;

      --accent:#00e5ff;
      --accentSoft: rgba(0,229,255,.14);

      --radius:20px;
      --pad:16px;
      --gap:12px;
      --shadow: 0 18px 45px rgba(0,0,0,.55);

      --navH:56px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(900px 380px at 18% 0%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(780px 360px at 85% 10%, rgba(255,255,255,.05), transparent 65%),
        radial-gradient(820px 420px at 50% 115%, rgba(0,0,0,.75), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow-x:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .shell{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      width:100%;
      margin:0 auto;
      max-width: 980px;
    }
    @media (max-width: 430px){ .shell{ max-width: 375px; } }
    @media (max-width: 390px){ .shell{ max-width: 360px; } }

    header{
      padding: 14px 14px 10px;
      min-height:56px;
    }
    main{
      flex:1;
      padding: 0 14px calc(var(--navH) + env(safe-area-inset-bottom) + 18px);
    }

    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ min-width:0; }
    .wrap{ flex-wrap:wrap; }
    .sp{ justify-content:space-between; }

    .pageTitle{
      font-weight:1000;
      letter-spacing:.2px;
      line-height:1.08;
      font-size: clamp(20px, 4.7vw, 28px);
    }
    .small{ font-size:12px; }
    .muted{ color:var(--muted); }
    .muted2{ color:var(--muted2); }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.065), rgba(255,255,255,.035));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: var(--shadow);
    }

    .heroPhase{
      position:relative;
      overflow:hidden;
    }
    .heroPhase::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(600px 240px at 20% 0%, rgba(255,255,255,.08), transparent 65%),
        radial-gradient(520px 240px at 85% 10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(540px 260px at 50% 120%, rgba(0,0,0,.60), transparent 55%);
      pointer-events:none;
    }
    .heroPhase > *{ position:relative; z-index:1; }

    .pills{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    button{
      border:1px solid var(--stroke2);
      background: rgba(0,0,0,.35);
      color:var(--text);
      border-radius: 18px;
      padding: 12px 14px;
      font-weight:1000;
      letter-spacing:.2px;
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .btnTiny{ padding:8px 10px; border-radius:14px; font-size:12px; }
    .ghost{ background: rgba(0,0,0,.20); }
    .primary{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border-color: rgba(255,255,255,.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 20px rgba(0,0,0,.55);
    }
    .danger{
      background: linear-gradient(180deg, rgba(255,59,48,.22), rgba(255,59,48,.10));
      border-color: rgba(255,59,48,.35);
    }

    .jumbo{
      min-height: 64px;
      font-size: 18px;
      border-radius: 20px;
      width:100%;
    }
    @media (max-width: 430px){
      .jumbo{ min-height: 68px; font-size: 19px; }
    }

    @keyframes pulseGlow{
      0%   { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
      50%  { transform: translateY(-1px); box-shadow: 0 0 0 1px rgba(255,255,255,.10), 0 0 32px rgba(0,229,255,.32); }
      100% { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
    }
    .pulse{ animation: pulseGlow 1.65s ease-in-out infinite; }
    .pulseOrder{ animation: pulseGlow 1.25s ease-in-out infinite; }

    .actionsTray{
      position: sticky;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom));
      z-index: 30;
    }
    .actionsStack{ display:flex; flex-direction:column; gap:10px; }

    .tiles{ display:flex; flex-wrap:wrap; gap:8px; }
    .tile{
      max-width:100%;
      overflow-wrap:anywhere;
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.14);
      font-weight: 900;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      --catTint: rgba(255,255,255,.06);
      background:
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.sel{
      outline: 2px solid rgba(0,229,255,.55);
      transform: translateY(-1px);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.wild{ border-color: rgba(255,255,255,.28); box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset; }
    .tile.wet{ border-color: rgba(0,229,255,.25); }

    .handGroups{ display:flex; flex-direction:column; gap:12px; }
    .handGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(0,0,0,.22);
      padding:10px;
    }
    .handGroupTitle{
      font-weight:1000;
      font-size:12px;
      letter-spacing:.18px;
      color: var(--muted);
      margin-bottom:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .handGroupTitle .count{ opacity:.75; font-weight:1000; }

    .tile.cat-tortilla, .slotValue.cat-tortilla{ --catTint: rgba(255,204,0,.18); border-color: rgba(255,204,0,.30); }
    .tile.cat-protein,  .slotValue.cat-protein { --catTint: rgba(255,59,48,.16);  border-color: rgba(255,59,48,.28); }
    .tile.cat-cheese,   .slotValue.cat-cheese  { --catTint: rgba(255,245,200,.14); border-color: rgba(255,245,200,.24); }
    .tile.cat-wet,      .slotValue.cat-wet     { --catTint: rgba(255,43,214,.14); border-color: rgba(255,43,214,.24); }
    .tile.cat-drytop,   .slotValue.cat-drytop  { --catTint: rgba(163,255,18,.12); border-color: rgba(163,255,18,.22); }
    .tile.cat-wild,     .slotValue.cat-wild    { --catTint: rgba(255,255,255,.10); border-color: rgba(255,255,255,.26); }
    .tile.cat-other,    .slotValue.cat-other   { --catTint: rgba(179,107,255,.14); border-color: rgba(179,107,255,.24); }

    .pubGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      padding:12px;
      margin-bottom:12px;
    }
    .pubGroupTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
      margin-bottom: 8px;
    }
    .pubDishRow{
      border:1px solid var(--stroke);
      border-radius:16px;
      background: rgba(0,0,0,.45);
      padding:10px;
      margin-top:10px;
      position:relative;
      overflow:hidden;
    }
    .pubDishRow::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, var(--tintA), transparent 70%);
      opacity:.95;
      pointer-events:none;
    }
    .pubDishRow > *{ position:relative; z-index:1; }
    .pubDishMeta{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
    }

    details.acc{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    details.acc + details.acc{ margin-top:10px; }
    details.acc summary{
      list-style:none;
      cursor:pointer;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:1000;
    }
    details.acc summary::-webkit-details-marker{ display:none; }
    .accBody{ padding: 0 14px 14px; }
    .field{ margin-top:10px; }
    .label{ font-size:12px; color:var(--muted); margin-bottom:6px; font-weight:900; }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; line-height:1.35; }

    :root{ color-scheme: dark; }

    nav.footer{
      position:fixed;
      left:0; right:0; bottom:0;
      height: var(--navH);
      padding-bottom: env(safe-area-inset-bottom);
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      z-index: 40;
    }
    .navBtn{
      flex:1;
      min-height:56px;
      border:none;
      border-right: 1px solid rgba(255,255,255,.06);
      background: transparent;
      color: rgba(255,255,255,.86);
      font-weight:1000;
      border-radius: 0;
      padding: 8px 6px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:2px;
    }
    .navBtn:last-child{ border-right:none; }
    .navBtn.active{
      color:#fff;
      background: radial-gradient(320px 120px at 50% 0%, rgba(0,229,255,.20), transparent 60%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .navBtn .ic{ font-size:16px; }
    .navBtn .tx{ font-size:12px; }

    #toastWrap{
      position:fixed;
      left:0; right:0;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom) + 12px);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 80;
    }
    .toast{
      max-width:min(560px, calc(100% - 24px));
      background: rgba(0,0,0,.78);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,.65);
      font-weight: 900;
      pointer-events:none;
    }

    #modalWrap{
      position:fixed; inset:0;
      background: rgba(0,0,0,.65);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 90;
    }
    #modalWrap.on{ display:flex; }
    .modal{
      width: min(560px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: 0 22px 60px rgba(0,0,0,.70);
      padding: 14px;
    }
    .modal h3{ margin: 4px 0 8px; font-size: 18px; }
    .modal .body{ color: var(--muted); font-weight: 900; line-height: 1.35; }
    .modal .foot{ margin-top: 12px; display:flex; gap:10px; justify-content:flex-end; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .page{ display:none; }
    .page.on{ display:block; }

    /* Prep Window: 8-slot carousel */
    .slotStrip{
      display:flex;
      gap:10px;
      overflow-x:auto;
      padding: 4px 2px 10px;
      -webkit-overflow-scrolling:touch;
      scroll-snap-type:x mandatory;
    }
    .slotCard{
      flex: 0 0 auto;
      width: min(150px, 44vw);
      scroll-snap-align:start;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.32);
      padding:12px;
      position:relative;
      overflow:hidden;
      user-select:none;
      cursor:pointer;
    }
    .slotCard::before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(320px 120px at 20% 0%, rgba(255,255,255,.07), transparent 60%);
      pointer-events:none;
    }
    .slotCard > *{ position:relative; z-index:1; }
    .slotLabel{
      font-weight:1000;
      font-size:12px;
      color: rgba(243,244,246,.70);
      margin-bottom:8px;
    }
    .slotValue{
      --catTint: rgba(255,255,255,.06);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:40px;
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      padding:10px 10px;
      font-weight:1000;
      text-align:center;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      background:
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .slotEmpty{
      background: rgba(255,255,255,.03);
      color: rgba(243,244,246,.45);
      border-style:dashed;
    }
    .slotFilled{
      border-color: rgba(255,255,255,.20);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }

    /* ===== Draw Tile Modal Grid w/ subtle shimmer + flip reveal ===== */
    .drawMeta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 10px;
    }
    .drawGrid{
      display:grid;
      gap:10px;
      margin-top: 8px;
    }
    .drawGrid.busy{ pointer-events:none; opacity:.96; }

    .tileBack{
      position:relative;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      box-shadow: 0 12px 28px rgba(0,0,0,.50);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      min-height: 78px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px 8px;
      perspective: 900px;
    }
    .tileBack:active{ transform: translateY(1px) scale(.99); }

    /* Shimmer only on backs (modal only) */
    @keyframes slowShimmer{
      0% { transform: translateX(-120%) skewX(-12deg); opacity:.0; }
      20%{ opacity:.12; }
      50%{ opacity:.22; }
      80%{ opacity:.10; }
      100%{ transform: translateX(140%) skewX(-12deg); opacity:.0; }
    }
    .tileBack::after{
      content:"";
      position:absolute;
      top:-40%;
      left:-60%;
      width: 70%;
      height: 180%;
      background: linear-gradient(90deg,
        transparent,
        rgba(255,255,255,.08),
        rgba(0,229,255,.10),
        rgba(255,255,255,.06),
        transparent
      );
      filter: blur(2px);
      animation: slowShimmer 4.8s ease-in-out infinite;
      pointer-events:none;
    }

    .tileFlip{
      position:relative;
      width:100%;
      height:100%;
      min-height: 78px;
      transform-style: preserve-3d;
      transition: transform 900ms cubic-bezier(.2,.85,.2,1);
    }
    .tileBack.reveal .tileFlip{ transform: rotateY(180deg); }

    .face{
      position:absolute;
      inset:0;
      border-radius:18px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 10px 8px;
      backface-visibility: hidden;
    }
    .face.back{
      background:
        radial-gradient(340px 140px at 25% 0%, rgba(255,255,255,.08), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .face.back::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(520px 240px at 10% 0%, rgba(0,229,255,.14), transparent 60%),
        radial-gradient(520px 240px at 90% 10%, rgba(255,255,255,.06), transparent 65%);
      opacity:.60;
      pointer-events:none;
    }

    .face.front{
      transform: rotateY(180deg);
      background:
        radial-gradient(340px 140px at 25% 0%, rgba(255,255,255,.08), transparent 62%),
        linear-gradient(180deg, rgba(0,229,255,.12), rgba(0,0,0,.35));
      border: 1px solid rgba(255,255,255,.10);
    }

    .tileBackBrand{
      position:relative;
      z-index:1;
      font-weight:1000;
      letter-spacing:.2px;
      color: rgba(243,244,246,.78);
      font-size: 13px;
      line-height:1.1;
      padding: 0 10px;
    }
    .tileFrontText{
      font-weight:1000;
      color: rgba(243,244,246,.92);
      font-size: 14px;
      line-height:1.15;
      padding: 0 10px;
      word-break: break-word;
    }
    .tileBackNum{
      position:absolute;
      top:10px;
      left:10px;
      z-index:2;
      font-weight:1000;
      font-size:12px;
      color: rgba(243,244,246,.42);
      background: rgba(0,0,0,.24);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 4px 8px;
      pointer-events:none;
    }
    .tileBackSel{
      outline: 2px solid rgba(0,229,255,.55);
      box-shadow: 0 0 0 1px rgba(255,255,255,.08), 0 0 30px rgba(0,229,255,.26);
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="row sp">
        <div>
          <div class="row" style="gap:10px;">
            <div class="pageTitle" id="appNameH">Taco Ria</div>
            <span class="pill"><span class="mono" id="verPill">v0.9.1.2.25</span></span>
          </div>
          <div class="muted small" id="subTitle">Private Prep ‚Ä¢ Public Line ‚Ä¢ Remix</div>
        </div>
        <button class="ghost btnTiny" id="btnNewMatchTop">New Match</button>
      </div>
    </header>

    <main>
      <!-- GAMEPLAY -->
      <section class="page on" id="pageGameplay">
        <div class="card heroPhase" style="margin-bottom:12px;">
          <div class="pills" style="margin-top:2px;">
            <span class="pill" id="tilesRemainBadge">Tiles Remaining 0</span>
            <span class="pill" id="kitchenBadge">Kitchen Closed</span>
            <span class="pill" id="handBadge">Hand 1/12</span>
            <span class="pill" id="turnBadge">Your Turn</span>
          </div>

          <div style="margin-top:12px;">
            <div style="font-weight:1000; font-size:16px;" id="phaseTitle">Not Seated Yet</div>
            <div class="muted" id="phaseDesc">Serve 10+ points in one turn to open the kitchen.</div>
          </div>
        </div>

        <!-- SIMPLE ACTIONS -->
        <div class="actionsTray">
          <div class="card">
            <div class="actionsStack">
              <button class="primary jumbo pulse" id="btnPrep">Prep a Dish</button>
              <button class="primary jumbo" id="btnOrderUp">Order Up!</button>
              <button class="danger jumbo" id="btnEndTurn">End Turn</button>
            </div>
            <div class="muted small" style="margin-top:10px;" id="actionHint">
              One draw per turn.
            </div>
          </div>
        </div>

        <!-- PUBLIC LINE -->
        <div class="card" style="margin-top:12px;">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Public Line / Window</div>
            <span class="pill" id="lineSummary">0 dishes</span>
          </div>
          <div id="publicLine"></div>
        </div>
      </section>

      <!-- PREP -->
      <section class="page" id="pagePrep">
        <div class="card">
          <div class="row sp" style="margin-bottom:8px;">
            <div style="font-weight:1000;">Prep Table</div>
            <span class="badge" id="prepTurnBadge">Your Turn</span>
          </div>

          <div class="row wrap" style="gap:10px; justify-content:space-between; margin-bottom:12px;">
            <button class="primary jumbo" id="btnDraw">Draw Tile</button>
            <button class="primary jumbo" id="btnOrderUpFromPrep">Order Up!</button>
          </div>

          <!-- PREP WINDOW (auto verification) -->
          <details class="acc" open>
            <summary>
              <span>Prep Window</span>
              <span class="muted2 small" id="prepLoadedHint">Empty</span>
            </summary>
            <div class="accBody">
              <div class="slotStrip" id="prepCarousel"></div>
              <div class="hint" id="prepHint" style="margin-top:10px;"></div>
            </div>
          </details>

          <details class="acc" open style="margin-top:10px;">
            <summary>
              <span>Your Hand</span>
              <span class="muted2 small" id="handCountHint">0 tiles</span>
            </summary>
            <div class="accBody">
              <div id="handTiles"></div>

              <div class="row wrap" style="margin-top:12px; justify-content:flex-end;">
                <button class="ghost btnTiny" id="btnClearSelection">Clear Selection</button>
              </div>

              <div class="hint" id="handHint" style="margin-top:10px;">
                Tap tiles to load/unload the Prep Window.
              </div>
            </div>
          </details>
        </div>
      </section>

      <!-- SCORES -->
      <section class="page" id="pageScores">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Scores</div>
            <span class="badge" id="scoreModePill">Standard</span>
          </div>

          <div class="row wrap" style="gap:10px; margin-bottom:12px;">
            <span class="pill" id="scoreCurrent">Current: 0</span>
            <span class="pill muted" id="scoreServedMuted">Served this hand: 0</span>
          </div>

          <div id="scoreList"></div>

          <div class="hint" style="margin-top:10px;">
            Player panels are collapsed by default. Expand to see served dishes and remix net.
          </div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="page" id="pageSettings">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Settings</div>
            <span class="badge">v<span class="mono">0.9.1.2.25</span></span>
          </div>
          <div class="muted small">Primary theme stays black. Choose a high-contrast accent.</div>

          <details class="acc" open style="margin-top:12px;">
            <summary>
              <span>Match</span>
              <span class="muted2 small">Mode + Players</span>
            </summary>
            <div class="accBody">
              <div class="row wrap" style="gap:12px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Mode</div>
                  <div class="selectWrap">
                    <select id="selMode">
                      <option value="standard">Standard Match</option>
                      <option value="campaign">Campaign</option>
                    </select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Players</div>
                  <div class="selectWrap">
                    <select id="selPlayers">
                      <option value="2">2 Players</option>
                      <option value="3">3 Players</option>
                      <option value="4" selected>4 Players</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">CPU Difficulty (Standard only)</div>
                  <div class="selectWrap">
                    <select id="selDifficulty"></select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Hands (Standard only)</div>
                  <input type="number" id="inpHands" min="1" max="12" value="12" />
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Tiles per Player</div>
                  <input type="number" id="inpTilesPerPlayer" min="8" max="24" value="16" />
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Decks</div>
                  <div class="selectWrap">
                    <select id="selDecks">
                      <option value="1">1 Deck</option>
                      <option value="2" selected>2 Decks (Recommended)</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Theme</span>
              <span class="muted2 small">Accent Color</span>
            </summary>
            <div class="accBody">
              <div class="label">Accent</div>
              <div class="selectWrap">
                <select id="selAccent"></select>
              </div>
              <div class="hint">CPU colors will auto-adjust to avoid matching you or each other.</div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Language</span>
              <span class="muted2 small">EN / ES / FR / DE</span>
            </summary>
            <div class="accBody">
              <div class="label">App Language</div>
              <div class="selectWrap">
                <select id="selLang">
                  <option value="en">English</option>
                  <option value="es">Espa√±ol</option>
                  <option value="fr">Fran√ßais</option>
                  <option value="de">Deutsch</option>
                </select>
              </div>
            </div>
          </details>
        </div>
      </section>
    </main>
  </div>

  <nav class="footer">
    <button class="navBtn active" id="navGame"><div class="ic">üé≠</div><div class="tx">Gameplay</div></button>
    <button class="navBtn" id="navPrep"><div class="ic">üç≥</div><div class="tx">Prep</div></button>
    <button class="navBtn" id="navScores"><div class="ic">üèÜ</div><div class="tx">Scores</div></button>
    <button class="navBtn" id="navSettings"><div class="ic">‚öôÔ∏è</div><div class="tx">Settings</div></button>
  </nav>

  <div id="toastWrap"></div>

  <div id="modalWrap">
    <div class="modal">
      <h3 id="modalTitle">Modal</h3>
      <div class="body" id="modalBody"></div>
      <div class="foot" id="modalFoot"></div>
    </div>
  </div>

  <script>
    /* =========================
       Taco Ria v0.9.1.2.25 (Atomic Patch)
       ‚úÖ Removed "Current Dish" panel
       ‚úÖ Automated verification: player selects ingredients -> Order Up enabled if ANY recipe qualifies
       ‚úÖ Prep Window: 8 slots, auto-placed by category
       ‚úÖ Draw Tile modal: tile backs show ONLY game name; subtle shimmer; flip reveal; modal stays open through reveal
       ‚úÖ One draw per turn enforced
       ========================= */

    const VERSION = "v0.9.1.2.25";
    const LS_KEY = "taco_ria_state_v091225_autoverify";

    const DIFFS = ["Beginner","Easy","Medium","Difficult","Master Chef"];
    const DIFF_DELAY_MS = { "Beginner":5000, "Easy":3500, "Medium":2200, "Difficult":1200, "Master Chef":500 };

    const ACCENTS = [
      { name:"Neon Cyan", val:"#00e5ff" },
      { name:"Signal Yellow", val:"#ffcc00" },
      { name:"Lime", val:"#a3ff12" },
      { name:"Hot Pink", val:"#ff2bd6" },
      { name:"Orange", val:"#ff8a00" },
      { name:"Ice", val:"#b3f6ff" },
      { name:"Violet", val:"#b36bff" },
      { name:"Red", val:"#ff3b30" }
    ];

    const CPU_BASE_COLORS = ["#ff3b30","#b36bff","#ffcc00","#a3ff12"];

    const I18N = {
      en: { gameplay:"Gameplay", prep:"Prep", scores:"Scores", settings:"Settings", orderUp:"Order Up!", drawTile:"Draw Tile", endTurn:"End Turn", prepDish:"Prep a Dish", cancel:"Cancel", close:"Close" },
      es: { gameplay:"Juego", prep:"Preparaci√≥n", scores:"Puntos", settings:"Ajustes", orderUp:"¬°Orden lista!", drawTile:"Robar ficha", endTurn:"Terminar turno", prepDish:"Preparar plato", cancel:"Cancelar", close:"Cerrar" },
      fr: { gameplay:"Jeu", prep:"Pr√©pa", scores:"Scores", settings:"R√©glages", orderUp:"√Ä l‚Äôenvoi !", drawTile:"Piocher une tuile", endTurn:"Fin du tour", prepDish:"Pr√©parer un plat", cancel:"Annuler", close:"Fermer" },
      de: { gameplay:"Spiel", prep:"Vorbereiten", scores:"Punkte", settings:"Einstellungen", orderUp:"Bestellung raus!", drawTile:"Pl√§ttchen ziehen", endTurn:"Zug beenden", prepDish:"Gericht vorbereiten", cancel:"Abbrechen", close:"Schlie√üen" },
    };

    const RULES = {
      remixMinPoints: 5,
      tacoDryToppingsRequired: 3,
      wetLockedUntilKitchen: true,
      starterPassDishKey: "chipsDip",
    };

    const RECIPES = [
      { key:"hardTaco", name:"Hard Shell Taco", pts:5, kind:"taco", tortilla:"Corn Tortillas" },
      { key:"softTaco", name:"Soft Taco", pts:5, kind:"taco", tortilla:"Flour Tortillas" },
      { key:"chorizoTaco", name:"Chorizo Taco", pts:8, kind:"chorizoTaco" },
      { key:"chipsDip", name:"Chips & Dip", pts:5, kind:"chipsDip" },
      { key:"pico", name:"Pico de Gallo", pts:8, kind:"pico" },
      { key:"ench", name:"Enchiladas", pts:10, kind:"ench" },
    ];

    const DECK_ING_COUNTS = [
      ["Fish",1],["Ground Beef",2],["Shredded Chicken",2],["Carne Guisada",1],["Al Pastor",1],["Carnitas",1],
      ["Egg",2],["Chicken Fajita",2],["Chorizo",1],
      ["Tortilla Chips",3],["Flour Tortillas",2],["Corn Tortillas",2],
      ["Shredded yellow Cheese",2],["Shredded white cheese",2],
      ["Rice",2],["Charro Beans",1],["Refried Beans",1],["Black Beans",1],
      ["Cilantro",2],["Jalapenos",2],["Lettuce",1],["Lime Juice",2],["Onion",2],["Tomato",2],
      ["Sour Cream",2],["Avocado",2],
      ["Salsa Roja",2],["Salsa Verde",2],["Queso",2],["Guacamole",2],
      ["Grocery Run",2],
    ];

    const $ = (id)=> document.getElementById(id);

    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }
    function randInt(n){ return Math.floor(Math.random()*n); }
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }
    function nowId(prefix="id"){
      return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }
    function hexToRgba(hex, a){
      const h = (hex || "#ffffff").replace("#","").trim();
      const full = h.length===3 ? h.split("").map(c=>c+c).join("") : h.padEnd(6,"0").slice(0,6);
      const n = parseInt(full,16);
      const r=(n>>16)&255, g=(n>>8)&255, b=n&255;
      return `rgba(${r},${g},${b},${a})`;
    }
    function groupBy(arr, keyFn){
      const m = {};
      for(const it of arr){
        const k = keyFn(it);
        (m[k] ||= []).push(it);
      }
      return m;
    }
    function toast(msg, ms=2200){
      const wrap = $("toastWrap");
      wrap.innerHTML = `<div class="toast">${escapeHtml(msg)}</div>`;
      clearTimeout(toast._t);
      toast._t = setTimeout(()=> wrap.innerHTML="", ms);
    }
    function openModal(title, html, footButtons){
      $("modalTitle").textContent = title;
      $("modalBody").innerHTML = html;
      $("modalFoot").innerHTML = "";
      for(const b of footButtons){
        const btn = document.createElement("button");
        btn.className = b.className || "ghost";
        btn.textContent = b.text;
        btn.onclick = ()=> b.onClick?.();
        $("modalFoot").appendChild(btn);
      }
      $("modalWrap").classList.add("on");
    }
    function closeModal(){ $("modalWrap").classList.remove("on"); modalMode = null; }
    $("modalWrap").addEventListener("click",(e)=>{ if(e.target.id==="modalWrap") closeModal(); });

    function t(key){
      const lang = state.settings.lang || "en";
      return (I18N[lang] && I18N[lang][key]) || I18N.en[key] || key;
    }
    function getAppName(){
      return ($("appNameH")?.textContent || document.title || "App").trim();
    }
    function recipeByKey(k){ return RECIPES.find(r=>r.key===k); }

    /* ===== Ingredient classification ===== */
    function isWild(name){ return name==="Grocery Run"; }
    function isTortilla(name){ return name==="Corn Tortillas" || name==="Flour Tortillas"; }
    function isProtein(name){
      return ["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"].includes(name);
    }
    function isCheese(name){ return name==="Shredded yellow Cheese" || name==="Shredded white cheese"; }
    function isSauce(name){ return name==="Salsa Roja" || name==="Salsa Verde"; }
    function isWet(name){ return ["Salsa Roja","Salsa Verde","Queso","Guacamole"].includes(name); }
    function isDip(name){ return ["Salsa Roja","Salsa Verde","Guacamole","Queso"].includes(name); }
    function isTopping(name){
      return isWet(name) || ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Avocado","Shredded yellow Cheese","Shredded white cheese"].includes(name);
    }
    function isDryTopping(name){ return isTopping(name) && !isWet(name) && !isCheese(name); }

    function ingredientCategory(name){
      if(isWild(name)) return "wild";
      if(isTortilla(name)) return "tortilla";
      if(isProtein(name)) return "protein";
      if(isCheese(name)) return "cheese";
      if(isWet(name)) return "wet";
      if(isDryTopping(name)) return "drytop";
      return "other";
    }
    function categoryLabel(cat){
      return {
        tortilla:"Tortillas",
        protein:"Proteins",
        cheese:"Cheese",
        wet:"Wet Toppings",
        drytop:"Dry Toppings",
        wild:"Grocery Run",
        other:"Other"
      }[cat] || cat;
    }

    /* ===== Validation ===== */
    function validateDish(recipeKey, tileObjs, ctx){
      const r = recipeByKey(recipeKey);
      if(!r) return { ok:false, reason:"Unknown recipe." };

      const names = tileObjs.map(t=>t.name);
      const wildCount = names.filter(isWild).length;
      const nonWild = names.filter(n=>!isWild(n));

      function count(fn){ return nonWild.filter(fn).length; }
      function hasAny(fn){ return count(fn) > 0 || wildCount > 0; }

      if(r.kind==="taco"){
        const hasReqTortilla = nonWild.includes(r.tortilla) || (wildCount>0 && !nonWild.some(isTortilla));
        if(!hasReqTortilla) return { ok:false, reason:`Use ${r.tortilla}.` };

        if(!hasAny(isProtein)) return { ok:false, reason:"Needs 1 protein." };

        if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          if(nonWild.some(isWet)) return { ok:false, reason:"Wet toppings locked until Kitchen Open." };
        }

        const dryTopCount = nonWild.filter(isDryTopping).length;
        if(dryTopCount !== RULES.tacoDryToppingsRequired && wildCount < Math.max(0, RULES.tacoDryToppingsRequired - dryTopCount)){
          return { ok:false, reason:`Needs ${RULES.tacoDryToppingsRequired} dry toppings.` };
        }

        if(count(isTortilla) > 1) return { ok:false, reason:"Only 1 tortilla." };
        if(count(isProtein) > 1) return { ok:false, reason:"Only 1 protein." };
        if(count(isCheese) > 1) return { ok:false, reason:"Only 1 cheese." };
        if(nonWild.filter(isWet).length > 1) return { ok:false, reason:"Only 1 wet topping." };

        if(tileObjs.length < 5 || tileObjs.length > 7) return { ok:false, reason:"Use 5‚Äì7 tiles." };
        return { ok:true };
      }

      if(r.kind==="chorizoTaco"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Needs 4 tiles." };
        const hasTort = count(isTortilla) >= 1 || wildCount>=1;
        const hasChor = nonWild.includes("Chorizo") || wildCount>=1;
        const hasOnion = nonWild.includes("Onion") || wildCount>=1;
        const hasCil = nonWild.includes("Cilantro") || wildCount>=1;
        if(!hasTort) return { ok:false, reason:"Needs tortilla." };
        if(!hasChor) return { ok:false, reason:"Needs chorizo." };
        if(!hasOnion) return { ok:false, reason:"Needs onion." };
        if(!hasCil) return { ok:false, reason:"Needs cilantro." };
        return { ok:true };
      }

      if(r.kind==="chipsDip"){
        if(tileObjs.length !== 2) return { ok:false, reason:"Needs 2 tiles." };
        const hasChips = nonWild.includes("Tortilla Chips") || wildCount>=1;
        const hasDipOk = nonWild.filter(isDip).length >= 1 || wildCount>=1;
        if(!hasChips) return { ok:false, reason:"Needs Tortilla Chips." };
        if(!hasDipOk) return { ok:false, reason:"Needs a dip (salsa/queso/guac)." };
        return { ok:true };
      }

      if(r.kind==="pico"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Needs 4 tiles." };
        const okTom = nonWild.includes("Tomato") || wildCount>=1;
        const okOn  = nonWild.includes("Onion") || wildCount>=1;
        const okCil = nonWild.includes("Cilantro") || wildCount>=1;
        const okLim = nonWild.includes("Lime Juice") || wildCount>=1;
        if(!okTom || !okOn || !okCil || !okLim) return { ok:false, reason:"Needs Tomato, Onion, Cilantro, Lime." };
        return { ok:true };
      }

      if(r.kind==="ench"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Needs 4 tiles." };
        const wildCount2 = names.filter(isWild).length;
        const nonWild2 = names.filter(n=>!isWild(n));
        const hasTort = nonWild2.filter(isTortilla).length >= 1 || wildCount2>=1;
        const hasProt = nonWild2.filter(isProtein).length >= 1 || wildCount2>=1;
        const hasChee = nonWild2.filter(isCheese).length >= 1 || wildCount2>=1;
        const hasSau  = nonWild2.filter(isSauce).length >= 1 || wildCount2>=1;
        if(!hasTort) return { ok:false, reason:"Needs tortillas." };
        if(!hasProt) return { ok:false, reason:"Needs protein." };
        if(!hasChee) return { ok:false, reason:"Needs shredded cheese." };
        if(!hasSau)  return { ok:false, reason:"Needs sauce." };
        return { ok:true };
      }

      return { ok:false, reason:"Unknown recipe." };
    }

    /* ===== Auto-detect best qualifying dish from selection ===== */
    function bestQualifyingRecipe(tileObjs, ctx){
      const winners = [];
      for(const r of RECIPES){
        const v = validateDish(r.key, tileObjs, ctx);
        if(v.ok) winners.push(r);
      }
      if(!winners.length) return null;
      // pick highest points; tie-breaker: fewer tiles used; then stable by list order
      winners.sort((a,b)=> (b.pts - a.pts));
      return winners[0];
    }

    /* ===== Prep Window slots (generic, always 8) ===== */
    const PREP_SLOTS = [
      { label:"Tortilla", accept:isTortilla },
      { label:"Protein", accept:isProtein },
      { label:"Cheese", accept:isCheese },
      { label:"Wet", accept:isWet },
      { label:"Dry Top 1", accept:isDryTopping },
      { label:"Dry Top 2", accept:isDryTopping },
      { label:"Dry Top 3", accept:isDryTopping },
      { label:"Extra", accept:()=>true },
    ];

    function assignSelectionToPrepSlots(pl, selIds){
      const chosen = selIds
        .map(id=> pl.hand.find(t=>t.id===id))
        .filter(Boolean);

      const used = new Set();
      const slotFill = PREP_SLOTS.map(()=> null);

      // pass 1: exact slot matches (non-wild preferred)
      for(let si=0; si<PREP_SLOTS.length; si++){
        const s = PREP_SLOTS[si];
        const found = chosen.find(t => !used.has(t.id) && !isWild(t.name) && s.accept(t.name));
        if(found){
          slotFill[si] = found;
          used.add(found.id);
        }
      }
      // pass 2: wilds fill missing matches
      for(let si=0; si<PREP_SLOTS.length; si++){
        if(slotFill[si]) continue;
        const s = PREP_SLOTS[si];
        const wild = chosen.find(t => !used.has(t.id) && isWild(t.name));
        if(wild){
          slotFill[si] = wild;
          used.add(wild.id);
        }
      }
      // pass 3: leftovers go into first empty
      const leftovers = chosen.filter(t=>!used.has(t.id));
      for(let si=0; si<PREP_SLOTS.length && leftovers.length; si++){
        if(slotFill[si]) continue;
        slotFill[si] = leftovers.shift();
      }

      return slotFill;
    }

    /* ===== State ===== */
    function defaultState(){
      return {
        settings:{
          accent:"#00e5ff",
          lang:"en",
          mode:"standard",
          players:4,
          difficulty:"Easy",
          handsTotal:12,
          tilesPerPlayer:16,
          decks:2,
        },
        match: null,
        ui:{
          page:"gameplay",
          selectedIds: [],          // ‚úÖ selection drives verification now
        }
      };
    }

    function persist(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    function load(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return null;
        return JSON.parse(raw);
      }catch(e){
        return null;
      }
    }
    let state = load() || defaultState();

    /* ===== Deck / Match ===== */
    function buildDeck(decks=2){
      const tiles = [];
      for(let d=0; d<decks; d++){
        for(const [name,count] of DECK_ING_COUNTS){
          for(let i=0;i<count;i++){
            tiles.push({ id: nowId("t"), name });
          }
        }
      }
      return shuffle(tiles);
    }

    function mkPlayer(id, name, isHuman, color){
      return {
        id, name, isHuman,
        color,
        score: 0,
        servedThisHand: 0,
        hand: [],
        starterPassUsed: false,
        didDrawThisTurn: false,
        logThisHand: [],
        remixGainThisHand: 0,
        remixLossThisHand: 0,
      };
    }

    function dealInitial(m){
      const tilesPer = state.settings.tilesPerPlayer;
      for(const pid of Object.keys(m.players)){
        m.players[pid].hand = [];
        for(let i=0;i<tilesPer;i++){
          const t0 = m.bag.pop();
          if(!t0) break;
          m.players[pid].hand.push(t0);
        }
      }
    }

    function ensureUniqueCpuColors(){
      const used = new Set([state.settings.accent.toLowerCase()]);
      const pickPool = ACCENTS.map(a=>a.val.toLowerCase());
      const unique = [];

      for(const c of CPU_BASE_COLORS){
        let col = c.toLowerCase();
        if(used.has(col)){
          col = pickPool.find(x=>!used.has(x)) || col;
        }
        used.add(col);
        unique.push(col);
      }
      return unique;
    }

    function newMatch(){
      const cpuCols = ensureUniqueCpuColors();
      const pCount = state.settings.players;

      const m = {
        id: nowId("m"),
        handIndex: 1,
        kitchenOpen: false,
        bag: buildDeck(state.settings.decks),
        publicLine: [],
        players: {},
        activePid: "P1",
        servedThisTurnPts: 0,
      };

      m.players["P1"] = mkPlayer("P1","You", true, state.settings.accent);
      if(pCount >= 2) m.players["P2"] = mkPlayer("P2","Chef Mike", false, cpuCols[0]);
      if(pCount >= 3) m.players["P3"] = mkPlayer("P3","Salsa Sam", false, cpuCols[1]);
      if(pCount >= 4) m.players["P4"] = mkPlayer("P4","Queso Queen", false, cpuCols[2]);

      dealInitial(m);

      state.match = m;
      state.ui.page = "gameplay";
      state.ui.selectedIds = [];
      persist();
      render();
      toast("New match started.");
    }

    function beginTurn(pid){
      const m = state.match;
      const p = m.players[pid];
      if(!p) return;
      p.didDrawThisTurn = false;
      m.servedThisTurnPts = 0;

      // keep selections ONLY for human turn
      if(pid === "P1"){
        state.ui.selectedIds = [];
      }
    }

    function p1(){ return state.match.players["P1"]; }
    function selectedTilesP1(){
      const pl = p1();
      return state.ui.selectedIds.map(id=>pl.hand.find(t=>t.id===id)).filter(Boolean);
    }

    /* ===== Publish selection as dish ===== */
    function publishSelectionP1(){
      const m = state.match;
      const pl = p1();
      const ctx = { kitchenOpen: m.kitchenOpen };

      const tiles = selectedTilesP1();
      const r = bestQualifyingRecipe(tiles, ctx);
      if(!r) return { ok:false, msg:"No qualifying dish." };

      const v = validateDish(r.key, tiles, ctx);
      if(!v.ok) return { ok:false, msg:v.reason };

      const pub = {
        id: nowId("pub"),
        owner: "P1",
        ownerName: pl.name,
        recipeKey: r.key,
        name: r.name,
        points: r.pts,
        tiles: tiles.map(t=>({id:t.id, name:t.name})),
        isRemix: false,
        from: null
      };
      m.publicLine.push(pub);

      // remove used tiles from hand
      for(const t0 of tiles){
        const idx = pl.hand.findIndex(h=>h.id===t0.id);
        if(idx>=0) pl.hand.splice(idx,1);
      }

      pl.score += r.pts;
      pl.servedThisHand += r.pts;
      pl.logThisHand.push({ type:"serve", name:r.name, points:r.pts });

      // kitchen open tracking (starter pass honored)
      let nonStarterPts = 0;
      if(!m.kitchenOpen){
        if(r.key === RULES.starterPassDishKey && !pl.starterPassUsed){
          pl.starterPassUsed = true;
        }else{
          nonStarterPts += r.pts;
        }
      }else{
        nonStarterPts += r.pts;
      }

      m.servedThisTurnPts += nonStarterPts;
      if(!m.kitchenOpen && m.servedThisTurnPts >= 10){
        m.kitchenOpen = true;
        toast("üî• Kitchen Open!");
      }

      // clear selection after publish
      state.ui.selectedIds = [];
      return { ok:true };
    }

    /* ===== One draw per turn ===== */
    function drawTile(pid){
      const m = state.match;
      const pl = m.players[pid];
      if(m.activePid !== pid) return { ok:false, msg:"Not your turn." };
      if(pl.didDrawThisTurn) return { ok:false, msg:"Only one draw per turn." };
      if(m.bag.length === 0) return { ok:false, msg:"No tiles left." };

      const idx = randInt(m.bag.length);
      const t0 = m.bag.splice(idx, 1)[0];

      pl.hand.push(t0);
      pl.didDrawThisTurn = true;
      return { ok:true, tile:t0, msg:`Drew: ${t0.name}` };
    }

    /* ===== End turn ===== */
    function endTurn(pid){
      const m = state.match;
      if(m.activePid !== pid) return;

      const order = Object.keys(m.players);
      const i = order.indexOf(pid);
      const next = order[(i+1)%order.length];
      m.activePid = next;
      beginTurn(next);

      persist();
      render();

      if(next !== "P1"){
        setTimeout(()=> cpuAct(next), cpuDelayMs());
      }else{
        toast("Your turn.");
      }
    }

    function cpuDelayMs(){
      const diff = state.settings.difficulty || "Easy";
      const base = DIFF_DELAY_MS[diff] ?? 2200;
      return Math.max(450, base + randInt(220));
    }

    function cpuAct(pid){
      const m = state.match;
      const pl = m.players[pid];
      if(!pl || pl.isHuman) return;

      const ctx = { kitchenOpen: m.kitchenOpen };

      // quick heuristic: try to assemble a valid recipe, else draw once
      const tryOrder = ["ench","pico","chorizoTaco","hardTaco","softTaco","chipsDip"];

      function pickExact(name){
        return pl.hand.find(x=>x.name===name)?.id || pl.hand.find(x=>x.name==="Grocery Run")?.id || null;
      }
      function anyFrom(names){
        for(const n of names){
          const id = pl.hand.find(x=>x.name===n)?.id;
          if(id) return id;
        }
        return pl.hand.find(x=>x.name==="Grocery Run")?.id || null;
      }

      let made = false;

      for(const key of tryOrder){
        const r = recipeByKey(key);
        if(!r) continue;

        let ids = [];

        if(r.kind==="chipsDip"){
          const chips = pl.hand.find(x=>x.name==="Tortilla Chips")?.id || pickExact("Tortilla Chips");
          const dip = anyFrom(["Salsa Roja","Salsa Verde","Guacamole","Queso"]);
          if(chips && dip) ids = [chips,dip];
        }else if(r.kind==="pico"){
          const tom = pickExact("Tomato"), oni = pickExact("Onion"), cil = pickExact("Cilantro"), lim = pickExact("Lime Juice");
          if(tom && oni && cil && lim) ids = [tom,oni,cil,lim];
        }else if(r.kind==="ench"){
          const tort = anyFrom(["Flour Tortillas","Corn Tortillas"]);
          const prot = anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]);
          const chee = anyFrom(["Shredded yellow Cheese","Shredded white cheese"]);
          const sauc = anyFrom(["Salsa Roja","Salsa Verde"]);
          if(tort && prot && chee && sauc) ids = [tort,prot,chee,sauc];
        }else if(r.kind==="chorizoTaco"){
          const tort = anyFrom(["Flour Tortillas","Corn Tortillas"]);
          const chor = pickExact("Chorizo"), oni = pickExact("Onion"), cil = pickExact("Cilantro");
          if(tort && chor && oni && cil) ids = [tort,chor,oni,cil];
        }else if(r.kind==="taco"){
          const tort = pickExact(r.tortilla);
          const prot = anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]);
          if(tort && prot){
            ids.push(tort,prot);
            const tops = ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Avocado","Shredded yellow Cheese","Shredded white cheese"];
            for(const n of tops){
              if(ids.length>=5) break;
              const id = pl.hand.find(x=>x.name===n)?.id;
              if(id && !ids.includes(id)) ids.push(id);
            }
            while(ids.length<5){
              const w = pl.hand.find(x=>x.name==="Grocery Run")?.id;
              if(!w) break;
              ids.push(w);
            }
          }
        }

        if(ids.length){
          const tiles = ids.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
          const v = validateDish(r.key, tiles, ctx);
          if(v.ok){
            // publish
            const pub = {
              id: nowId("pub"),
              owner: pid,
              ownerName: pl.name,
              recipeKey: r.key,
              name: r.name,
              points: r.pts,
              tiles: tiles.map(t=>({id:t.id, name:t.name})),
              isRemix: false,
              from: null
            };
            m.publicLine.push(pub);

            for(const t0 of tiles){
              const idx = pl.hand.findIndex(h=>h.id===t0.id);
              if(idx>=0) pl.hand.splice(idx,1);
            }
            pl.score += r.pts;
            pl.servedThisHand += r.pts;
            pl.logThisHand.push({ type:"serve", name:r.name, points:r.pts });

            // kitchen open tracking
            let nonStarterPts = 0;
            if(!m.kitchenOpen){
              if(r.key === RULES.starterPassDishKey && !pl.starterPassUsed){
                pl.starterPassUsed = true;
              }else{
                nonStarterPts += r.pts;
              }
            }else{
              nonStarterPts += r.pts;
            }
            m.servedThisTurnPts += nonStarterPts;
            if(!m.kitchenOpen && m.servedThisTurnPts >= 10){
              m.kitchenOpen = true;
            }

            made = true;
            break;
          }
        }
      }

      if(!made){
        drawTile(pid);
      }

      persist();
      render();
      endTurn(pid);
    }

    /* ===== Selection (P1) ===== */
    function toggleSelection(tileId){
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }

      const pl = p1();
      const tile = pl.hand.find(t=>t.id===tileId);
      if(!tile) return;

      const inSel = state.ui.selectedIds.includes(tileId);
      if(inSel){
        state.ui.selectedIds = state.ui.selectedIds.filter(id=>id!==tileId);
        persist(); render();
        return;
      }

      // cap at 8 for clean prep window
      if(state.ui.selectedIds.length >= 8){
        toast("Prep Window is full.");
        return;
      }

      state.ui.selectedIds.push(tileId);
      persist(); render();
    }

    function clearSelection(){
      state.ui.selectedIds = [];
      persist(); render();
    }

    /* ===== Draw Modal ===== */
    let modalMode = null;

    function bestFitCols(n){
      if(n >= 25) return 5;
      const c = Math.ceil(Math.sqrt(n));
      return Math.max(1, Math.min(5, c));
    }

    function openDrawModal(){
      const m = state.match;
      const pl = p1();
      const myTurn = (m.activePid === "P1");

      if(!myTurn){ toast("Not your turn."); return; }
      if(pl.didDrawThisTurn){ toast("Only one draw per turn."); return; }

      const total = m.bag.length;
      if(total === 0){
        openModal(
          t("drawTile"),
          `<div class="muted">No more tiles to choose from.</div>`,
          [{ text: t("close"), className:"primary", onClick: closeModal }]
        );
        return;
      }

      const shown = Math.min(25, total);
      const cols = bestFitCols(shown);
      const appName = escapeHtml(getAppName());

      const meta = `
        <div class="drawMeta">
          <span class="pill">Tiles Remaining <span class="mono">${total}</span></span>
          ${total > 25 ? `<span class="pill muted">Showing <span class="mono">25</span></span>` : ``}
        </div>
        <div class="muted small">Pick a tile, any tile...</div>
      `;

      const grid = `
        <div class="drawGrid" id="drawGrid" style="grid-template-columns: repeat(${cols}, 1fr);">
          ${Array.from({length: shown}).map((_,i)=>`
            <div class="tileBack" data-draw-pick="${i}">
              <div class="tileBackNum">${i+1}/${shown}</div>
              <div class="tileFlip">
                <div class="face back">
                  <div class="tileBackBrand">${appName}</div>
                </div>
                <div class="face front">
                  <div class="tileFrontText" data-front-text>‚Äî</div>
                </div>
              </div>
            </div>
          `).join("")}
        </div>
      `;

      openModal(
        t("drawTile"),
        meta + grid,
        [
          { text: t("close"), className:"primary", onClick: closeModal }
        ]
      );

      modalMode = "draw";

      $("modalBody").onclick = (e)=>{
        if(modalMode !== "draw") return;
        const pick = e.target.closest("[data-draw-pick]");
        if(!pick) return;

        const gridEl = $("drawGrid");
        if(gridEl) gridEl.classList.add("busy");
        pick.classList.add("tileBackSel");

        // perform actual draw (random), then reveal via flip, THEN close after a beat
        modalMode = "draw_busy";

        const res = drawTile("P1");
        if(!res.ok){
          toast(res.msg);
          closeModal();
          persist(); render();
          return;
        }

        const front = pick.querySelector("[data-front-text]");
        if(front) front.textContent = res.tile?.name || "‚Äî";

        // flip reveal
        requestAnimationFrame(()=>{
          pick.classList.add("reveal");
        });

        // keep modal open through animation; then close
        setTimeout(()=>{
          closeModal();
          persist();
          render();
          toast(res.msg);
        }, 1150);
      };
    }

    /* ===== Pages ===== */
    function setPage(p){
      state.ui.page = p;
      persist();
      render();
    }
    function setNavActive(btnId){
      ["navGame","navPrep","navScores","navSettings"].forEach(id=>{
        $(id).classList.toggle("active", id===btnId);
      });
    }
    $("navGame").onclick = ()=> setPage("gameplay");
    $("navPrep").onclick = ()=> setPage("prep");
    $("navScores").onclick = ()=> setPage("scores");
    $("navSettings").onclick = ()=> setPage("settings");

    /* ===== Buttons ===== */
    $("btnNewMatchTop").onclick = ()=>{
      openModal(
        "New Match",
        "Start a fresh match? This overwrites current match state.",
        [
          { text:"Cancel", className:"ghost", onClick: closeModal },
          { text:"Start", className:"primary", onClick: ()=>{ closeModal(); newMatch(); } }
        ]
      );
    };

    $("btnPrep").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      setPage("prep");
    };

    function doOrderUpFrom(where){
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }

      const res = publishSelectionP1();
      if(!res.ok){ toast(res.msg); return; }

      persist(); render();
      toast("Order up!");
      if(where==="prep") setPage("gameplay");
    }

    $("btnOrderUp").onclick = ()=> doOrderUpFrom("gameplay");
    $("btnOrderUpFromPrep").onclick = ()=> doOrderUpFrom("prep");

    $("btnEndTurn").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      endTurn("P1");
    };

    $("btnDraw").onclick = openDrawModal;
    $("btnClearSelection").onclick = clearSelection;

    $("handTiles").addEventListener("click",(e)=>{
      const el = e.target.closest("[data-htile]");
      if(!el) return;
      toggleSelection(el.getAttribute("data-htile"));
    });

    // tap a filled slot in prep window to remove that ingredient from selection
    $("prepCarousel").addEventListener("click",(e)=>{
      const card = e.target.closest(".slotCard");
      if(!card) return;
      const tileId = card.getAttribute("data-tile-id");
      if(!tileId) return;

      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }

      state.ui.selectedIds = state.ui.selectedIds.filter(id => id !== tileId);
      persist(); render();
    });

    /* ===== Settings ===== */
    function fillSettings(){
      $("selDifficulty").innerHTML = DIFFS.map(d=> `<option value="${d}">${d}</option>`).join("");
      $("selDifficulty").value = state.settings.difficulty;

      $("selAccent").innerHTML = ACCENTS.map(a=> `<option value="${a.val}">${a.name} (${a.val})</option>`).join("");
      $("selAccent").value = state.settings.accent;

      $("selMode").value = state.settings.mode;
      $("selPlayers").value = String(state.settings.players);
      $("inpHands").value = state.settings.handsTotal;
      $("inpTilesPerPlayer").value = state.settings.tilesPerPlayer;
      $("selDecks").value = String(state.settings.decks);
      $("selLang").value = state.settings.lang;
    }

    $("selMode").onchange = ()=>{ state.settings.mode = $("selMode").value; persist(); render(); toast("Mode updated."); };
    $("selPlayers").onchange = ()=>{ state.settings.players = parseInt($("selPlayers").value,10); persist(); render(); toast("Players updated."); };
    $("selDifficulty").onchange = ()=>{ state.settings.difficulty = $("selDifficulty").value; persist(); render(); };
    $("inpHands").onchange = ()=>{ state.settings.handsTotal = Math.max(1, Math.min(12, parseInt($("inpHands").value,10) || 12)); persist(); render(); };
    $("inpTilesPerPlayer").onchange = ()=>{ state.settings.tilesPerPlayer = Math.max(8, Math.min(24, parseInt($("inpTilesPerPlayer").value,10) || 16)); persist(); render(); };
    $("selDecks").onchange = ()=>{ state.settings.decks = parseInt($("selDecks").value,10) || 2; persist(); render(); };

    $("selAccent").onchange = ()=>{
      state.settings.accent = $("selAccent").value;
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      if(state.match){
        const cpuCols = ensureUniqueCpuColors();
        if(state.match.players["P2"]) state.match.players["P2"].color = cpuCols[0];
        if(state.match.players["P3"]) state.match.players["P3"].color = cpuCols[1];
        if(state.match.players["P4"]) state.match.players["P4"].color = cpuCols[2];
        state.match.players["P1"].color = state.settings.accent;
      }

      persist(); render();
    };

    $("selLang").onchange = ()=>{ state.settings.lang = $("selLang").value; persist(); render(); };

    /* ===== Rendering ===== */
    function phaseText(){
      const m = state.match;
      if(m.kitchenOpen) return { title:"Kitchen Open", desc:"Remix is enabled. Wet toppings allowed." };
      if(m.publicLine.length > 0) return { title:"Appetizers Out", desc:"Build toward 10+ points in a single turn to open the kitchen." };
      return { title:"Not Seated Yet", desc:"Serve 10+ points in one turn to open the kitchen." };
    }

    function playerColor(pid){
      const m = state.match;
      return m.players[pid]?.color || "#ffffff";
    }

    function renderPublicLine(){
      const m = state.match;
      const el = $("publicLine");

      $("lineSummary").textContent = `${m.publicLine.length} dish${m.publicLine.length===1?"":"es"}`;

      if(!m.publicLine.length){
        el.innerHTML = `<div class="muted small">No dishes in the window yet.</div>`;
        return;
      }

      const groups = groupBy(m.publicLine, d=> d.name);
      el.innerHTML = Object.entries(groups).map(([menuItem, dishes])=>{
        const total = dishes.reduce((t0,d)=>t0+d.points,0);
        return `
          <div class="pubGroup">
            <div class="pubGroupTitle">
              <div>${escapeHtml(menuItem)}</div>
              <span class="badge">Total <span class="mono">${total}</span></span>
            </div>
            ${dishes.map(d=>{
              const col = playerColor(d.owner);
              const tintA = hexToRgba(col,.28);
              const tiles = d.tiles.map(ti=>{
                const cat = ingredientCategory(ti.name);
                const wet = isWet(ti.name) ? "wet" : "";
                const wild = isWild(ti.name) ? "wild" : "";
                return `<span class="tile ${wet} ${wild} cat-${cat}">${escapeHtml(ti.name)}</span>`;
              }).join("");
              return `
                <div class="pubDishRow" style="--tintA:${tintA};">
                  <div class="pubDishMeta">
                    <div>${escapeHtml(d.ownerName)}${d.isRemix ? " ‚Ä¢ Remix" : ""}</div>
                    <span class="badge">${d.points} pts</span>
                  </div>
                  <div class="tiles" style="margin-top:8px;">${tiles}</div>
                </div>
              `;
            }).join("")}
          </div>
        `;
      }).join("");
    }

    function renderPrep(){
      const m = state.match;
      const pl = p1();
      const myTurn = (m.activePid==="P1");

      $("prepTurnBadge").textContent = myTurn ? "Your Turn" : `${m.players[m.activePid].name}'s Turn`;
      $("handCountHint").textContent = `${pl.hand.length} tiles`;

      // Draw button state
      $("btnDraw").textContent = t("drawTile");
      $("btnDraw").disabled = !myTurn || pl.didDrawThisTurn || m.bag.length===0;
      if(!pl.didDrawThisTurn && myTurn && m.bag.length>0) $("btnDraw").classList.add("pulse");
      else $("btnDraw").classList.remove("pulse");

      // Selection + verification
      const ctx = { kitchenOpen: m.kitchenOpen };
      const selTiles = selectedTilesP1();
      const best = bestQualifyingRecipe(selTiles, ctx);

      const canOrder = myTurn && !!best;
      $("btnOrderUpFromPrep").disabled = !canOrder;
      $("btnOrderUpFromPrep").classList.toggle("pulseOrder", canOrder);
      $("btnOrderUpFromPrep").textContent = t("orderUp");

      // Prep loaded hint (minimal)
      $("prepLoadedHint").textContent = best ? `${best.name} ‚Ä¢ ${best.pts} pts` : (selTiles.length ? "Building‚Ä¶" : "Empty");
      $("prepHint").textContent = best ? "‚úÖ Ready for Order Up!" : (selTiles.length ? "Keep selecting‚Ä¶ (or clear)" : "");

      // Prep Window slots
      const slotFill = assignSelectionToPrepSlots(pl, state.ui.selectedIds);
      $("prepCarousel").innerHTML = PREP_SLOTS.map((s, i)=>{
        const tObj = slotFill[i];
        const filled = !!tObj;
        const cat = filled ? ingredientCategory(tObj.name) : "";
        const txt = filled ? escapeHtml(tObj.name) : "Empty";
        return `
          <div class="slotCard" ${filled ? `data-tile-id="${escapeHtml(tObj.id)}"` : ""}>
            <div class="slotLabel">${escapeHtml(s.label)}</div>
            <div class="slotValue ${filled ? "slotFilled" : "slotEmpty"} ${filled ? `cat-${cat}` : ""}">
              ${txt}
            </div>
          </div>
        `;
      }).join("");

      // Hand groups
      const grouped = groupBy(pl.hand, t0 => ingredientCategory(t0.name));
      const order = ["tortilla","protein","cheese","wet","drytop","wild","other"];

      $("handTiles").innerHTML = `
        <div class="handGroups">
          ${order.filter(cat => (grouped[cat]||[]).length).map(cat=>{
            const tiles = grouped[cat];
            return `
              <div class="handGroup">
                <div class="handGroupTitle">
                  <span>${escapeHtml(categoryLabel(cat))}</span>
                  <span class="count">${tiles.length}</span>
                </div>
                <div class="tiles">
                  ${tiles.map(ti=>{
                    const inSel = state.ui.selectedIds.includes(ti.id);
                    const wet = isWet(ti.name) ? "wet" : "";
                    const wild = isWild(ti.name) ? "wild" : "";
                    return `
                      <span class="tile ${inSel?"sel":""} ${wet} ${wild} cat-${cat}" data-htile="${escapeHtml(ti.id)}">
                        ${escapeHtml(ti.name)}
                      </span>
                    `;
                  }).join("")}
                </div>
              </div>
            `;
          }).join("")}
        </div>
      `;
    }

    function renderScores(){
      const m = state.match;
      const pl = p1();

      $("scoreModePill").textContent = state.settings.mode==="campaign" ? "Campaign" : "Standard";
      $("scoreCurrent").textContent = `Current: ${pl.score}`;
      $("scoreServedMuted").textContent = `Served this hand: ${pl.servedThisHand}`;

      const players = Object.values(m.players);

      $("scoreList").innerHTML = players.map(p=>{
        const col = playerColor(p.id);
        const tintA = hexToRgba(col,.18);

        const dishLines = (p.logThisHand || []).map(ev=>{
          const extra = ev.type==="remix" ? ` <span class="muted2 small">(from ${escapeHtml(ev.from || "‚Äî")})</span>` : "";
          return `<div class="row sp" style="gap:12px; margin-top:8px;">
            <div style="font-weight:900;">${escapeHtml(ev.name)}${extra}</div>
            <span class="badge">${ev.points}</span>
          </div>`;
        }).join("") || `<div class="muted small">No dishes served yet this hand.</div>`;

        const net = (p.remixGainThisHand || 0) - (p.remixLossThisHand || 0);
        const netTxt = net === 0 ? "0" : (net > 0 ? `+${net}` : `${net}`);

        return `
          <details class="acc" style="margin-top:12px; background: rgba(255,255,255,.03);">
            <summary>
              <span>${escapeHtml(p.name)}${p.id==="P1" ? " (You)" : ""}</span>
              <span class="badge" style="background: rgba(0,0,0,.30);">Score ${p.score}</span>
            </summary>
            <div class="accBody" style="position:relative; overflow:hidden;">
              <div style="position:absolute; inset:0; background: linear-gradient(135deg, ${tintA}, transparent 70%); opacity:.9; pointer-events:none;"></div>
              <div style="position:relative; z-index:1;">
                <div class="row wrap" style="gap:10px; margin-top:6px;">
                  <span class="pill">Served: ${p.servedThisHand}</span>
                  <span class="pill">Remix Net: ${netTxt}</span>
                </div>
                <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>
                ${dishLines}
              </div>
            </div>
          </details>
        `;
      }).join("");
    }

    function renderGameplay(){
      const m = state.match;
      const myTurn = (m.activePid==="P1");

      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));
      $("verPill").textContent = VERSION;

      $("navGame").querySelector(".tx").textContent = t("gameplay");
      $("navPrep").querySelector(".tx").textContent = t("prep");
      $("navScores").querySelector(".tx").textContent = t("scores");
      $("navSettings").querySelector(".tx").textContent = t("settings");

      $("btnPrep").textContent = t("prepDish");
      $("btnEndTurn").textContent = t("endTurn");

      $("tilesRemainBadge").textContent = `Tiles Remaining ${m.bag.length}`;
      $("kitchenBadge").textContent = m.kitchenOpen ? "Kitchen Open" : "Kitchen Closed";
      $("handBadge").textContent = `Hand ${m.handIndex}/${state.settings.handsTotal}`;
      $("turnBadge").textContent = myTurn ? "Your Turn" : `${m.players[m.activePid].name}'s Turn`;

      const ph = phaseText();
      $("phaseTitle").textContent = ph.title;
      $("phaseDesc").textContent = ph.desc;

      // Gameplay Order Up mirrors current selection (so it can light up if you prepped already)
      const ctx = { kitchenOpen: m.kitchenOpen };
      const selTiles = selectedTilesP1();
      const best = bestQualifyingRecipe(selTiles, ctx);

      const canOrder = myTurn && !!best;
      $("btnOrderUp").textContent = t("orderUp");
      $("btnOrderUp").disabled = !canOrder;
      $("btnOrderUp").classList.toggle("pulseOrder", canOrder);

      $("btnPrep").disabled = !myTurn;
      $("btnEndTurn").disabled = !myTurn;

      renderPublicLine();
    }

    function setNavActive(btnId){
      ["navGame","navPrep","navScores","navSettings"].forEach(id=>{
        $(id).classList.toggle("active", id===btnId);
      });
    }

    function render(){
      if(!state.match) newMatch();

      ["pageGameplay","pagePrep","pageScores","pageSettings"].forEach(id=> $(id).classList.remove("on"));
      if(state.ui.page==="gameplay"){ $("pageGameplay").classList.add("on"); setNavActive("navGame"); }
      if(state.ui.page==="prep"){ $("pagePrep").classList.add("on"); setNavActive("navPrep"); }
      if(state.ui.page==="scores"){ $("pageScores").classList.add("on"); setNavActive("navScores"); }
      if(state.ui.page==="settings"){ $("pageSettings").classList.add("on"); setNavActive("navSettings"); }

      fillSettings();
      renderGameplay();
      renderPrep();
      renderScores();
    }

    function boot(){
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      if(state.match){
        state.match.players["P1"].color = state.settings.accent;
        const cpuCols = ensureUniqueCpuColors();
        if(state.match.players["P2"]) state.match.players["P2"].color = cpuCols[0];
        if(state.match.players["P3"]) state.match.players["P3"].color = cpuCols[1];
        if(state.match.players["P4"]) state.match.players["P4"].color = cpuCols[2];
      }

      if(state.match) beginTurn(state.match.activePid);
      render();
    }

    boot();
  </script>
</body>
</html>
