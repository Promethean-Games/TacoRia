<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Taco Ria</title>

  <style>
    :root{
      --bg:#050608;
      --bg2:#0a0c10;
      --panel:#0c0f14;
      --panel2:#0b0d11;
      --text:#f3f4f6;
      --muted:rgba(243,244,246,.70);
      --muted2:rgba(243,244,246,.52);

      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.14);

      --accent:#00e5ff;
      --accentSoft: rgba(0,229,255,.14);

      --danger:#ff3b30;

      --radius:20px;
      --pad:16px;
      --gap:12px;
      --shadow: 0 18px 45px rgba(0,0,0,.55);

      --navH:56px;
      color-scheme: dark;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(900px 380px at 18% 0%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(780px 360px at 85% 10%, rgba(255,255,255,.05), transparent 65%),
        radial-gradient(820px 420px at 50% 115%, rgba(0,0,0,.75), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow-x:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .shell{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      width:100%;
      margin:0 auto;
      max-width: 980px;
    }
    @media (max-width: 430px){ .shell{ max-width: 390px; } }

    header{ padding: 14px 14px 10px; min-height:56px; }
    main{ flex:1; padding: 0 14px calc(var(--navH) + env(safe-area-inset-bottom) + 18px); }

    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ min-width:0; }
    .wrap{ flex-wrap:wrap; }
    .sp{ justify-content:space-between; }

    .pageTitle{
      font-weight:1000;
      letter-spacing:.2px;
      line-height:1.08;
      font-size: clamp(20px, 4.7vw, 28px);
    }
    .small{ font-size:12px; }
    .muted{ color:var(--muted); }
    .muted2{ color:var(--muted2); }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.065), rgba(255,255,255,.035));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: var(--shadow);
    }

    .heroPhase{
      position:relative;
      overflow:hidden;
    }
    .heroPhase::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(600px 240px at 20% 0%, rgba(255,255,255,.08), transparent 65%),
        radial-gradient(520px 240px at 85% 10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(540px 260px at 50% 120%, rgba(0,0,0,.60), transparent 55%);
      pointer-events:none;
    }
    .heroPhase > *{ position:relative; z-index:1; }

    .pills{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    button{
      border:1px solid var(--stroke2);
      background: rgba(0,0,0,.35);
      color:var(--text);
      border-radius: 18px;
      padding: 12px 14px;
      font-weight:1000;
      letter-spacing:.2px;
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .btnTiny{ padding:8px 10px; border-radius:14px; font-size:12px; }
    .ghost{ background: rgba(0,0,0,.20); }
    .primary{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border-color: rgba(255,255,255,.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 20px rgba(0,0,0,.55);
    }
    .danger{
      background: linear-gradient(180deg, rgba(255,59,48,.22), rgba(255,59,48,.10));
      border-color: rgba(255,59,48,.35);
    }

    .jumbo{
      min-height: 64px;
      font-size: 18px;
      border-radius: 20px;
      width:100%;
    }
    @media (max-width: 430px){
      .jumbo{ min-height: 68px; font-size: 19px; }
    }

    @keyframes pulseGlow{
      0%   { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
      50%  { transform: translateY(-1px); box-shadow: 0 0 0 1px rgba(255,255,255,.10), 0 0 32px rgba(0,229,255,.28); }
      100% { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
    }
    .pulse{ animation: pulseGlow 1.55s ease-in-out infinite; }
    .pulseOrder{ animation: pulseGlow 1.25s ease-in-out infinite; }

    .actionsTray{
      position: sticky;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom));
      z-index: 30;
    }
    @media (max-width: 520px), (max-height: 720px){
      .actionsTray{ position: static; bottom: auto; }
    }
    .actionsStack{ display:flex; flex-direction:column; gap:10px; }

    .tiles{ display:flex; flex-wrap:wrap; gap:8px; }
    .tile{
      max-width:100%;
      overflow-wrap:anywhere;
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.14);
      font-weight: 900;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      --catTint: rgba(255,255,255,.06);
      background: linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.sel{
      outline: 2px solid rgba(0,229,255,.55);
      transform: translateY(-1px);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.wild{ border-color: rgba(255,255,255,.28); box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset; }

    .handGroups{ display:flex; flex-direction:column; gap:12px; }
    .handGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(0,0,0,.22);
      padding:10px;
    }
    .handGroupTitle{
      font-weight:1000;
      font-size:12px;
      letter-spacing:.18px;
      color: var(--muted);
      margin-bottom:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .handGroupTitle .count{ opacity:.75; font-weight:1000; }

    .tile.cat-tortilla{ --catTint: rgba(255,204,0,.18); border-color: rgba(255,204,0,.30); }
    .tile.cat-protein { --catTint: rgba(255,59,48,.16);  border-color: rgba(255,59,48,.28); }
    .tile.cat-cheese  { --catTint: rgba(255,245,200,.14); border-color: rgba(255,245,200,.24); }
    .tile.cat-wet     { --catTint: rgba(0,229,255,.14); border-color: rgba(0,229,255,.24); }
    .tile.cat-drytop  { --catTint: rgba(163,255,18,.12); border-color: rgba(163,255,18,.22); }
    .tile.cat-wild    { --catTint: rgba(255,255,255,.10); border-color: rgba(255,255,255,.26); }
    .tile.cat-other   { --catTint: rgba(179,107,255,.14); border-color: rgba(179,107,255,.24); }

    .pubGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      padding:12px;
      margin-bottom:12px;
    }
    .pubGroupTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
      margin-bottom: 8px;
    }
    .pubDishRow{
      border:1px solid var(--stroke);
      border-radius:16px;
      background: rgba(0,0,0,.45);
      padding:10px;
      margin-top:10px;
      position:relative;
      overflow:hidden;
    }
    .pubDishRow::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, var(--tintA), transparent 70%);
      opacity:.95;
      pointer-events:none;
    }
    .pubDishRow > *{ position:relative; z-index:1; }
    .pubDishMeta{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
    }

    details.acc{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    details.acc + details.acc{ margin-top:10px; }
    details.acc summary{
      list-style:none;
      cursor:pointer;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:1000;
    }
    details.acc summary::-webkit-details-marker{ display:none; }
    .accBody{ padding: 0 14px 14px; }
    .label{ font-size:12px; color:var(--muted); margin-bottom:6px; font-weight:900; }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; line-height: 1.35; }

    select, input[type="number"]{
      width:100%;
      padding:12px 40px 12px 14px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background:#0b0b0b;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      appearance:none;
      -webkit-appearance:none;
      outline:none;
    }
    select option{ background:#0b0b0b; color: rgba(255,255,255,.92); }
    .selectWrap{ position:relative; }
    .selectWrap::after{
      content:"▾";
      position:absolute;
      right:14px; top:50%;
      transform: translateY(-50%);
      opacity:.75;
      pointer-events:none;
      font-weight:1000;
    }

    nav.footer{
      position:fixed;
      left:0; right:0; bottom:0;
      height: var(--navH);
      padding-bottom: env(safe-area-inset-bottom);
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      z-index: 40;
    }
    .navBtn{
      flex:1;
      min-height:56px;
      border:none;
      border-right: 1px solid rgba(255,255,255,.06);
      background: transparent;
      color: rgba(255,255,255,.86);
      font-weight:1000;
      border-radius: 0;
      padding: 10px 6px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      font-size: 13px;
      letter-spacing:.15px;
    }
    .navBtn:last-child{ border-right:none; }
    .navBtn.active{
      color:#fff;
      background: radial-gradient(320px 120px at 50% 0%, rgba(0,229,255,.20), transparent 60%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }

    #toastWrap{
      position:fixed;
      left:0; right:0;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom) + 12px);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 80;
    }
    .toast{
      max-width:min(560px, calc(100% - 24px));
      background: rgba(0,0,0,.78);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,.65);
      font-weight: 900;
      pointer-events:none;
    }

    #modalWrap{
      position:fixed; inset:0;
      background: var(--bg);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 90;
    }
    #modalWrap.on{ display:flex; }
    .modal{
      width: min(560px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: 0 22px 60px rgba(0,0,0,.70);
      padding: 14px;
    }
    .modal h3{ margin: 4px 0 8px; font-size: 18px; }
    .modal .body{ color: var(--muted); font-weight: 900; line-height: 1.35; }
    .modal .foot{ margin-top: 12px; display:flex; gap:10px; justify-content:flex-end; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .page{ display:none; }
    .page.on{ display:block; }

    .prepRow{
      border:1px solid var(--stroke);
      border-radius: 18px;
      background: rgba(0,0,0,.26);
      padding: 12px;
      overflow:hidden;
    }
    .prepTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
      font-weight:1000;
    }
    .prepSlots{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:10px;
    }
    @media (max-width: 430px){
      .prepSlots{ grid-template-columns: repeat(2, 1fr); }
    }
    .slot{
      border-radius: 16px;
      border: 1px dashed rgba(255,255,255,.20);
      background: rgba(255,255,255,.03);
      padding: 10px;
      min-height: 58px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      user-select:none;
    }
    .slot.filled{
      border-style: solid;
      border-color: rgba(255,255,255,.18);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        rgba(0,0,0,.30);
    }
    .slot .sName{
      font-weight: 1000;
      font-size: 13px;
      color: rgba(243,244,246,.94);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:100%;
    }
    .slot .sHint{
      font-weight: 900;
      font-size: 12px;
      color: rgba(243,244,246,.42);
    }

    /* Draw Modal */
    .drawMeta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 10px;
    }
    .drawRow{
      display:flex;
      gap:12px;
      margin-top: 12px;
      width:100%;
    }
    .drawRow.busy{ pointer-events:none; opacity:.98; }
    .drawRow .tileCard{ flex:1; min-width:0; }

    @media (max-width: 430px){
      .drawRow{ gap:10px; }
    }
    @media (max-width: 360px){
      .drawRow{ gap:8px; }
    }

    @keyframes slowShimmer{
      0%   { transform: translateX(-12%); opacity:.22; }
      50%  { transform: translateX(12%);  opacity:.32; }
      100% { transform: translateX(-12%); opacity:.22; }
    }
    @keyframes slowBreath{
      0%   { box-shadow: 0 10px 26px rgba(0,0,0,.55); transform: translateY(0); }
      50%  { box-shadow: 0 14px 32px rgba(0,0,0,.66); transform: translateY(-1px); }
      100% { box-shadow: 0 10px 26px rgba(0,0,0,.55); transform: translateY(0); }
    }

    .tileCard{
      perspective: 900px;
      min-height: 94px;
    }
    @media (max-width: 430px){
      .tileCard{ min-height: 86px; }
    }
    .tileFlip{
      position:relative;
      width:100%;
      height:100%;
      transform-style:preserve-3d;
      transition: transform 650ms cubic-bezier(.2,.9,.2,1);
      border-radius:18px;
    }
    .tileFace{
      position:absolute;
      inset:0;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      overflow:hidden;
      backface-visibility:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 10px 8px;
      user-select:none;
    }

    .tileBack{
      background:
        radial-gradient(340px 140px at 25% 0%, rgba(255,255,255,.08), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      cursor:pointer;
    }
    .tileBack::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(520px 240px at 10% 0%, rgba(0,229,255,.16), transparent 60%),
        radial-gradient(520px 240px at 90% 10%, rgba(255,255,255,.06), transparent 65%);
      opacity:.55;
      pointer-events:none;
    }
    .tileBack::after{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, rgba(0,0,0,.25), rgba(0,0,0,.55));
      opacity:.55;
      pointer-events:none;
    }
    .tileBackInner{
      position:relative;
      z-index:1;
      width:100%;
      font-weight:1000;
      letter-spacing:.2px;
      color: rgba(243,244,246,.78);
      font-size: 13px;
      line-height:1.1;
      padding: 0 6px;
    }

    /* Strict mode shimmer only */
    .strictMode .tileBack{ animation: slowBreath 4.6s ease-in-out infinite; }
    .strictMode .tileBack::before{ animation: slowShimmer 7.8s ease-in-out infinite; }

    .tilePickOutline{
      outline: 2px solid rgba(0,229,255,.55);
      box-shadow: 0 0 0 1px rgba(255,255,255,.08), 0 0 30px rgba(0,229,255,.24);
    }

    .tileFront{
      transform: rotateY(180deg);
      background:
        radial-gradient(420px 160px at 15% 0%, rgba(255,255,255,.08), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,.55));
      border-color: rgba(255,255,255,.18);
    }
    .tileFront .frontName{
      font-weight:1000;
      font-size: 14px;
      color: rgba(243,244,246,.95);
      padding: 0 4px;
    }
    .tileFlip.reveal{ transform: rotateY(180deg); }

    /* Tutorial */
    .tutWrap{
      position:relative;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      background: rgba(0,0,0,.22);
    }
    .tutStrip{
      display:flex;
      width:100%;
      overflow-x:auto;
      scroll-snap-type:x mandatory;
      -webkit-overflow-scrolling:touch;
    }
    .tutPage{
      flex: 0 0 100%;
      scroll-snap-align:start;
      padding: 14px;
      min-height: 220px;
    }
    .tutTitle{ font-weight:1000; font-size:16px; margin-bottom:6px; }
    .tutText{ color: var(--muted); font-weight:900; line-height:1.35; }
    .tutDots{
      display:flex; gap:8px; justify-content:center;
      margin-top:10px;
      opacity:.85;
    }
    .dot{
      width:8px; height:8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.05);
    }
    .dot.on{ background: rgba(0,229,255,.45); border-color: rgba(0,229,255,.55); }

    .tutMedia{
      margin-top:12px;
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      overflow:hidden;
      background: rgba(0,0,0,.25);
    }
    .tutMedia img{
      width:100%;
      display:block;
      aspect-ratio: 16 / 9;
      object-fit: cover;
    }
  </style>
</head>

<body>
  <div class="shell">
    <header>
      <div class="row sp">
        <div>
          <div class="row" style="gap:10px;">
            <div class="pageTitle" id="appNameH">Taco Ria</div>
          </div>
          <div class="muted small" id="subTitle">Private Prep • Public Line • Remix</div>
        </div>
        <button class="ghost btnTiny" id="btnNewMatchTop">New Match</button>
      </div>
    </header>

    <main>
      <!-- GAMEPLAY -->
      <section class="page on" id="pageGameplay">
        <div class="card heroPhase" style="margin-bottom:12px;">
          <div class="pills" style="margin-top:2px;">
            <span class="pill" id="tilesRemainBadge">Tiles Remaining 0</span>
            <span class="pill" id="kitchenBadge">Kitchen Closed</span>
            <span class="pill" id="handBadge">Hand 1/12</span>
            <span class="pill" id="turnBadge">Your Turn</span>
          </div>

          <div style="margin-top:12px;">
            <div style="font-weight:1000; font-size:16px;" id="phaseTitle">Not Seated Yet</div>
            <div class="muted" id="phaseDesc">Serve 10+ points in one turn to open the kitchen.</div>
          </div>
        </div>

        <div class="actionsTray">
          <div class="card">
            <div class="actionsStack">
              <button class="primary jumbo" id="btnPrep">Prep a Dish</button>
              <button class="primary jumbo" id="btnOrderUp">Order Up!</button>
              <button class="danger jumbo" id="btnEndTurn">End Turn</button>
            </div>
            <div class="muted small" style="margin-top:10px;" id="actionHint">
              Prep your ingredients, then Order Up. One draw per turn.
            </div>

            <div class="prepRow" style="margin-top:12px;">
              <div class="prepTop">
                <div style="font-weight:1000;">Prep Table</div>
                <div class="muted2 small" id="gpPrepLoadedHint">0/10 loaded</div>
              </div>
              <div class="prepSlots" id="gpPrepSlots"></div>
              <div class="muted small" style="margin-top:10px;" id="gpPrepStatus">No dish detected yet.</div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Public Line / Window</div>
            <span class="pill" id="lineSummary">0 dishes</span>
          </div>
          <div id="publicLine"></div>
        </div>
      </section>

      <!-- PREP -->
      <section class="page" id="pagePrep">
        <div class="card">
          <div class="row sp" style="margin-bottom:8px;">
            <div style="font-weight:1000;">Prep Table</div>
            <span class="badge" id="prepTurnBadge">Your Turn</span>
          </div>

          <div class="prepRow" style="margin-bottom:12px;">
            <div class="prepTop">
              <div>Prep Window</div>
              <div class="muted2 small" id="prepLoadedHint">0/10 loaded</div>
            </div>
            <div class="prepSlots" id="prepSlots"></div>
            <div class="muted small" style="margin-top:10px;" id="prepStatus">No dish detected yet.</div>
          </div>

          <div class="row wrap" style="gap:10px; justify-content:space-between; margin-bottom:12px;">
            <button class="primary jumbo" id="btnDraw">Draw Tile</button>
            <button class="primary jumbo" id="btnOrderUpFromPrep">Order Up!</button>
          </div>

          <div class="row wrap" style="gap:10px; justify-content:space-between; margin-bottom:12px;">
            <button class="ghost jumbo" id="btnAutoPlate">Auto-Plate</button>
            <button class="ghost jumbo" id="btnClearPrep">Clear Prep</button>
          </div>

          <div class="row wrap" style="gap:10px; justify-content:space-between; margin-bottom:12px;">
            <button class="ghost btnTiny" id="btnAutoRemix">Auto-Remix</button>
          </div>

          <details class="acc" open>
            <summary>
              <span>Your Hand</span>
              <span class="muted2 small" id="handCountHint">0 tiles</span>
            </summary>
            <div class="accBody">
              <div id="handTiles"></div>
              <div class="hint" id="handHint" style="margin-top:10px;">
                Tap hand tiles to add/remove them from your Prep Window.
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Menu Guide</span>
              <span class="muted2 small">Reference</span>
            </summary>
            <div class="accBody" id="menuGuideBody"></div>
          </details>
        </div>
      </section>

      <!-- REMIX -->
      <section class="page" id="pageRemix">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Remix</div>
            <span class="badge" id="remixGateBadge">Kitchen Closed</span>
          </div>

          <div class="muted small" id="remixHint">
            Select 1+ tile(s) from your hand, then tap Remix on a dish in the window. Successful remix = +1 point.
          </div>

          <div class="row wrap" style="gap:10px; margin-top:12px;">
            <button class="ghost" id="btnRemixClearSel">Clear Selection</button>
          </div>

          <details class="acc" open style="margin-top:12px;">
            <summary>
              <span>Selected Tiles</span>
              <span class="muted2 small" id="remixSelCount">0 selected</span>
            </summary>
            <div class="accBody">
              <div id="remixSelectedTiles" class="tiles"></div>
              <div class="hint">Tap a selected tile to unselect it.</div>
            </div>
          </details>

          <details class="acc" open style="margin-top:10px;">
            <summary>
              <span>Public Line</span>
              <span class="muted2 small" id="remixLineCount">0 dishes</span>
            </summary>
            <div class="accBody">
              <div id="remixPublicLine"></div>
            </div>
          </details>

          <details class="acc" open style="margin-top:10px;">
            <summary>
              <span>Your Hand</span>
              <span class="muted2 small" id="remixHandCount">0 tiles</span>
            </summary>
            <div class="accBody">
              <div id="remixHandTiles"></div>
              <div class="hint">Tap tiles to select/unselect for remix.</div>
            </div>
          </details>
        </div>
      </section>

      <!-- SCORES -->
      <section class="page" id="pageScores">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Scores</div>
            <span class="badge" id="scoreModePill">Standard</span>
          </div>

          <div class="row wrap" style="gap:10px; margin-bottom:12px;">
            <span class="pill" id="scoreCurrent">Current: 0</span>
            <span class="pill muted" id="scoreServedMuted">Served this hand: 0</span>
          </div>

          <div id="scoreList"></div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="page" id="pageSettings">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Settings</div>
          </div>
          <div class="muted small">Primary theme stays black. Choose a high-contrast accent.</div>

          <details class="acc" open style="margin-top:12px;">
            <summary>
              <span>Match</span>
              <span class="muted2 small">Mode + Players</span>
            </summary>
            <div class="accBody">
              <div class="row wrap" style="gap:12px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Mode</div>
                  <div class="selectWrap">
                    <select id="selMode">
                      <option value="standard">Standard Match</option>
                      <option value="campaign">Campaign</option>
                    </select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Players</div>
                  <div class="selectWrap">
                    <select id="selPlayers">
                      <option value="2">2 Players</option>
                      <option value="3">3 Players</option>
                      <option value="4" selected>4 Players</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">CPU Difficulty (Standard only)</div>
                  <div class="selectWrap">
                    <select id="selDifficulty"></select>
                  </div>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Hands (Standard only)</div>
                  <input type="number" id="inpHands" min="1" max="12" value="12" />
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Tiles per Player</div>
                  <input type="number" id="inpTilesPerPlayer" min="8" max="24" value="16" />
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Decks</div>
                  <div class="selectWrap">
                    <select id="selDecks">
                      <option value="1">1 Deck</option>
                      <option value="2" selected>2 Decks (Recommended)</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Theme</span>
              <span class="muted2 small">Accent Color</span>
            </summary>
            <div class="accBody">
              <div class="label">Accent</div>
              <div class="selectWrap">
                <select id="selAccent"></select>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Language</span>
              <span class="muted2 small">EN / ES / FR / DE</span>
            </summary>
            <div class="accBody">
              <div class="label">App Language</div>
              <div class="selectWrap">
                <select id="selLang">
                  <option value="en">English</option>
                  <option value="es">Español</option>
                  <option value="fr">Français</option>
                  <option value="de">Deutsch</option>
                </select>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Tutorial</span>
              <span class="muted2 small">View / Hide</span>
            </summary>
            <div class="accBody">
              <button class="primary" id="btnViewTutorial">View Tutorial</button>
              <div class="hint">Tutorial auto-shows on first app start. It may show again after your 2nd draw unless you hide it.</div>
            </div>
          </details>
        </div>
      </section>
    </main>
  </div>

  <nav class="footer">
    <button class="navBtn active" id="navGame">Gameplay</button>
    <button class="navBtn" id="navPrep">Prep</button>
    <button class="navBtn" id="navRemix">Remix</button>
    <button class="navBtn" id="navScores">Scores</button>
    <button class="navBtn" id="navSettings">Settings</button>
  </nav>

  <div id="toastWrap"></div>

  <div id="modalWrap">
    <div class="modal">
      <h3 id="modalTitle">Modal</h3>
      <div class="body" id="modalBody"></div>
      <div class="foot" id="modalFoot"></div>
    </div>
  </div>

  <script>
(function(){
  "use strict";

  var VERSION = "v0.9.2.1";
  var LS_KEY  = "taco_ria_state_v0921";

  function $(id){ return document.getElementById(id); }
  function on(id, evt, fn){
    var el = $(id);
    if(!el) return false;
    el.addEventListener(evt, fn);
    return true;
  }
  function setClick(id, fn){
    var el = $(id);
    if(!el) return false;
    el.onclick = fn;
    return true;
  }

  function escapeHtml(s){
    s = (s === null || s === undefined) ? "" : String(s);
    return s.replace(/&/g,"&amp;")
            .replace(/</g,"&lt;")
            .replace(/>/g,"&gt;")
            .replace(/"/g,"&quot;")
            .replace(/'/g,"&#039;");
  }
  function randInt(n){ return Math.floor(Math.random() * n); }
  function shuffle(a){
    for (var i=a.length-1;i>0;i--){
      var j = Math.floor(Math.random()*(i+1));
      var t = a[i]; a[i]=a[j]; a[j]=t;
    }
    return a;
  }
  function nowId(prefix){
    prefix = prefix || "id";
    return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }
  function hexToRgba(hex, a){
    hex = (hex || "#ffffff").replace("#","").trim();
    var full = hex.length === 3 ? (hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]) : (hex + "000000").slice(0,6);
    var n = parseInt(full, 16);
    var r=(n>>16)&255, g=(n>>8)&255, b=n&255;
    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
  }
  function groupBy(arr, keyFn){
    var m = {};
    arr = arr || [];
    for (var i=0;i<arr.length;i++){
      var it = arr[i];
      var k = keyFn(it);
      if(!m[k]) m[k] = [];
      m[k].push(it);
    }
    return m;
  }
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function toast(msg, ms){
    ms = ms || 2200;
    var wrap = $("toastWrap");
    if(!wrap) return;
    wrap.innerHTML = '<div class="toast">' + escapeHtml(msg) + '</div>';
    if(toast._t) clearTimeout(toast._t);
    toast._t = setTimeout(function(){ wrap.innerHTML=""; }, ms);
  }

  // Global error visibility (helps you instantly see the real reason “buttons don’t work”)
  window.addEventListener("error", function(e){
    try{
      toast("JS error: " + (e && e.message ? e.message : "unknown"), 7000);
    }catch(_){}
  });

  // Modal
  var modalMode = null;
  function openModal(title, htmlBody, footButtons){
    var mt = $("modalTitle"), mb = $("modalBody"), mf = $("modalFoot"), mw = $("modalWrap");
    if(!mt || !mb || !mf || !mw) return;

    mt.textContent = title;
    mb.innerHTML = htmlBody;
    mf.innerHTML = "";

    footButtons = footButtons || [];
    for (var i=0;i<footButtons.length;i++){
      (function(b){
        var btn = document.createElement("button");
        btn.className = b.className || "ghost";
        btn.textContent = b.text || "OK";
        btn.onclick = function(){ if (typeof b.onClick === "function") b.onClick(); };
        mf.appendChild(btn);
      })(footButtons[i]);
    }
    mw.classList.add("on");
  }
  function closeModal(){
    var mw = $("modalWrap"), mb = $("modalBody");
    if(mw) mw.classList.remove("on");
    if(mb) mb.onclick = null;
    modalMode = null;
  }

  // i18n
  var I18N = {
    en:{ gameplay:"Gameplay", prep:"Prep", remix:"Remix", scores:"Scores", settings:"Settings", orderUp:"Order Up!", drawTile:"Draw Tile", endTurn:"End Turn", prepDish:"Prep a Dish", cancel:"Cancel", close:"Close", start:"Start", hide:"Hide" },
    es:{ gameplay:"Gameplay", prep:"Preparación", remix:"Remix", scores:"Puntos", settings:"Ajustes", orderUp:"¡Orden lista!", drawTile:"Robar ficha", endTurn:"Terminar turno", prepDish:"Preparar plato", cancel:"Cancelar", close:"Cerrar", start:"Iniciar", hide:"Ocultar" },
    fr:{ gameplay:"Gameplay", prep:"Prépa", remix:"Remix", scores:"Scores", settings:"Réglages", orderUp:"À l’envoi !", drawTile:"Piocher", endTurn:"Fin du tour", prepDish:"Préparer", cancel:"Annuler", close:"Fermer", start:"Démarrer", hide:"Masquer" },
    de:{ gameplay:"Gameplay", prep:"Vorbereiten", remix:"Remix", scores:"Punkte", settings:"Einstellungen", orderUp:"Bestellung raus!", drawTile:"Ziehen", endTurn:"Zug beenden", prepDish:"Vorbereiten", cancel:"Abbrechen", close:"Schließen", start:"Start", hide:"Ausblenden" }
  };
  function t(key){
    var lang = (state && state.settings && state.settings.lang) ? state.settings.lang : "en";
    var pack = I18N[lang] || I18N.en;
    return pack[key] || I18N.en[key] || key;
  }
  function getAppName(){
    var el = $("appNameH");
    return (el && el.textContent ? el.textContent : (document.title || "Taco Ria")).trim();
  }

  // Difficulty
  var DIFFS = ["Beginner","Easy","Medium","Difficult","Master Chef"];
  function isLoose(diff){ return diff==="Beginner" || diff==="Easy" || diff==="Medium"; }
  function isStrict(diff){ return diff==="Difficult" || diff==="Master Chef"; }

  // Accents
  var ACCENTS = [
    {name:"Neon Cyan", val:"#00e5ff"},
    {name:"Signal Yellow", val:"#ffcc00"},
    {name:"Lime", val:"#a3ff12"},
    {name:"Hot Pink", val:"#ff2bd6"},
    {name:"Orange", val:"#ff8a00"},
    {name:"Ice", val:"#b3f6ff"},
    {name:"Violet", val:"#b36bff"},
    {name:"Red", val:"#ff3b30"}
  ];
  var CPU_BASE_COLORS = ["#ff3b30","#b36bff","#ffcc00","#a3ff12"];
  function ensureUniqueCpuColors(){
    var used = {};
    used[String((state.settings && state.settings.accent) || "#00e5ff").toLowerCase()] = true;
    var pool = [];
    for(var i=0;i<ACCENTS.length;i++) pool.push(ACCENTS[i].val.toLowerCase());
    var out = [];
    for(var j=0;j<CPU_BASE_COLORS.length;j++){
      var col = CPU_BASE_COLORS[j].toLowerCase();
      if(used[col]){
        for(var k=0;k<pool.length;k++){
          if(!used[pool[k]]){ col = pool[k]; break; }
        }
      }
      used[col] = true;
      out.push(col);
    }
    return out;
  }

  // Deck (54-card list per deck)
  var DECK_ING_COUNTS = [
    ["Fish",1],
    ["Ground Beef",2],
    ["Shredded Chicken",2],
    ["Carne Guisada",1],
    ["Beef Fajita",1],
    ["Carnitas",1],
    ["Egg",2],
    ["Chicken Fajita",1],
    ["Chorizo",2],
    ["Tortilla Chips",3],
    ["Flour Tortillas",3],
    ["Corn Tortillas",2],
    ["Shredded yellow Cheese",2],
    ["Shredded white cheese",2],
    ["Rice",2],
    ["Charro Beans",1],  /* non-wet */
    ["Refried Beans",1],
    ["Black Beans",1],
    ["Cilantro",2],
    ["Jalapenos",1],
    ["Lettuce",1],
    ["Lime Juice",2],
    ["Onion",2],
    ["Tomato",2],
    ["Sour Cream",1],
    ["Avocado",2],
    ["Salsa Roja",2],
    ["Salsa Verde",2],
    ["Queso",2],
    ["Guacamole",3],
    ["Grocery Run",2]
  ];
  function buildDeck(decks){
    decks = decks || 2;
    var tiles = [];
    for (var d=0; d<decks; d++){
      for (var i=0;i<DECK_ING_COUNTS.length;i++){
        var name = DECK_ING_COUNTS[i][0];
        var count = DECK_ING_COUNTS[i][1];
        for (var c=0;c<count;c++){
          tiles.push({ id: nowId("t"), name: name });
        }
      }
    }
    return shuffle(tiles);
  }

  // Ingredient classifiers
  function isWild(n){ return n==="Grocery Run"; }
  function isTortilla(n){ return n==="Corn Tortillas" || n==="Flour Tortillas"; }
  function isEgg(n){ return n==="Egg"; }
  function isProtein(n){
    return n==="Fish" || n==="Ground Beef" || n==="Shredded Chicken" || n==="Carne Guisada" ||
           n==="Chicken Fajita" || n==="Beef Fajita" || n==="Carnitas" || n==="Chorizo" || n==="Egg";
  }
  function isCheese(n){ return n==="Shredded yellow Cheese" || n==="Shredded white cheese"; }
  function isSauce(n){ return n==="Salsa Roja" || n==="Salsa Verde"; }
  function isWet(n){ return n==="Salsa Roja" || n==="Salsa Verde" || n==="Queso" || n==="Guacamole"; } // Charro Beans NOT wet
  function isDip(n){ return n==="Salsa Roja" || n==="Salsa Verde" || n==="Guacamole" || n==="Queso"; }
  function isBean(n){ return n==="Charro Beans" || n==="Refried Beans" || n==="Black Beans"; }
  function isDryTopping(n){
    return n==="Lettuce" || n==="Onion" || n==="Tomato" || n==="Cilantro" || n==="Jalapenos" || n==="Avocado" ||
           isCheese(n) || n==="Sour Cream";
  }
  function ingredientCategory(name){
    if(isWild(name)) return "wild";
    if(isTortilla(name)) return "tortilla";
    if(isProtein(name)) return "protein";
    if(isCheese(name)) return "cheese";
    if(isWet(name)) return "wet";
    if(isDryTopping(name)) return "drytop";
    return "other";
  }
  function categoryLabel(cat){
    var map = {
      tortilla:"Tortillas", protein:"Proteins", cheese:"Cheese", wet:"Wet Toppings",
      drytop:"Dry Toppings", wild:"Grocery Run", other:"Other"
    };
    return map[cat] || cat;
  }

  // Recipes
  var GRILL_PROTEINS = { "Fish":true, "Chicken Fajita":true, "Beef Fajita":true };
  var RECIPES = [
    { key:"breakfastTaco", name:"Breakfast Taco", base:3, kind:"breakfast" },
    { key:"hardTaco", name:"Hard Shell Taco", base:5, kind:"taco", tortilla:"Corn Tortillas" },
    { key:"softTaco", name:"Soft Taco", base:5, kind:"taco", tortilla:"Flour Tortillas" },
    { key:"chorizoTaco", name:"Chorizo Taco", base:8, kind:"chorizo" },
    { key:"chipsDip", name:"Chips & Dip", base:5, kind:"chipsDip" },
    { key:"kidsRB", name:"Kid's Rice and Beans", base:2, kind:"kidsRB" }, /* Starter Pass + +1 if tortilla OR avocado */
    { key:"pico", name:"Pico de Gallo", base:8, kind:"pico" },
    { key:"ench", name:"Enchiladas", base:10, kind:"ench" }
  ];
  function recipeByKey(k){
    for(var i=0;i<RECIPES.length;i++){ if(RECIPES[i].key===k) return RECIPES[i]; }
    return null;
  }

  var RULES = {
    openKitchenTurnPts: 10,
    wetLockedUntilKitchen: true,
    tacoDryLoose: 1,
    tacoDryStrict: 3,
    starterPassDishKeys: { chipsDip:true, kidsRB:true }
  };
  function isStarterPassDishKey(k){ return !!(RULES.starterPassDishKeys && RULES.starterPassDishKeys[k]); }

  // State
  function defaultState(){
    return {
      settings:{
        accent:"#00e5ff",
        lang:"en",
        mode:"standard",
        players:4,
        difficulty:"Easy",
        handsTotal:12,
        tilesPerPlayer:16,
        decks:2,
        tutorialHidden:false
      },
      flags:{
        tutorialIntroShown:false,
        tutorialSecondDrawShown:false,
        p1DrawCount:0
      },
      match:null,
      ui:{ page:"gameplay" }
    };
  }
  function persist(){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){}
  }
  function load(){
    try{
      var raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch(e){ return null; }
  }
  var state = load() || defaultState();

  function mkPlayer(id, name, isHuman, color){
    return {
      id:id, name:name, isHuman:isHuman,
      color:color,
      score:0,
      servedThisHand:0,
      hand:[],
      didDrawThisTurn:false,
      prepSelectedIds:[],
      remixSelectedIds:[],
      logThisHand:[],
      remixGainThisHand:0,
      remixLossThisHand:0,
      starterPassUsed:false
    };
  }
  function dealInitial(m){
    var tilesPer = state.settings.tilesPerPlayer || 16;
    for(var pid in m.players){
      if(!m.players.hasOwnProperty(pid)) continue;
      var p = m.players[pid];
      p.hand = [];
      p.prepSelectedIds = [];
      p.remixSelectedIds = [];
      p.logThisHand = [];
      p.servedThisHand = 0;
      p.remixGainThisHand = 0;
      p.remixLossThisHand = 0;
      p.didDrawThisTurn = false;
      p.starterPassUsed = false;
      for(var i=0;i<tilesPer;i++){
        var t0 = m.bag.pop();
        if(!t0) break;
        p.hand.push(t0);
      }
    }
  }
  function beginTurn(pid){
    var m = state.match;
    var p = m.players[pid];
    p.didDrawThisTurn = false;
    m.servedThisTurnPts = 0;
  }
  function p1(){ return state.match.players["P1"]; }

  function newMatch(){
    var cpuCols = ensureUniqueCpuColors();
    var pCount = parseInt(state.settings.players,10) || 4;

    var m = {
      id: nowId("m"),
      handIndex: 1,
      kitchenOpen: false,
      bag: buildDeck(parseInt(state.settings.decks,10) || 2),
      publicLine: [],
      players: {},
      activePid: "P1",
      servedThisTurnPts: 0
    };

    m.players["P1"] = mkPlayer("P1","You", true, state.settings.accent);
    if(pCount >= 2) m.players["P2"] = mkPlayer("P2","Chef Mike", false, cpuCols[0]);
    if(pCount >= 3) m.players["P3"] = mkPlayer("P3","Salsa Sam", false, cpuCols[1]);
    if(pCount >= 4) m.players["P4"] = mkPlayer("P4","Queso Queen", false, cpuCols[2]);

    dealInitial(m);
    state.match = m;
    state.ui.page = "gameplay";
    beginTurn("P1");
    persist();
    render();
    toast("New match started.");
  }

  function diffCtx(){
    var diff = state.settings.difficulty || "Easy";
    return { kitchenOpen: !!(state.match && state.match.kitchenOpen), difficulty: diff, strict: isStrict(diff), loose: isLoose(diff) };
  }

  function countOcc(names){
    var m = {};
    for (var i=0;i<names.length;i++){
      var n = names[i];
      m[n] = (m[n] || 0) + 1;
    }
    return m;
  }

  function validateRecipeForSelection(recipeKey, tileObjs, ctx){
    var r = recipeByKey(recipeKey);
    if(!r) return {ok:false, reason:"Unknown recipe."};

    tileObjs = tileObjs || [];
    var names = [];
    for(var i=0;i<tileObjs.length;i++) names.push(tileObjs[i].name);

    var occ = countOcc(names);
    var wildCount = 0;
    var nonWild = [];
    for(i=0;i<names.length;i++){
      if(isWild(names[i])) wildCount++;
      else nonWild.push(names[i]);
    }

    var hasWet = false;
    for(i=0;i<nonWild.length;i++){ if(isWet(nonWild[i])){ hasWet=true; break; } }
    if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen && hasWet){
      return {ok:false, reason:"Wet locked until Kitchen Open."};
    }

    var reqDry = ctx.strict ? RULES.tacoDryStrict : RULES.tacoDryLoose;

    if(r.kind === "breakfast"){
      var hasTort=false, hasEgg2=false;
      for(i=0;i<nonWild.length;i++){
        if(isTortilla(nonWild[i])) hasTort=true;
        if(isEgg(nonWild[i])) hasEgg2=true;
      }
      if(!hasTort && wildCount>0) hasTort=true;
      if(!hasEgg2 && wildCount>0) hasEgg2=true;
      if(!hasTort || !hasEgg2) return {ok:false, reason:"Needs tortilla + egg."};

      for(i=0;i<nonWild.length;i++){
        if(nonWild[i]==="Sour Cream" || nonWild[i]==="Charro Beans" || nonWild[i]==="Black Beans"){
          return {ok:false, reason:"Breakfast taco: no sour cream/charro/black beans."};
        }
      }
      var wetCount=0;
      for(i=0;i<nonWild.length;i++) if(isWet(nonWild[i])) wetCount++;
      if(wetCount>1) return {ok:false, reason:"Only 1 wet topping."};
      if(tileObjs.length>8) return {ok:false, reason:"Too many tiles."};
      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:r.base, grillBonus:0, extras:0, laurensLunch:false};
    }

    if(r.kind === "chipsDip"){
      if(tileObjs.length !== 2) return {ok:false, reason:"Needs 2 tiles."};
      var hasChips=false, hasDip=false;
      for(i=0;i<nonWild.length;i++){
        if(nonWild[i]==="Tortilla Chips") hasChips=true;
        if(isDip(nonWild[i])) hasDip=true;
      }
      if(!hasChips && wildCount>0) hasChips=true;
      if(!hasDip && wildCount>0) hasDip=true;
      if(!hasChips) return {ok:false, reason:"Needs chips."};
      if(!hasDip) return {ok:false, reason:"Needs a dip."};
      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:r.base, grillBonus:0, extras:0, laurensLunch:false};
    }

    if(r.kind === "kidsRB"){
      if(tileObjs.length < 2) return {ok:false, reason:"Needs Rice + 1 Bean."};
      if(tileObjs.length > 4) return {ok:false, reason:"Too many tiles."};

      var hasRice=false, hasBean=false, hasAv=false, hasTor=false;
      var extraIllegal=false;
      var tortillaCount=0, avocadoCount=0;

      for(i=0;i<nonWild.length;i++){
        var nK = nonWild[i];
        if(nK==="Rice") hasRice=true;
        else if(isBean(nK)) hasBean=true;
        else if(nK==="Avocado"){ hasAv=true; avocadoCount++; }
        else if(isTortilla(nK)){ hasTor=true; tortillaCount++; }
        else { extraIllegal=true; }
      }

      if(!hasRice && wildCount>0){ hasRice=true; wildCount--; }
      if(!hasBean && wildCount>0){ hasBean=true; wildCount--; }

      if(!hasRice || !hasBean) return {ok:false, reason:"Needs Rice + 1 Bean."};
      if(extraIllegal) return {ok:false, reason:"Only Rice + 1 Bean allowed (optional: Avocado, Tortilla)."};
      if(tortillaCount>1) return {ok:false, reason:"Only 1 tortilla allowed."};
      if(avocadoCount>1) return {ok:false, reason:"Only 1 avocado allowed."};

      var bonus = (hasTor || hasAv) ? 1 : 0;
      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:(r.base + bonus), grillBonus:0, extras:bonus, laurensLunch:false};
    }

    if(r.kind === "pico"){
      if(tileObjs.length !== 4) return {ok:false, reason:"Needs 4 tiles."};
      var need = { "Tomato":false, "Onion":false, "Cilantro":false, "Lime Juice":false };
      for(i=0;i<nonWild.length;i++){
        if(need.hasOwnProperty(nonWild[i])) need[nonWild[i]] = true;
      }
      if(wildCount>0){
        for(var k in need){
          if(need.hasOwnProperty(k) && !need[k] && wildCount>0){
            need[k]=true; wildCount--;
          }
        }
      }
      if(!need["Tomato"] || !need["Onion"] || !need["Cilantro"] || !need["Lime Juice"]){
        return {ok:false, reason:"Needs Tomato, Onion, Cilantro, Lime."};
      }
      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:r.base, grillBonus:0, extras:0, laurensLunch:false};
    }

    if(r.kind === "ench"){
      if(tileObjs.length < 4) return {ok:false, reason:"Needs more tiles."};
      var hasT=false, hasP=false, hasS=false, hasC=false;
      for(i=0;i<nonWild.length;i++){
        var nE=nonWild[i];
        if(isTortilla(nE)) hasT=true;
        else if(isProtein(nE)) hasP=true;
        else if(isSauce(nE)) hasS=true;
        else if(isCheese(nE)) hasC=true;
      }
      if(!hasT && wildCount>0) hasT=true;
      if(!hasP && wildCount>0) hasP=true;
      if(!hasS && wildCount>0) hasS=true;
      if(!hasC && wildCount>0) hasC=true;

      if(!hasT) return {ok:false, reason:"Needs tortillas."};
      if(!hasP) return {ok:false, reason:"Needs protein."};
      if(!hasS) return {ok:false, reason:"Needs sauce."};
      if(!hasC) return {ok:false, reason:"Needs cheese."};
      if(tileObjs.length > 7) return {ok:false, reason:"Too many toppings."};

      var grillBonus=0;
      var prot=null;
      for(i=0;i<nonWild.length;i++){
        if(isProtein(nonWild[i]) && !isEgg(nonWild[i])){ prot=nonWild[i]; break; }
      }
      if(prot && GRILL_PROTEINS[prot]) grillBonus=1;
      var extras = Math.max(0, tileObjs.length - 4);
      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:(r.base + grillBonus + extras), grillBonus:grillBonus, extras:extras, laurensLunch:false};
    }

    if(r.kind === "chorizo"){
      if(tileObjs.length < 4) return {ok:false, reason:"Needs more tiles."};
      if(ctx.strict && tileObjs.length !== 4) return {ok:false, reason:"Needs 4 tiles."};

      var hasT2=false, hasCh=false, hasOn=false, hasCil=false;
      for(i=0;i<nonWild.length;i++){
        var n2=nonWild[i];
        if(isTortilla(n2)) hasT2=true;
        else if(n2==="Chorizo") hasCh=true;
        else if(n2==="Onion") hasOn=true;
        else if(n2==="Cilantro") hasCil=true;
      }
      if(!hasT2 && wildCount>0) hasT2=true;
      if(!hasCh && wildCount>0) hasCh=true;
      if(!hasOn && wildCount>0) hasOn=true;
      if(!hasCil && wildCount>0) hasCil=true;

      if(!hasT2) return {ok:false, reason:"Needs tortilla."};
      if(!hasCh) return {ok:false, reason:"Needs chorizo."};
      if(!hasOn) return {ok:false, reason:"Needs onion."};
      if(!hasCil) return {ok:false, reason:"Needs cilantro."};

      var extras2 = ctx.loose ? Math.max(0, tileObjs.length - 4) : 0;
      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:(r.base+extras2), grillBonus:0, extras:extras2, laurensLunch:false};
    }

    if(r.kind === "taco"){
      if(tileObjs.length < (ctx.strict ? 5 : 3)) return {ok:false, reason:"Needs more tiles."};
      if(tileObjs.length > 8) return {ok:false, reason:"Too many tiles."};

      var hasReqT=false;
      for(i=0;i<nonWild.length;i++){ if(nonWild[i]===r.tortilla){ hasReqT=true; break; } }
      if(!hasReqT && wildCount>0){
        var hasAnyT=false;
        for(i=0;i<nonWild.length;i++){ if(isTortilla(nonWild[i])){ hasAnyT=true; break; } }
        if(!hasAnyT) hasReqT=true;
      }
      if(!hasReqT) return {ok:false, reason:"Use " + r.tortilla + "."};

      var hasProt=false;
      for(i=0;i<nonWild.length;i++){ if(isProtein(nonWild[i])){ hasProt=true; break; } }
      if(!hasProt && wildCount===0) return {ok:false, reason:"Needs protein."};

      var dryCount=0;
      for(i=0;i<nonWild.length;i++){ if(isDryTopping(nonWild[i])) dryCount++; }
      if(dryCount < reqDry){
        if(wildCount < (reqDry - dryCount)) return {ok:false, reason:"Needs " + reqDry + " dry toppings."};
      }

      var wetCount2=0;
      for(i=0;i<nonWild.length;i++){ if(isWet(nonWild[i])) wetCount2++; }
      if(wetCount2 > 1) return {ok:false, reason:"Only 1 wet topping."};

      var grillBonus2=0;
      var prot2=null;
      for(i=0;i<nonWild.length;i++){
        if(isProtein(nonWild[i]) && !isEgg(nonWild[i])){ prot2=nonWild[i]; break; }
      }
      if(prot2 && GRILL_PROTEINS[prot2]) grillBonus2=1;

      var minReq = ctx.strict ? 5 : 3;
      var extras3 = Math.max(0, tileObjs.length - minReq);
      var pts = r.base + grillBonus2 + extras3;

      var laurens = (occ["Lettuce"] || 0) >= 2;
      if(laurens) pts += 5;

      return {ok:true, recipeKey:r.key, name:r.name, base:r.base, points:pts, grillBonus:grillBonus2, extras:extras3, laurensLunch:laurens};
    }

    return {ok:false, reason:"No match."};
  }

  function detectBestDish(tileObjs, ctx){
    tileObjs = tileObjs || [];
    if(tileObjs.length === 0) return {ok:false, reason:"No dish detected yet."};

    var names = [];
    for(var i=0;i<tileObjs.length;i++) names.push(tileObjs[i].name);

    var hasEgg2=false, hasTort=false, hasWild=false;
    for(i=0;i<names.length;i++){
      if(names[i]==="Egg") hasEgg2=true;
      if(isTortilla(names[i])) hasTort=true;
      if(isWild(names[i])) hasWild=true;
    }
    if(hasWild){ hasEgg2=true; hasTort=true; }

    var ordered = [];
    if(hasEgg2 && hasTort) ordered.push("breakfastTaco");
    for(i=0;i<RECIPES.length;i++){
      if(RECIPES[i].key !== "breakfastTaco") ordered.push(RECIPES[i].key);
    }
    if(!(hasEgg2 && hasTort)) ordered.push("breakfastTaco");

    var best=null;
    for(i=0;i<ordered.length;i++){
      var k = ordered[i];
      var v = validateRecipeForSelection(k, tileObjs, ctx);
      if(!v.ok) continue;
      if(!best || v.points > best.points) best=v;
    }
    if(!best) return {ok:false, reason:"No dish detected yet."};
    best.ok=true;
    return best;
  }

  function selectedTilesFor(pid){
    var m = state.match;
    var p = m && m.players ? m.players[pid] : null;
    var ids = (p && p.prepSelectedIds) ? p.prepSelectedIds : [];
    var hand = (p && p.hand) ? p.hand : [];
    var out = [];
    for(var i=0;i<ids.length;i++){
      var id = ids[i];
      for(var j=0;j<hand.length;j++){
        if(hand[j].id===id){ out.push(hand[j]); break; }
      }
    }
    return out;
  }
  function remixSelectedTilesFor(pid){
    var m = state.match;
    var p = m && m.players ? m.players[pid] : null;
    var ids = (p && p.remixSelectedIds) ? p.remixSelectedIds : [];
    var hand = (p && p.hand) ? p.hand : [];
    var out = [];
    for(var i=0;i<ids.length;i++){
      var id = ids[i];
      for(var j=0;j<hand.length;j++){
        if(hand[j].id===id){ out.push(hand[j]); break; }
      }
    }
    return out;
  }

  function publishSelectionAsDish(pid){
    var m = state.match;
    var pl = m.players[pid];
    var ctx = diffCtx();
    var selected = selectedTilesFor(pid);
    var best = detectBestDish(selected, ctx);
    if(!best.ok) return {ok:false, msg: best.reason};

    var usedIds = (pl.prepSelectedIds || []).slice(0);
    var usedTiles = [];
    for(var i=0;i<usedIds.length;i++){
      var id = usedIds[i];
      for(var j=0;j<pl.hand.length;j++){
        if(pl.hand[j].id===id){ usedTiles.push(pl.hand[j]); break; }
      }
    }

    for(i=0;i<usedTiles.length;i++){
      for(j=0;j<pl.hand.length;j++){
        if(pl.hand[j].id===usedTiles[i].id){ pl.hand.splice(j,1); break; }
      }
    }
    pl.prepSelectedIds = [];

    var pub = {
      id: nowId("pub"),
      owner: pid,
      ownerName: pl.name,
      recipeKey: best.recipeKey,
      name: best.name,
      basePts: best.base,
      points: best.points,
      tiles: [],
      isRemix: false
    };
    for(i=0;i<usedTiles.length;i++){
      pub.tiles.push({id: usedTiles[i].id, name: usedTiles[i].name});
    }
    m.publicLine.push(pub);

    pl.score += best.points;
    pl.servedThisHand += best.points;
    pl.logThisHand.push({ type:"serve", name: best.name, points: best.points });

    var turnPts = best.points;
    if(!m.kitchenOpen){
      if(isStarterPassDishKey(best.recipeKey) && !pl.starterPassUsed){
        pl.starterPassUsed = true;
        turnPts = 0;
      }
    }
    m.servedThisTurnPts += turnPts;
    if(!m.kitchenOpen && m.servedThisTurnPts >= RULES.openKitchenTurnPts){
      m.kitchenOpen = true;
      toast("🔥 Kitchen Open!");
    }
    if(best.laurensLunch){ toast("Lauren’s Lunch", 5000); }

    return {ok:true, dish: pub};
  }

  function canRemixTile(name, ctx){
    if(isWild(name)) return true;
    if(ctx.strict) return isDryTopping(name) || isWet(name);
    return true;
  }

  function applyRemixToDish(pid, dishId, addTileIds){
    var m = state.match;
    var pl = m.players[pid];
    var ctx = diffCtx();

    if(!m.kitchenOpen) return {ok:false, msg:"Kitchen is closed."};
    if(!addTileIds || !addTileIds.length) return {ok:false, msg:"Select at least 1 tile."};

    var target=null;
    for(var i=0;i<m.publicLine.length;i++){
      if(m.publicLine[i].id===dishId){ target=m.publicLine[i]; break; }
    }
    if(!target) return {ok:false, msg:"No target dish."};

    var addTiles=[];
    for(i=0;i<addTileIds.length;i++){
      var id=addTileIds[i];
      for(var j=0;j<pl.hand.length;j++){
        if(pl.hand[j].id===id){ addTiles.push(pl.hand[j]); break; }
      }
    }
    if(!addTiles.length) return {ok:false, msg:"No tiles found."};

    for(i=0;i<addTiles.length;i++){
      if(!canRemixTile(addTiles[i].name, ctx)) return {ok:false, msg:"That tile can’t be used for remix on this difficulty."};
    }

    var sim=[];
    var baseArr = target.tiles || [];
    for(i=0;i<baseArr.length;i++) sim.push({id: baseArr[i].id, name: baseArr[i].name});
    for(i=0;i<addTiles.length;i++) sim.push({id: addTiles[i].id, name: addTiles[i].name});

    var v = validateRecipeForSelection(target.recipeKey, sim, ctx);
    if(!v.ok) return {ok:false, msg: v.reason || "Illegal remix."};

    for(i=0;i<addTiles.length;i++){
      for(j=0;j<pl.hand.length;j++){
        if(pl.hand[j].id===addTiles[i].id){ pl.hand.splice(j,1); break; }
      }
    }

    if(!target.tiles) target.tiles=[];
    for(i=0;i<addTiles.length;i++){
      target.tiles.push({id:addTiles[i].id, name:addTiles[i].name});
    }
    target.isRemix = true;

    pl.score += 1;
    pl.remixGainThisHand += 1;
    pl.logThisHand.push({ type:"remix", name:"Remix: " + target.name, points:1, from: target.ownerName });
    pl.remixSelectedIds = [];

    toast("Remix! (+1)", 1600);
    return {ok:true};
  }

  // Tutorial steps (wired images)
  var TUTORIAL_STEPS = [
    { title:"Next step", text:"Use the ingredients in your hand to load your Prep Window. When a dish is detected, Order Up becomes available.", img:"https://prometheangamescom.wordpress.com/wp-content/uploads/2025/12/chatgpt-image-dec-16-2025-11_05_25-am.png" },
    { title:"Opening the kitchen", text:"Serve 10+ points in a single turn to open the kitchen. Once it’s open, wet toppings become available.", img:"https://prometheangamescom.wordpress.com/wp-content/uploads/2025/12/01-bienvenidos.png" },
    { title:"Remixing", text:"When the kitchen is open, you can improve the public line using tiles from your hand. Remix points are additive.", img:"https://prometheangamescom.wordpress.com/wp-content/uploads/2025/12/03-remix.png" },
    { title:"Bonuses", text:"Some combos trigger fun bonuses and achievements. (Example: double lettuce shows Lauren’s Lunch.)", img:"https://prometheangamescom.wordpress.com/wp-content/uploads/2025/12/04-lauren.png" },
    { title:"Difficulty", text:"Beginner/Easy/Medium are forgiving and include helpers. Difficult/Master Chef are strict and CPUs remix smarter.", img:"https://prometheangamescom.wordpress.com/wp-content/uploads/2025/12/05-difficulty.png" }
  ];

  function openTutorialModal(){
    modalMode = "tutorial";
    var steps = TUTORIAL_STEPS || [];
    if(!steps.length){ toast("Tutorial steps missing."); return; }

    var html = '<div class="tutWrap"><div class="tutStrip" id="tutStrip">';
    for(var i=0;i<steps.length;i++){
      var s = steps[i] || {};
      var imgSrc = (s.img === null || s.img === undefined) ? "" : String(s.img);
      var media = "";
      if(imgSrc){
        media =
          '<div class="tutMedia">' +
            '<img src="' + escapeHtml(imgSrc) + '" alt="" loading="lazy" decoding="async" onerror="this.style.display=\\'none\\'">' +
          '</div>';
      }
      html +=
        '<div class="tutPage">' +
          '<div class="tutTitle">' + escapeHtml(s.title || "") + '</div>' +
          '<div class="tutText">' + escapeHtml(s.text || "") + '</div>' +
          media +
          '<div class="hint" style="margin-top:12px;">Swipe to continue.</div>' +
        '</div>';
    }
    html += '</div></div><div class="tutDots" id="tutDots">';
    for(i=0;i<steps.length;i++){ html += '<div class="dot ' + (i===0 ? 'on' : '') + '"></div>'; }
    html += '</div>';

    openModal("Tutorial", html, [
      {text:t("hide"), className:"ghost", onClick:function(){ state.settings.tutorialHidden=true; persist(); closeModal(); }},
      {text:t("close"), className:"primary", onClick:function(){ persist(); closeModal(); }}
    ]);

    var strip = $("tutStrip");
    var dots = $("tutDots") ? $("tutDots").querySelectorAll(".dot") : [];
    function updateDots(){
      if(!strip) return;
      var w = strip.clientWidth || 1;
      var idx = Math.round(strip.scrollLeft / w);
      for(var j=0;j<dots.length;j++){
        if(dots[j] && dots[j].classList) dots[j].classList.toggle("on", j===idx);
      }
    }
    if(strip){
      strip.addEventListener("scroll", function(){
        if(window.requestAnimationFrame) window.requestAnimationFrame(updateDots);
        else updateDots();
      });
    }
  }

  function renderMenuGuide(){
    var lines = [];
    lines.push('<div class="label">Breakfast Taco (3 pts)</div><div class="hint">Tortilla + Egg required. Wet: max 1. No Sour Cream / Charro Beans / Black Beans.</div>');
    lines.push('<div class="label">Hard Shell Taco (base 5 pts)</div><div class="hint">Corn tortilla + protein + dry toppings. Strict mode requires more toppings.</div>');
    lines.push('<div class="label">Soft Taco (base 5 pts)</div><div class="hint">Flour tortilla + protein + dry toppings.</div>');
    lines.push('<div class="label">Chorizo Taco (base 8 pts)</div><div class="hint">Tortilla + Chorizo + Onion + Cilantro.</div>');
    lines.push('<div class="label">Chips & Dip (5 pts)</div><div class="hint">Tortilla Chips + (Salsa/Guac/Queso). Starter Pass usable once before kitchen opens.</div>');
    lines.push('<div class="label">Kid&#039;s Rice and Beans (2 pts)</div><div class="hint">Rice + 1 Bean required. Optional: Avocado and/or 1 Tortilla. +1 if tortilla OR avocado is added. No other ingredients. Starter Pass usable once before kitchen opens.</div>');
    lines.push('<div class="label">Pico de Gallo (8 pts)</div><div class="hint">Tomato + Onion + Cilantro + Lime Juice. No extras.</div>');
    lines.push('<div class="label">Enchiladas (base 10 pts)</div><div class="hint">Tortillas + Protein + Sauce + Cheese. Up to 3 toppings.</div>');
    $("menuGuideBody").innerHTML = lines.join('<div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>');
  }

  function phaseText(){
    var m = state.match;
    if(m.kitchenOpen) return {title:"Kitchen Open", desc:"Wet toppings unlocked. Remix is enabled."};
    if(m.publicLine.length > 0) return {title:"Appetizers Out", desc:"Build toward 10+ points in a single turn to open the kitchen."};
    return {title:"Not Seated Yet", desc:"Serve 10+ points in one turn to open the kitchen."};
  }
  function playerColor(pid){
    var m = state.match;
    return (m.players[pid] && m.players[pid].color) ? m.players[pid].color : "#ffffff";
  }

  function renderPublicLineInto(elId, includeRemixButtons){
    var m = state.match;
    var el = $(elId);
    if(!el) return;

    var groups = groupBy(m.publicLine, function(d){ return d.name; });
    var any = false;
    for (var k in groups) if(groups.hasOwnProperty(k)) { any=true; break; }
    if(!any){
      el.innerHTML = '<div class="muted small">No dishes in the window yet.</div>';
      return;
    }

    var html = "";
    for(var menuItem in groups){
      if(!groups.hasOwnProperty(menuItem)) continue;
      var dishes = groups[menuItem];
      var total = 0;
      for(var i=0;i<dishes.length;i++) total += (dishes[i].points||0);

      html += '<div class="pubGroup">' +
        '<div class="pubGroupTitle">' +
          '<div>' + escapeHtml(menuItem) + '</div>' +
          '<span class="badge">Total <span class="mono">' + total + '</span></span>' +
        '</div>';

      for(i=0;i<dishes.length;i++){
        var d = dishes[i];
        var col = playerColor(d.owner);
        var tintA = hexToRgba(col, 0.28);

        var tiles = "";
        var arr = d.tiles || [];
        for(var j=0;j<arr.length;j++){
          var nm = arr[j].name;
          var cat = ingredientCategory(nm);
          tiles += '<span class="tile cat-' + cat + '" style="cursor:default;">' + escapeHtml(nm) + '</span>';
        }

        var remixBtn = "";
        if(includeRemixButtons){
          remixBtn = '<button class="btnTiny ghost" data-remix-target="' + escapeHtml(d.id) + '">Remix</button>';
        }

        html += '<div class="pubDishRow" style="--tintA:' + tintA + ';">' +
          '<div class="pubDishMeta">' +
            '<div>' + escapeHtml(d.ownerName) + (d.isRemix ? " • Remix" : "") + '</div>' +
            '<div class="row" style="gap:8px; align-items:center;">' +
              (includeRemixButtons ? remixBtn : '') +
              '<span class="badge">' + (d.points||0) + ' pts</span>' +
            '</div>' +
          '</div>' +
          '<div class="tiles" style="margin-top:8px;">' + tiles + '</div>' +
        '</div>';
      }

      html += '</div>';
    }

    el.innerHTML = html;
  }

  function renderPublicLine(){
    var m = state.match;
    if($("lineSummary")) $("lineSummary").textContent = m.publicLine.length + " dish" + (m.publicLine.length===1 ? "" : "es");
    renderPublicLineInto("publicLine", false);
  }

  function renderGameplayPrepTable(){
    var slotsEl = $("gpPrepSlots");
    if(!slotsEl) return;

    var pl = p1();
    var ids = (pl.prepSelectedIds || []).slice(0,10);
    if($("gpPrepLoadedHint")) $("gpPrepLoadedHint").textContent = ids.length + "/10 loaded";

    var selected = selectedTilesFor("P1");
    var ctx = diffCtx();
    var best = detectBestDish(selected, ctx);

    var slotsHtml = "";
    for(var i=0;i<10;i++){
      var tObj = selected[i];
      if(!tObj){
        slotsHtml += '<div class="slot"><div class="sHint">Empty</div></div>';
      }else{
        var cat = ingredientCategory(tObj.name);
        slotsHtml += '<div class="slot filled" data-prep-remove-gp="' + escapeHtml(tObj.id) + '">' +
          '<div class="sName">' + escapeHtml(tObj.name) + '</div>' +
          '<div class="muted2 small" style="margin-top:6px;">' + escapeHtml(categoryLabel(cat)) + '</div>' +
        '</div>';
      }
    }
    slotsEl.innerHTML = slotsHtml;
    if($("gpPrepStatus")) $("gpPrepStatus").textContent = best.ok ? (best.name + " detected.") : best.reason;
  }

  function fillSettings(){
    var sd = $("selDifficulty");
    if(sd){
      sd.innerHTML = "";
      for(var i=0;i<DIFFS.length;i++){
        var op = document.createElement("option");
        op.value = DIFFS[i];
        op.textContent = DIFFS[i];
        sd.appendChild(op);
      }
      sd.value = state.settings.difficulty;
    }

    var sa = $("selAccent");
    if(sa){
      sa.innerHTML = "";
      for(i=0;i<ACCENTS.length;i++){
        op = document.createElement("option");
        op.value = ACCENTS[i].val;
        op.textContent = ACCENTS[i].name + " (" + ACCENTS[i].val + ")";
        sa.appendChild(op);
      }
      sa.value = state.settings.accent;
    }

    if($("selMode")) $("selMode").value = state.settings.mode;
    if($("selPlayers")) $("selPlayers").value = String(state.settings.players);
    if($("inpHands")) $("inpHands").value = state.settings.handsTotal;
    if($("inpTilesPerPlayer")) $("inpTilesPerPlayer").value = state.settings.tilesPerPlayer;
    if($("selDecks")) $("selDecks").value = String(state.settings.decks);
    if($("selLang")) $("selLang").value = state.settings.lang;
  }

  function setNavActive(btnId){
    var ids = ["navGame","navPrep","navRemix","navScores","navSettings"];
    for(var i=0;i<ids.length;i++){
      var el = $(ids[i]);
      if(el) el.classList.toggle("active", ids[i]===btnId);
    }
  }

  function setPage(p){
    state.ui.page = p;
    persist();
    render();
  }

  function renderGameplay(){
    var m = state.match;
    if(!m) return;
    var myTurn = (m.activePid === "P1");

    document.documentElement.style.setProperty("--accent", state.settings.accent);
    document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, 0.14));
    document.documentElement.classList.toggle("strictMode", isStrict(state.settings.difficulty || "Easy"));

    if($("navGame")) $("navGame").textContent = t("gameplay");
    if($("navPrep")) $("navPrep").textContent = t("prep");
    if($("navRemix")) $("navRemix").textContent = t("remix");
    if($("navScores")) $("navScores").textContent = t("scores");
    if($("navSettings")) $("navSettings").textContent = t("settings");

    if($("btnPrep")) $("btnPrep").textContent = t("prepDish");
    if($("btnEndTurn")) $("btnEndTurn").textContent = t("endTurn");
    if($("btnOrderUp")) $("btnOrderUp").textContent = t("orderUp");

    if($("btnPrep")) $("btnPrep").classList.toggle("pulse", myTurn);

    if($("tilesRemainBadge")) $("tilesRemainBadge").textContent = "Tiles Remaining " + m.bag.length;
    if($("kitchenBadge")) $("kitchenBadge").textContent = m.kitchenOpen ? "Kitchen Open" : "Kitchen Closed";
    if($("handBadge")) $("handBadge").textContent = "Hand " + m.handIndex + "/" + (state.settings.handsTotal || 12);
    if($("turnBadge")) $("turnBadge").textContent = myTurn ? "Your Turn" : (m.players[m.activePid].name + "'s Turn");

    var ph = phaseText();
    if($("phaseTitle")) $("phaseTitle").textContent = ph.title;
    if($("phaseDesc")) $("phaseDesc").textContent = ph.desc;

    var sel = selectedTilesFor("P1");
    var best = detectBestDish(sel, diffCtx());
    var canOrder = myTurn && best.ok;

    if($("btnOrderUp")){
      $("btnOrderUp").disabled = !canOrder;
      $("btnOrderUp").classList.toggle("pulseOrder", canOrder);
    }
    if($("btnPrep")) $("btnPrep").disabled = !myTurn;
    if($("btnEndTurn")) $("btnEndTurn").disabled = !myTurn;

    renderPublicLine();
    renderGameplayPrepTable();
  }

  function renderPrep(){
    var m = state.match;
    if(!m) return;
    var pl = p1();
    var myTurn = (m.activePid === "P1");

    if($("prepTurnBadge")) $("prepTurnBadge").textContent = myTurn ? "Your Turn" : (m.players[m.activePid].name + "'s Turn");
    if($("handCountHint")) $("handCountHint").textContent = (pl.hand ? pl.hand.length : 0) + " tiles";

    if($("btnDraw")){
      $("btnDraw").textContent = t("drawTile");
      $("btnDraw").disabled = (!myTurn) || pl.didDrawThisTurn || (m.bag.length===0);
      $("btnDraw").classList.toggle("pulse", myTurn && !pl.didDrawThisTurn && m.bag.length>0);
    }

    var diff = state.settings.difficulty || "Easy";
    var showAutoPlate = myTurn && (diff==="Beginner" || diff==="Easy" || diff==="Medium");
    if($("btnAutoPlate")) $("btnAutoPlate").style.display = showAutoPlate ? "inline-flex" : "none";

    var showAutoRemix = myTurn && diff==="Beginner" && m.kitchenOpen;
    if($("btnAutoRemix")) $("btnAutoRemix").style.display = showAutoRemix ? "inline-flex" : "none";

    var ids = (pl.prepSelectedIds || []).slice(0,10);
    if($("prepLoadedHint")) $("prepLoadedHint").textContent = ids.length + "/10 loaded";

    var selected = selectedTilesFor("P1");
    var ctx = diffCtx();
    var best = detectBestDish(selected, ctx);

    var slotsHtml = "";
    for(var i=0;i<10;i++){
      var tObj = selected[i];
      if(!tObj){
        slotsHtml += '<div class="slot"><div class="sHint">Empty</div></div>';
      }else{
        var cat = ingredientCategory(tObj.name);
        slotsHtml += '<div class="slot filled" data-prep-remove="' + escapeHtml(tObj.id) + '">' +
          '<div class="sName">' + escapeHtml(tObj.name) + '</div>' +
          '<div class="muted2 small" style="margin-top:6px;">' + escapeHtml(categoryLabel(cat)) + '</div>' +
        '</div>';
      }
    }
    if($("prepSlots")) $("prepSlots").innerHTML = slotsHtml;
    if($("prepStatus")) $("prepStatus").textContent = best.ok ? (best.name + " detected.") : best.reason;

    var canOrder = myTurn && best.ok;
    if($("btnOrderUpFromPrep")){
      $("btnOrderUpFromPrep").disabled = !canOrder;
      $("btnOrderUpFromPrep").classList.toggle("pulseOrder", canOrder);
      $("btnOrderUpFromPrep").textContent = t("orderUp");
    }

    // Hand groups
    var grouped = groupBy(pl.hand || [], function(ti){ return ingredientCategory(ti.name); });
    var order = ["tortilla","protein","cheese","wet","drytop","wild","other"];
    var handHtml = '<div class="handGroups">';
    for(var oi=0;oi<order.length;oi++){
      var cat2 = order[oi];
      var tiles = grouped[cat2] || [];
      if(!tiles.length) continue;

      handHtml += '<div class="handGroup">' +
        '<div class="handGroupTitle">' +
          '<span>' + escapeHtml(categoryLabel(cat2)) + '</span>' +
          '<span class="count">' + tiles.length + '</span>' +
        '</div>' +
        '<div class="tiles">';

      for(var j=0;j<tiles.length;j++){
        var ti = tiles[j];
        var inPrep = false;
        var selIds = pl.prepSelectedIds || [];
        for(var s=0;s<selIds.length;s++){ if(selIds[s]===ti.id){ inPrep=true; break; } }
        var wild = isWild(ti.name) ? "wild" : "";
        handHtml += '<span class="tile ' + (inPrep ? "sel " : "") + wild + ' cat-' + cat2 + '" data-htile="' + escapeHtml(ti.id) + '">' +
          escapeHtml(ti.name) +
        '</span>';
      }

      handHtml += '</div></div>';
    }
    handHtml += '</div>';
    if($("handTiles")) $("handTiles").innerHTML = handHtml;

    renderMenuGuide();
  }

  function renderRemix(){
    var m = state.match;
    if(!m) return;
    var pl = p1();
    var myTurn = (m.activePid === "P1");
    var kitchenOpen = !!m.kitchenOpen;

    if($("remixGateBadge")) $("remixGateBadge").textContent = kitchenOpen ? (myTurn ? "Kitchen Open • Your Turn" : "Kitchen Open") : "Kitchen Closed";
    if($("remixHandCount")) $("remixHandCount").textContent = (pl.hand ? pl.hand.length : 0) + " tiles";
    if($("remixLineCount")) $("remixLineCount").textContent = (m.publicLine ? m.publicLine.length : 0) + " dishes";

    var sel = remixSelectedTilesFor("P1");
    if($("remixSelCount")) $("remixSelCount").textContent = sel.length + " selected";

    var selHtml = "";
    if(!sel.length){
      selHtml = '<div class="muted small">No tiles selected.</div>';
    }else{
      for(var i=0;i<sel.length;i++){
        selHtml += '<span class="tile sel cat-' + ingredientCategory(sel[i].name) + '" data-rm-htile="' + escapeHtml(sel[i].id) + '">' + escapeHtml(sel[i].name) + '</span>';
      }
    }
    if($("remixSelectedTiles")) $("remixSelectedTiles").innerHTML = selHtml;

    renderPublicLineInto("remixPublicLine", true);

    var grouped = groupBy(pl.hand || [], function(ti){ return ingredientCategory(ti.name); });
    var order = ["tortilla","protein","cheese","wet","drytop","wild","other"];
    var handHtml = '<div class="handGroups">';
    for(var oi=0;oi<order.length;oi++){
      var cat2 = order[oi];
      var tiles = grouped[cat2] || [];
      if(!tiles.length) continue;

      handHtml += '<div class="handGroup">' +
        '<div class="handGroupTitle">' +
          '<span>' + escapeHtml(categoryLabel(cat2)) + '</span>' +
          '<span class="count">' + tiles.length + '</span>' +
        '</div>' +
        '<div class="tiles">';

      for(var j=0;j<tiles.length;j++){
        var ti = tiles[j];
        var inSel = false;
        var selIds = pl.remixSelectedIds || [];
        for(var s=0;s<selIds.length;s++){ if(selIds[s]===ti.id){ inSel=true; break; } }
        var wild = isWild(ti.name) ? "wild" : "";
        handHtml += '<span class="tile ' + (inSel ? "sel " : "") + wild + ' cat-' + cat2 + '" data-rm-htile="' + escapeHtml(ti.id) + '">' +
          escapeHtml(ti.name) +
        '</span>';
      }

      handHtml += '</div></div>';
    }
    handHtml += '</div>';
    if($("remixHandTiles")) $("remixHandTiles").innerHTML = handHtml;
  }

  function renderScores(){
    var m = state.match;
    if(!m) return;
    var pl = p1();

    if($("scoreModePill")) $("scoreModePill").textContent = (state.settings.mode === "campaign") ? "Campaign" : "Standard";
    if($("scoreCurrent")) $("scoreCurrent").textContent = "Current: " + pl.score;
    if($("scoreServedMuted")) $("scoreServedMuted").textContent = "Served this hand: " + pl.servedThisHand;

    var players = [];
    for(var pid in m.players) if(m.players.hasOwnProperty(pid)) players.push(m.players[pid]);
    players.sort(function(a,b){ return a.id < b.id ? -1 : 1; });

    var out = "";
    for(var i=0;i<players.length;i++){
      var p = players[i];
      var col = playerColor(p.id);
      var tintA = hexToRgba(col, 0.18);

      var dishLines = "";
      if(p.logThisHand && p.logThisHand.length){
        for(var j=0;j<p.logThisHand.length;j++){
          var ev = p.logThisHand[j];
          var extra = (ev.type==="remix") ? ' <span class="muted2 small">(from ' + escapeHtml(ev.from || "—") + ')</span>' : '';
          dishLines += '<div class="row sp" style="gap:12px; margin-top:8px;">' +
            '<div style="font-weight:900;">' + escapeHtml(ev.name) + extra + '</div>' +
            '<span class="badge">' + ev.points + '</span>' +
          '</div>';
        }
      }else{
        dishLines = '<div class="muted small">No dishes served yet this hand.</div>';
      }

      var net = (p.remixGainThisHand||0) - (p.remixLossThisHand||0);
      var netTxt = (net===0) ? "0" : (net>0 ? ("+"+net) : String(net));

      out +=
        '<details class="acc" style="margin-top:12px; background: rgba(255,255,255,.03);">' +
          '<summary>' +
            '<span>' + escapeHtml(p.name) + (p.id==="P1" ? " (You)" : "") + '</span>' +
            '<span class="badge">Score ' + p.score + '</span>' +
          '</summary>' +
          '<div class="accBody" style="position:relative; overflow:hidden;">' +
            '<div style="position:absolute; inset:0; background: linear-gradient(135deg, ' + tintA + ', transparent 70%); opacity:.9; pointer-events:none;"></div>' +
            '<div style="position:relative; z-index:1;">' +
              '<div class="row wrap" style="gap:10px; margin-top:6px;">' +
                '<span class="pill">Served: ' + p.servedThisHand + '</span>' +
                '<span class="pill">Remix Net: ' + netTxt + '</span>' +
              '</div>' +
              '<div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>' +
              dishLines +
            '</div>' +
          '</div>' +
        '</details>';
    }
    if($("scoreList")) $("scoreList").innerHTML = out;
  }

  function render(){
    if(!state.match) newMatch();

    var pages = [
      ["pageGameplay","gameplay","navGame"],
      ["pagePrep","prep","navPrep"],
      ["pageRemix","remix","navRemix"],
      ["pageScores","scores","navScores"],
      ["pageSettings","settings","navSettings"]
    ];
    for(var i=0;i<pages.length;i++){
      var el = $(pages[i][0]);
      if(el) el.classList.toggle("on", state.ui.page===pages[i][1]);
      if(state.ui.page===pages[i][1]) setNavActive(pages[i][2]);
    }

    fillSettings();
    renderGameplay();
    renderPrep();
    renderRemix();
    renderScores();
  }

  function setNavActive(btnId){
    setNavActive = function(btnId2){
      var ids = ["navGame","navPrep","navRemix","navScores","navSettings"];
      for(var i=0;i<ids.length;i++){
        var el = $(ids[i]);
        if(el) el.classList.toggle("active", ids[i]===btnId2);
      }
    };
    setNavActive(btnId);
  }

  function togglePrepSelect(tileId){
    var m = state.match;
    var pl = p1();
    if(m.activePid !== "P1"){ toast("Not your turn."); return; }
    if(!pl.prepSelectedIds) pl.prepSelectedIds = [];

    var idx=-1;
    for(var i=0;i<pl.prepSelectedIds.length;i++){
      if(pl.prepSelectedIds[i]===tileId){ idx=i; break; }
    }
    if(idx>=0) pl.prepSelectedIds.splice(idx,1);
    else{
      if(pl.prepSelectedIds.length>=10){ toast("Prep window is full."); return; }
      pl.prepSelectedIds.push(tileId);
    }
    persist(); render();
  }

  function clearPrep(){
    var pl = p1();
    pl.prepSelectedIds = [];
    persist(); render();
  }

  function toggleRemixSelect(tileId){
    var m = state.match;
    var pl = p1();
    if(m.activePid !== "P1"){ toast("Not your turn."); return; }
    if(!pl.remixSelectedIds) pl.remixSelectedIds = [];

    var idx=-1;
    for(var i=0;i<pl.remixSelectedIds.length;i++){
      if(pl.remixSelectedIds[i]===tileId){ idx=i; break; }
    }
    if(idx>=0) pl.remixSelectedIds.splice(idx,1);
    else pl.remixSelectedIds.push(tileId);

    if(pl.remixSelectedIds.length>6) pl.remixSelectedIds = pl.remixSelectedIds.slice(pl.remixSelectedIds.length-6);
    persist(); render();
  }

  function clearRemixSelection(){
    var pl = p1();
    pl.remixSelectedIds = [];
    persist(); render();
  }

  function endTurn(){
    var m = state.match;
    if(m.activePid !== "P1"){ toast("Not your turn."); return; }
    // Minimal: just pass to next pid in sorted order
    var order=[];
    for(var k in m.players) if(m.players.hasOwnProperty(k)) order.push(k);
    order.sort();
    var i=0;
    for(i=0;i<order.length;i++) if(order[i]==="P1") break;
    var next = order[(i+1)%order.length];
    m.activePid = next;
    beginTurn(next);
    persist(); render();
    toast((next==="P1") ? "Your turn." : (m.players[next].name + "'s turn."));
  }

  function openDrawModal(){
    var m = state.match;
    var pl = p1();
    if(m.activePid !== "P1"){ toast("Not your turn."); return; }
    if(pl.didDrawThisTurn){ toast("Only one draw per turn."); return; }
    if(m.bag.length===0){ toast("No tiles left."); return; }

    // super-simple draw: pick one random tile (keeps your 3-choice UI out of the “buttons dead” critical path)
    var idx = randInt(m.bag.length);
    var t0 = m.bag.splice(idx,1)[0];
    pl.hand.push(t0);
    pl.didDrawThisTurn = true;

    state.flags.p1DrawCount = (state.flags.p1DrawCount || 0) + 1;
    persist(); render();
    toast("Drew: " + t0.name);

    if((state.flags.p1DrawCount||0) >= 2 && !state.settings.tutorialHidden && !state.flags.tutorialSecondDrawShown){
      state.flags.tutorialSecondDrawShown = true;
      persist();
      openTutorialModal();
    }
  }

  function wire(){
    setClick("navGame", function(){ setPage("gameplay"); });
    setClick("navPrep", function(){ setPage("prep"); });
    setClick("navRemix", function(){ setPage("remix"); });
    setClick("navScores", function(){ setPage("scores"); });
    setClick("navSettings", function(){ setPage("settings"); });

    setClick("btnNewMatchTop", function(){
      openModal("New Match", "Start a fresh match? This overwrites current match state.", [
        {text:t("cancel"), className:"ghost", onClick: closeModal},
        {text:t("start"), className:"primary", onClick: function(){ closeModal(); newMatch(); }}
      ]);
    });

    setClick("btnPrep", function(){ setPage("prep"); });
    setClick("btnEndTurn", endTurn);

    setClick("btnOrderUp", function(){
      var m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      var sel = selectedTilesFor("P1");
      var best = detectBestDish(sel, diffCtx());
      if(!best.ok){ toast("No qualifying dish."); return; }
      var res = publishSelectionAsDish("P1");
      if(!res.ok){ toast(res.msg || "No qualifying dish."); return; }
      persist(); render();
      toast("Order up!");
    });

    setClick("btnDraw", openDrawModal);

    setClick("btnOrderUpFromPrep", function(){
      var m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      var sel = selectedTilesFor("P1");
      var best = detectBestDish(sel, diffCtx());
      if(!best.ok){ toast("No qualifying dish."); return; }
      var res = publishSelectionAsDish("P1");
      if(!res.ok){ toast(res.msg || "No qualifying dish."); return; }
      persist(); render();
      setPage("gameplay");
      toast("Order up!");
    });

    setClick("btnClearPrep", clearPrep);
    setClick("btnAutoPlate", function(){ toast("Auto-Plate is still enabled on Easy/Medium; we’ll rewire it next."); });
    setClick("btnAutoRemix", function(){ toast("Auto-Remix is disabled in this build. Use the Remix tab."); });

    on("handTiles","click", function(e){
      var el = e.target.closest("[data-htile]");
      if(!el) return;
      togglePrepSelect(el.getAttribute("data-htile"));
    });

    on("prepSlots","click", function(e){
      var el = e.target.closest("[data-prep-remove]");
      if(!el) return;
      var id = el.getAttribute("data-prep-remove");
      var pl = p1();
      var next = [];
      for(var i=0;i<(pl.prepSelectedIds||[]).length;i++){
        if(pl.prepSelectedIds[i] !== id) next.push(pl.prepSelectedIds[i]);
      }
      pl.prepSelectedIds = next;
      persist(); render();
    });

    on("gpPrepSlots","click", function(e){
      var el = e.target.closest("[data-prep-remove-gp]");
      if(!el) return;
      var tid = el.getAttribute("data-prep-remove-gp");
      var pl = p1();
      var out = [];
      for(var i=0;i<(pl.prepSelectedIds||[]).length;i++){
        if(pl.prepSelectedIds[i] !== tid) out.push(pl.prepSelectedIds[i]);
      }
      pl.prepSelectedIds = out;
      persist(); render();
    });

    on("remixHandTiles","click", function(e){
      var el = e.target.closest("[data-rm-htile]");
      if(!el) return;
      toggleRemixSelect(el.getAttribute("data-rm-htile"));
    });
    on("remixSelectedTiles","click", function(e){
      var el = e.target.closest("[data-rm-htile]");
      if(!el) return;
      toggleRemixSelect(el.getAttribute("data-rm-htile"));
    });
    setClick("btnRemixClearSel", clearRemixSelection);

    on("remixPublicLine","click", function(e){
      var btn = e.target.closest("[data-remix-target]");
      if(!btn) return;

      var m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      if(!m.kitchenOpen){ toast("Kitchen is closed."); return; }

      var pl = p1();
      var ids = (pl.remixSelectedIds || []).slice(0);
      if(!ids.length){ toast("Select 1+ tile(s) from your hand first."); return; }
      if(ids.length > 4) ids = ids.slice(0,4);

      var out = applyRemixToDish("P1", btn.getAttribute("data-remix-target"), ids);
      if(!out.ok){ toast(out.msg || "Illegal remix."); return; }
      persist(); render();
    });

    // settings
    on("selMode","change", function(){ state.settings.mode = $("selMode").value; persist(); render(); });
    on("selPlayers","change", function(){ state.settings.players = parseInt($("selPlayers").value,10) || 4; persist(); newMatch(); });
    on("selDifficulty","change", function(){ state.settings.difficulty = $("selDifficulty").value; persist(); render(); });
    on("inpHands","change", function(){ state.settings.handsTotal = clamp(parseInt($("inpHands").value,10) || 12, 1, 12); persist(); render(); });
    on("inpTilesPerPlayer","change", function(){ state.settings.tilesPerPlayer = clamp(parseInt($("inpTilesPerPlayer").value,10) || 16, 8, 24); persist(); newMatch(); });
    on("selDecks","change", function(){ state.settings.decks = parseInt($("selDecks").value,10) || 2; persist(); newMatch(); });
    on("selAccent","change", function(){
      state.settings.accent = $("selAccent").value;
      if(state.match && state.match.players && state.match.players["P1"]) state.match.players["P1"].color = state.settings.accent;
      persist(); render();
    });
    on("selLang","change", function(){ state.settings.lang = $("selLang").value; persist(); render(); });

    setClick("btnViewTutorial", openTutorialModal);
  }

  function setPage(p){
    state.ui.page = p;
    persist();
    render();
  }

  function boot(){
    // Ensure match exists
    if(!state.match) newMatch();

    // Ensure arrays exist for older saves
    if(state.match && state.match.players){
      for(var pid in state.match.players){
        if(!state.match.players.hasOwnProperty(pid)) continue;
        var p = state.match.players[pid];
        if(!p.prepSelectedIds) p.prepSelectedIds = [];
        if(!p.remixSelectedIds) p.remixSelectedIds = [];
        if(!p.hand) p.hand = [];
        if(!p.logThisHand) p.logThisHand = [];
      }
    }

    wire();
    render();

    if(!state.flags.tutorialIntroShown && !state.settings.tutorialHidden){
      state.flags.tutorialIntroShown = true;
      persist();
      openTutorialModal();
    }

    toast("Loaded " + VERSION, 1800);
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", boot);
  }else{
    boot();
  }
})();
  </script>
</body>
</html>
