<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Taco Ria</title>
  <style>
    :root{
      --bg:#050608;
      --bg2:#0a0c10;
      --bg3:#0d1016;
      --text:#f3f4f6;
      --muted:rgba(243,244,246,.70);
      --muted2:rgba(243,244,246,.55);
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.14);
      --danger:#ff3b30;

      --accent:#00e5ff;
      --accentSoft: rgba(0,229,255,.14);

      --radius:20px;
      --pad:16px;
      --shadow: 0 18px 45px rgba(0,0,0,.55);
      --navH:56px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(900px 380px at 18% 0%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(780px 360px at 85% 10%, rgba(255,255,255,.05), transparent 65%),
        radial-gradient(820px 420px at 50% 115%, rgba(0,0,0,.75), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow-x:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .shell{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      width:100%;
      margin:0 auto;
      max-width: 980px;
    }
    @media (max-width: 430px){ .shell{ max-width: 375px; } }
    @media (max-width: 390px){ .shell{ max-width: 360px; } }

    header{ padding: 14px 14px 10px; min-height:56px; }
    main{ flex:1; padding: 0 14px calc(var(--navH) + env(safe-area-inset-bottom) + 18px); }

    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ min-width:0; }
    .wrap{ flex-wrap:wrap; }
    .sp{ justify-content:space-between; }

    .pageTitle{
      font-weight:1000;
      letter-spacing:.2px;
      line-height:1.08;
      font-size: clamp(20px, 4.7vw, 28px);
    }
    .small{ font-size:12px; }
    .muted{ color:var(--muted); }
    .muted2{ color:var(--muted2); }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.065), rgba(255,255,255,.035));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: var(--shadow);
    }

    .heroPhase{ position:relative; overflow:hidden; }
    .heroPhase::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(600px 240px at 20% 0%, rgba(255,255,255,.08), transparent 65%),
        radial-gradient(520px 240px at 85% 10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(540px 260px at 50% 120%, rgba(0,0,0,.60), transparent 55%);
      pointer-events:none;
    }
    .heroPhase > *{ position:relative; z-index:1; }

    .pills{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    button{
      border:1px solid var(--stroke2);
      background: rgba(0,0,0,.35);
      color:var(--text);
      border-radius: 18px;
      padding: 12px 14px;
      font-weight:1000;
      letter-spacing:.2px;
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .btnTiny{ padding:8px 10px; border-radius:14px; font-size:12px; }
    .ghost{ background: rgba(0,0,0,.20); }
    .primary{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border-color: rgba(255,255,255,.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 20px rgba(0,0,0,.55);
    }
    .danger{
      background: linear-gradient(180deg, rgba(255,59,48,.22), rgba(255,59,48,.10));
      border-color: rgba(255,59,48,.35);
    }

    .jumbo{
      min-height: 64px;
      font-size: 18px;
      border-radius: 20px;
      width:100%;
    }
    @media (max-width: 430px){
      .jumbo{ min-height: 68px; font-size: 19px; }
    }

    @keyframes pulseGlow{
      0%   { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
      50%  { transform: translateY(-1px); box-shadow: 0 0 0 1px rgba(255,255,255,.10), 0 0 32px rgba(0,229,255,.32); }
      100% { transform: translateY(0); box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(0,0,0,.55); }
    }
    .pulse{ animation: pulseGlow 1.65s ease-in-out infinite; }
    .pulseOrder{ animation: pulseGlow 1.25s ease-in-out infinite; }

    .actionsTray{ position: sticky; bottom: calc(var(--navH) + env(safe-area-inset-bottom)); z-index: 30; }
    .actionsStack{ display:flex; flex-direction:column; gap:10px; }

    .tiles{ display:flex; flex-wrap:wrap; gap:8px; }
    .tile{
      max-width:100%;
      overflow-wrap:anywhere;
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.14);
      font-weight: 900;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      --catTint: rgba(255,255,255,.06);
      background: linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.sel{
      outline: 2px solid rgba(0,229,255,.55);
      transform: translateY(-1px);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .tile.wild{ border-color: rgba(255,255,255,.28); box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset; }
    .tile.wet{ border-color: rgba(0,229,255,.25); }

    .handGroups{ display:flex; flex-direction:column; gap:12px; }
    .handGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(0,0,0,.22);
      padding:10px;
    }
    .handGroupTitle{
      font-weight:1000;
      font-size:12px;
      letter-spacing:.18px;
      color: var(--muted);
      margin-bottom:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .handGroupTitle .count{ opacity:.75; font-weight:1000; }

    .tile.cat-tortilla, .slotValue.cat-tortilla{ --catTint: rgba(255,204,0,.18); border-color: rgba(255,204,0,.30); }
    .tile.cat-protein,  .slotValue.cat-protein { --catTint: rgba(255,59,48,.16);  border-color: rgba(255,59,48,.28); }
    .tile.cat-cheese,   .slotValue.cat-cheese  { --catTint: rgba(255,245,200,.14); border-color: rgba(255,245,200,.24); }
    .tile.cat-wet,      .slotValue.cat-wet     { --catTint: rgba(255,43,214,.14); border-color: rgba(255,43,214,.24); }
    .tile.cat-drytop,   .slotValue.cat-drytop  { --catTint: rgba(163,255,18,.12); border-color: rgba(163,255,18,.22); }
    .tile.cat-wild,     .slotValue.cat-wild    { --catTint: rgba(255,255,255,.10); border-color: rgba(255,255,255,.26); }
    .tile.cat-other,    .slotValue.cat-other   { --catTint: rgba(179,107,255,.14); border-color: rgba(179,107,255,.24); }

    .pubGroup{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      padding:12px;
      margin-bottom:12px;
    }
    .pubGroupTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
      margin-bottom: 8px;
    }
    .pubDishRow{
      border:1px solid var(--stroke);
      border-radius:16px;
      background: rgba(0,0,0,.45);
      padding:10px;
      margin-top:10px;
      position:relative;
      overflow:hidden;
    }
    .pubDishRow::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, var(--tintA), transparent 70%);
      opacity:.95;
      pointer-events:none;
    }
    .pubDishRow > *{ position:relative; z-index:1; }
    .pubDishMeta{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:1000;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.30);
      font-weight:900;
      font-size:12px;
    }

    details.acc{
      border:1px solid var(--stroke);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    details.acc + details.acc{ margin-top:10px; }
    details.acc summary{
      list-style:none;
      cursor:pointer;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:1000;
    }
    details.acc summary::-webkit-details-marker{ display:none; }
    .accBody{ padding: 0 14px 14px; }

    .label{ font-size:12px; color:var(--muted); margin-bottom:6px; font-weight:900; }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; line-height:1.35; }

    :root{ color-scheme: dark; }

    nav.footer{
      position:fixed;
      left:0; right:0; bottom:0;
      height: var(--navH);
      padding-bottom: env(safe-area-inset-bottom);
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      z-index: 40;
    }
    .navBtn{
      flex:1;
      min-height:56px;
      border:none;
      border-right: 1px solid rgba(255,255,255,.06);
      background: transparent;
      color: rgba(255,255,255,.86);
      font-weight:1000;
      border-radius: 0;
      padding: 8px 6px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:2px;
    }
    .navBtn:last-child{ border-right:none; }
    .navBtn.active{
      color:#fff;
      background: radial-gradient(320px 120px at 50% 0%, rgba(0,229,255,.20), transparent 60%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .navBtn .ic{ font-size:16px; }
    .navBtn .tx{ font-size:12px; }

    #toastWrap{
      position:fixed;
      left:0; right:0;
      bottom: calc(var(--navH) + env(safe-area-inset-bottom) + 12px);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 80;
    }
    .toast{
      max-width:min(560px, calc(100% - 24px));
      background: rgba(0,0,0,.86);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,.65);
      font-weight: 900;
      pointer-events:none;
    }

    /* ===== MODAL (SOLID) ===== */
    #modalWrap{
      position:fixed; inset:0;
      background: linear-gradient(180deg, var(--bg), var(--bg3));
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 90;
    }
    #modalWrap.on{ display:flex; }
    .modal{
      width: min(620px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: 0 22px 60px rgba(0,0,0,.80);
      padding: 14px;
    }
    .modal h3{ margin: 4px 0 8px; font-size: 18px; }
    .modal .body{ color: var(--muted); font-weight: 900; line-height: 1.35; }
    .modal .foot{ margin-top: 12px; display:flex; gap:10px; justify-content:flex-end; }

    .page{ display:none; }
    .page.on{ display:block; }

    /* Prep Window: 8-slot carousel */
    .slotStrip{
      display:flex;
      gap:10px;
      overflow-x:auto;
      padding: 4px 2px 10px;
      -webkit-overflow-scrolling:touch;
      scroll-snap-type:x mandatory;
    }
    .slotCard{
      flex: 0 0 auto;
      width: min(150px, 44vw);
      scroll-snap-align:start;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.32);
      padding:12px;
      position:relative;
      overflow:hidden;
      user-select:none;
      cursor:pointer;
    }
    .slotCard::before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(320px 120px at 20% 0%, rgba(255,255,255,.07), transparent 60%);
      pointer-events:none;
    }
    .slotCard > *{ position:relative; z-index:1; }
    .slotLabel{
      font-weight:1000;
      font-size:12px;
      color: rgba(243,244,246,.70);
      margin-bottom:8px;
    }
    .slotValue{
      --catTint: rgba(255,255,255,.06);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:40px;
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      padding:10px 10px;
      font-weight:1000;
      text-align:center;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      background: linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }
    .slotEmpty{
      background: rgba(255,255,255,.03);
      color: rgba(243,244,246,.45);
      border-style:dashed;
    }
    .slotFilled{
      border-color: rgba(255,255,255,.20);
      background:
        linear-gradient(180deg, var(--accentSoft), rgba(0,0,0,0)),
        linear-gradient(135deg, var(--catTint), rgba(0,0,0,.45));
    }

    /* ===== Draw Tile Modal Grid ===== */
    .drawMeta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 10px;
    }
    .drawGrid{
      display:grid;
      gap:10px;
      margin-top: 8px;
    }
    .drawGrid.busy{ pointer-events:none; opacity:.96; }

    .tileBack{
      position:relative;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      box-shadow: 0 12px 28px rgba(0,0,0,.55);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      min-height: 78px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px 8px;
      perspective: 900px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.30));
    }
    .tileBack:active{ transform: translateY(1px) scale(.99); }

    @keyframes slowShimmer{
      0% { transform: translateX(-120%) skewX(-12deg); opacity:.0; }
      20%{ opacity:.10; }
      50%{ opacity:.18; }
      80%{ opacity:.08; }
      100%{ transform: translateX(140%) skewX(-12deg); opacity:.0; }
    }
    .tileBack::after{
      content:"";
      position:absolute;
      top:-40%;
      left:-60%;
      width: 70%;
      height: 180%;
      background: linear-gradient(90deg,
        transparent,
        rgba(255,255,255,.07),
        rgba(0,229,255,.10),
        rgba(255,255,255,.05),
        transparent
      );
      filter: blur(2px);
      animation: slowShimmer 5.8s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes glowDrift{
      0%   { transform: translate(-6%, -4%) scale(1); opacity:.12; }
      50%  { transform: translate(5%, 6%) scale(1.03); opacity:.18; }
      100% { transform: translate(-6%, -4%) scale(1); opacity:.12; }
    }
    .tileBack::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(420px 180px at 25% 0%, rgba(0,229,255,.16), transparent 60%),
        radial-gradient(380px 160px at 90% 10%, rgba(255,255,255,.07), transparent 65%);
      animation: glowDrift 7.5s ease-in-out infinite;
      pointer-events:none;
    }

    .tileFlip{
      position:relative;
      width:100%;
      height:100%;
      min-height: 78px;
      transform-style: preserve-3d;
      transition: transform 900ms cubic-bezier(.2,.85,.2,1);
    }
    .tileBack.reveal .tileFlip{ transform: rotateY(180deg); }

    .face{
      position:absolute;
      inset:0;
      border-radius:18px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 10px 8px;
      backface-visibility: hidden;
    }
    .face.back{
      background:
        radial-gradient(340px 140px at 25% 0%, rgba(255,255,255,.06), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.22));
    }
    .face.front{
      transform: rotateY(180deg);
      background:
        radial-gradient(340px 140px at 25% 0%, rgba(255,255,255,.07), transparent 62%),
        linear-gradient(180deg, rgba(0,229,255,.10), rgba(0,0,0,.32));
      border: 1px solid rgba(255,255,255,.10);
    }

    .tileBackBrand{
      font-weight:1000;
      letter-spacing:.2px;
      color: rgba(243,244,246,.84);
      font-size: 14px;
      line-height:1.1;
      padding: 0 10px;
    }
    .tileFrontText{
      font-weight:1000;
      color: rgba(243,244,246,.94);
      font-size: 14px;
      line-height:1.15;
      padding: 0 10px;
      word-break: break-word;
    }
    .tileBackSel{
      outline: 2px solid rgba(0,229,255,.55);
      box-shadow: 0 0 0 1px rgba(255,255,255,.08), 0 0 30px rgba(0,229,255,.26);
    }

    /* simple switches */
    .switchRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      border-radius: 16px;
      padding: 10px 12px;
      margin-top:10px;
    }
    .switchRow .title{ font-weight:1000; }
    .switchRow .sub{ font-size:12px; color: var(--muted); margin-top:2px; line-height:1.2; }
    .switchRow input[type="checkbox"]{
      width: 48px; height: 28px;
      appearance:none;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 999px;
      position:relative;
      cursor:pointer;
      outline:none;
    }
    .switchRow input[type="checkbox"]::after{
      content:"";
      position:absolute;
      top: 3px; left: 3px;
      width: 22px; height: 22px;
      border-radius: 999px;
      background: rgba(255,255,255,.70);
      box-shadow: 0 10px 20px rgba(0,0,0,.45);
      transition: transform 180ms ease, background 180ms ease;
    }
    .switchRow input[type="checkbox"]:checked{
      background: rgba(0,229,255,.18);
      border-color: rgba(0,229,255,.35);
    }
    .switchRow input[type="checkbox"]:checked::after{
      transform: translateX(20px);
      background: rgba(255,255,255,.88);
    }

    input[type="number"], select{
      width:100%;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.30);
      color: var(--text);
      font-weight:900;
    }

    /* ===== Tutorial Overlay ===== */
    #tutWrap{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 95;
      background:
        radial-gradient(900px 420px at 20% 0%, rgba(255,255,255,.06), transparent 62%),
        radial-gradient(780px 360px at 85% 10%, rgba(255,255,255,.05), transparent 65%),
        linear-gradient(180deg, var(--bg), var(--bg3));
    }
    #tutWrap.on{ display:flex; }

    .tutCard{
      width:min(680px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: 0 22px 60px rgba(0,0,0,.82);
      overflow:hidden;
    }
    .tutTop{
      padding: 14px 14px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .tutTitle{
      font-weight:1000;
      font-size: 18px;
      margin:0;
      line-height:1.1;
    }
    .tutStage{
      font-weight:1000;
      font-size:12px;
      color: rgba(243,244,246,.72);
    }
    .tutViewport{
      overflow:hidden;
      touch-action: pan-y;
    }
    .tutTrack{
      display:flex;
      width: 100%;
      transform: translateX(0%);
      transition: transform 320ms cubic-bezier(.2,.9,.2,1);
      will-change: transform;
    }
    .tutSlide{
      flex: 0 0 100%;
      padding: 14px 14px 12px;
    }
    .tutSlide h4{
      margin: 6px 0 8px;
      font-size: 16px;
      font-weight:1000;
    }
    .tutSlide p{
      margin: 0 0 10px;
      color: rgba(243,244,246,.78);
      font-weight:900;
      line-height:1.35;
      font-size: 13px;
    }
    .tutCallout{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.28);
      border-radius: 18px;
      padding: 10px 12px;
      margin-top: 10px;
    }
    .tutDots{
      display:flex;
      justify-content:center;
      gap:8px;
      padding: 10px 14px 14px;
    }
    .dot{
      width: 8px; height: 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.10);
    }
    .dot.on{
      background: rgba(0,229,255,.40);
      border-color: rgba(0,229,255,.55);
      box-shadow: 0 0 20px rgba(0,229,255,.22);
    }
    .tutFoot{
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
      padding: 0 14px 14px;
    }
    .tutBtns{
      display:flex;
      gap:10px;
      margin-left:auto;
    }
    .tutCheck{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:1000;
      color: rgba(243,244,246,.78);
      font-size: 12px;
      user-select:none;
    }
    .tutCheck input{
      width: 18px; height: 18px;
      accent-color: var(--accent);
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="row sp">
        <div>
          <div class="row" style="gap:10px;">
            <div class="pageTitle" id="appNameH">Taco Ria</div>
            <span class="pill"><span id="verPill">v0.9.1.4.25</span></span>
          </div>
          <div class="muted small" id="subTitle">Private Prep ‚Ä¢ Public Line ‚Ä¢ Remix</div>
        </div>
        <button class="ghost btnTiny" id="btnNewMatchTop">New Match</button>
      </div>
    </header>

    <main>
      <!-- GAMEPLAY -->
      <section class="page on" id="pageGameplay">
        <div class="card heroPhase" style="margin-bottom:12px;">
          <div class="pills" style="margin-top:2px;">
            <span class="pill" id="tilesRemainBadge">Tiles Remaining 0</span>
            <span class="pill" id="kitchenBadge">Kitchen Closed</span>
            <span class="pill" id="handBadge">Hand 1/12</span>
            <span class="pill" id="turnBadge">Your Turn</span>
          </div>

          <div style="margin-top:12px;">
            <div style="font-weight:1000; font-size:16px;" id="phaseTitle">Not Seated Yet</div>
            <div class="muted" id="phaseDesc">Serve 10+ points in one turn to open the kitchen.</div>
          </div>
        </div>

        <div class="actionsTray">
          <div class="card">
            <div class="actionsStack">
              <button class="primary jumbo pulse" id="btnPrep">Prep a Dish</button>
              <button class="primary jumbo" id="btnOrderUp">Order Up!</button>
              <button class="danger jumbo" id="btnEndTurn">End Turn</button>
            </div>
            <div class="muted small" style="margin-top:10px;" id="actionHint">
              One draw per turn.
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Public Line / Window</div>
            <span class="pill" id="lineSummary">0 dishes</span>
          </div>
          <div id="publicLine"></div>
        </div>
      </section>

      <!-- PREP -->
      <section class="page" id="pagePrep">
        <div class="card">
          <div class="row sp" style="margin-bottom:8px;">
            <div style="font-weight:1000;">Prep Table</div>
            <span class="badge" id="prepTurnBadge">Your Turn</span>
          </div>

          <div class="row wrap" style="gap:10px; justify-content:space-between; margin-bottom:12px;">
            <button class="primary jumbo" id="btnDraw">Draw Tile</button>
            <button class="primary jumbo" id="btnOrderUpFromPrep">Order Up!</button>
          </div>

          <details class="acc" open>
            <summary>
              <span>Prep Window</span>
              <span class="muted2 small" id="prepLoadedHint">Empty</span>
            </summary>
            <div class="accBody">
              <div class="slotStrip" id="prepCarousel"></div>
              <div class="hint" id="prepHint" style="margin-top:10px;"></div>
            </div>
          </details>

          <details class="acc" open style="margin-top:10px;">
            <summary>
              <span>Your Hand</span>
              <span class="muted2 small" id="handCountHint">0 tiles</span>
            </summary>
            <div class="accBody">
              <div id="handTiles"></div>

              <div class="row wrap" style="margin-top:12px; justify-content:flex-end;">
                <button class="ghost btnTiny" id="btnClearSelection">Clear Selection</button>
              </div>

              <div class="hint" id="handHint" style="margin-top:10px;">
                Tap tiles to load/unload the Prep Window.
              </div>
            </div>
          </details>

          <details class="acc" style="margin-top:10px;">
            <summary>
              <span>Menu Reference Guide</span>
              <span class="muted2 small">Quick rules</span>
            </summary>
            <div class="accBody" id="menuGuide"></div>
          </details>
        </div>
      </section>

      <!-- SCORES -->
      <section class="page" id="pageScores">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Scores</div>
            <span class="badge" id="scoreModePill">Standard</span>
          </div>

          <div class="row wrap" style="gap:10px; margin-bottom:12px;">
            <span class="pill" id="scoreCurrent">Current: 0</span>
            <span class="pill muted" id="scoreServedMuted">Served this hand: 0</span>
          </div>

          <div id="scoreList"></div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="page" id="pageSettings">
        <div class="card">
          <div class="row sp" style="margin-bottom:10px;">
            <div style="font-weight:1000;">Settings</div>
            <span class="badge">v<span id="verBadge">0.9.1.4.25</span></span>
          </div>
          <div class="muted small">Primary theme stays black. Choose a high-contrast accent.</div>

          <details class="acc" open style="margin-top:12px;">
            <summary>
              <span>Match</span>
              <span class="muted2 small">Mode + Players</span>
            </summary>
            <div class="accBody">
              <div class="row wrap" style="gap:12px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Mode</div>
                  <select id="selMode">
                    <option value="standard">Standard Match</option>
                    <option value="campaign">Campaign</option>
                  </select>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Players</div>
                  <select id="selPlayers">
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4" selected>4 Players</option>
                  </select>
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">CPU Difficulty</div>
                  <select id="selDifficulty"></select>
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Hands</div>
                  <input type="number" id="inpHands" min="1" max="12" value="12" />
                </div>
              </div>

              <div class="row wrap" style="gap:12px; margin-top:10px;">
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Tiles per Player</div>
                  <input type="number" id="inpTilesPerPlayer" min="8" max="24" value="16" />
                </div>
                <div style="flex:1; min-width: 160px;">
                  <div class="label">Decks</div>
                  <select id="selDecks">
                    <option value="1">1 Deck</option>
                    <option value="2" selected>2 Decks (Recommended)</option>
                  </select>
                </div>
              </div>

              <div class="switchRow">
                <div>
                  <div class="title">Auto-Plate</div>
                  <div class="sub">Assist: if a valid dish is detected in Prep, it can auto-serve.</div>
                </div>
                <input type="checkbox" id="chkAutoPlate" />
              </div>

              <div class="switchRow">
                <div>
                  <div class="title">Auto-Remix</div>
                  <div class="sub">CPU: after Kitchen Open, bots may remix (costs Grocery Run).</div>
                </div>
                <input type="checkbox" id="chkAutoRemix" />
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Theme</span>
              <span class="muted2 small">Accent Color</span>
            </summary>
            <div class="accBody">
              <div class="label">Accent</div>
              <select id="selAccent"></select>
              <div class="hint">CPU colors will auto-adjust to avoid matching you or each other.</div>
            </div>
          </details>

          <details class="acc">
            <summary>
              <span>Language</span>
              <span class="muted2 small">EN / ES / FR / DE</span>
            </summary>
            <div class="accBody">
              <div class="label">App Language</div>
              <select id="selLang">
                <option value="en">English</option>
                <option value="es">Espa√±ol</option>
                <option value="fr">Fran√ßais</option>
                <option value="de">Deutsch</option>
              </select>
            </div>
          </details>

          <!-- ‚úÖ Tutorial controls in Settings -->
          <details class="acc">
            <summary>
              <span>Help</span>
              <span class="muted2 small">Tutorial</span>
            </summary>
            <div class="accBody">
              <button class="primary" id="btnViewTutorial" style="width:100%;">View Tutorial</button>

              <div class="switchRow">
                <div>
                  <div class="title">Show tutorial after first draw</div>
                  <div class="sub">If off, it won‚Äôt auto-pop. You can still view it here.</div>
                </div>
                <input type="checkbox" id="chkTutAuto" />
              </div>

              <div class="row wrap" style="justify-content:flex-end; margin-top:10px;">
                <button class="ghost btnTiny" id="btnResetTutorial">Reset tutorial status</button>
              </div>
            </div>
          </details>
        </div>
      </section>
    </main>
  </div>

  <nav class="footer">
    <button class="navBtn active" id="navGame"><div class="ic">üé≠</div><div class="tx">Gameplay</div></button>
    <button class="navBtn" id="navPrep"><div class="ic">üç≥</div><div class="tx">Prep</div></button>
    <button class="navBtn" id="navScores"><div class="ic">üèÜ</div><div class="tx">Scores</div></button>
    <button class="navBtn" id="navSettings"><div class="ic">‚öôÔ∏è</div><div class="tx">Settings</div></button>
  </nav>

  <div id="toastWrap"></div>

  <div id="modalWrap">
    <div class="modal">
      <h3 id="modalTitle">Modal</h3>
      <div class="body" id="modalBody"></div>
      <div class="foot" id="modalFoot"></div>
    </div>
  </div>

  <!-- ‚úÖ Tutorial Overlay -->
  <div id="tutWrap" aria-hidden="true">
    <div class="tutCard" role="dialog" aria-modal="true" aria-label="Tutorial">
      <div class="tutTop">
        <div style="display:flex; flex-direction:column; gap:2px;">
          <div class="tutTitle" id="tutTitle">Tutorial</div>
          <div class="tutStage" id="tutStage">1 / 4</div>
        </div>
        <button class="ghost btnTiny" id="btnTutClose">Close</button>
      </div>

      <div class="tutViewport" id="tutViewport">
        <div class="tutTrack" id="tutTrack">
          <div class="tutSlide" id="slide0"></div>
          <div class="tutSlide" id="slide1"></div>
          <div class="tutSlide" id="slide2"></div>
          <div class="tutSlide" id="slide3"></div>
        </div>
      </div>

      <div class="tutDots" id="tutDots"></div>

      <div class="tutFoot">
        <label class="tutCheck" id="tutHideRow" style="visibility:hidden;">
          <input type="checkbox" id="chkTutHide" />
          Hide this tutorial next time
        </label>

        <div class="tutBtns">
          <button class="ghost" id="btnTutBack">Back</button>
          <button class="primary" id="btnTutNext">Next</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const VERSION = "v0.9.1.4.25";
    const LS_KEY = "taco_ria_state_v091425_breakfast_tutorial";

    const DIFFS = ["Beginner","Easy","Medium","Difficult","Master Chef"];
    const DIFF_DELAY_MS = { "Beginner":5000, "Easy":3500, "Medium":2200, "Difficult":1200, "Master Chef":500 };

    const ACCENTS = [
      { name:"Neon Cyan", val:"#00e5ff" },
      { name:"Signal Yellow", val:"#ffcc00" },
      { name:"Lime", val:"#a3ff12" },
      { name:"Hot Pink", val:"#ff2bd6" },
      { name:"Orange", val:"#ff8a00" },
      { name:"Ice", val:"#b3f6ff" },
      { name:"Violet", val:"#b36bff" },
      { name:"Red", val:"#ff3b30" }
    ];
    const CPU_BASE_COLORS = ["#ff3b30","#b36bff","#ffcc00","#a3ff12"];

    const I18N = {
      en: { gameplay:"Gameplay", prep:"Prep", scores:"Scores", settings:"Settings", orderUp:"Order Up!", drawTile:"Draw Tile", endTurn:"End Turn", prepDish:"Prep a Dish", cancel:"Cancel", close:"Close" },
      es: { gameplay:"Juego", prep:"Preparaci√≥n", scores:"Puntos", settings:"Ajustes", orderUp:"¬°Orden lista!", drawTile:"Robar ficha", endTurn:"Terminar turno", prepDish:"Preparar plato", cancel:"Cancelar", close:"Cerrar" },
      fr: { gameplay:"Jeu", prep:"Pr√©pa", scores:"Scores", settings:"R√©glages", orderUp:"√Ä l‚Äôenvoi !", drawTile:"Piocher une tuile", endTurn:"Fin du tour", prepDish:"Pr√©parer un plat", cancel:"Annuler", close:"Schlie√üen" },
      de: { gameplay:"Spiel", prep:"Vorbereiten", scores:"Punkte", settings:"Einstellungen", orderUp:"Bestellung raus!", drawTile:"Pl√§ttchen ziehen", endTurn:"Zug beenden", prepDish:"Gericht vorbereiten", cancel:"Abbrechen", close:"Schlie√üen" },
    };

    const RULES = {
      tacoDryToppingsRequired: 3,
      wetLockedUntilKitchen: true,
      starterPassDishKey: "chipsDip",
    };

    const RECIPES = [
      { key:"hardTaco", name:"Hard Shell Taco", pts:5, kind:"taco", tortilla:"Corn Tortillas" },
      { key:"softTaco", name:"Soft Taco", pts:5, kind:"taco", tortilla:"Flour Tortillas" },
      { key:"breakfastTaco", name:"Breakfast Taco", pts:3, kind:"breakfast" },
      { key:"chorizoTaco", name:"Chorizo Taco", pts:8, kind:"chorizoTaco" },
      { key:"chipsDip", name:"Chips & Dip", pts:5, kind:"chipsDip" },
      { key:"pico", name:"Pico de Gallo", pts:8, kind:"pico" },
      { key:"ench", name:"Enchiladas", pts:10, kind:"ench" },
    ];

    const DECK_ING_COUNTS = [
      ["Fish",1],["Ground Beef",2],["Shredded Chicken",2],["Carne Guisada",1],["Al Pastor",1],["Carnitas",1],
      ["Egg",2],["Chicken Fajita",2],["Chorizo",1],
      ["Tortilla Chips",3],["Flour Tortillas",2],["Corn Tortillas",2],
      ["Shredded yellow Cheese",2],["Shredded white cheese",2],
      ["Rice",2],["Charro Beans",1],["Refried Beans",1],["Black Beans",1],
      ["Cilantro",2],["Jalapenos",2],["Lettuce",1],["Lime Juice",2],["Onion",2],["Tomato",2],
      ["Sour Cream",2],["Avocado",2],
      ["Salsa Roja",2],["Salsa Verde",2],["Queso",2],["Guacamole",2],
      ["Grocery Run",2],
    ];

    const $ = (id)=> document.getElementById(id);
    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }
    function randInt(n){ return Math.floor(Math.random()*n); }
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }
    function nowId(prefix="id"){
      return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }
    function hexToRgba(hex, a){
      const h = (hex || "#ffffff").replace("#","").trim();
      const full = h.length===3 ? h.split("").map(c=>c+c).join("") : h.padEnd(6,"0").slice(0,6);
      const n = parseInt(full,16);
      const r=(n>>16)&255, g=(n>>8)&255, b=n&255;
      return `rgba(${r},${g},${b},${a})`;
    }
    function groupBy(arr, keyFn){
      const m = {};
      for(const it of arr){
        const k = keyFn(it);
        (m[k] ||= []).push(it);
      }
      return m;
    }
    function toast(msg, ms=2200){
      const wrap = $("toastWrap");
      wrap.innerHTML = `<div class="toast">${escapeHtml(msg)}</div>`;
      clearTimeout(toast._t);
      toast._t = setTimeout(()=> wrap.innerHTML="", ms);
    }

    function openModal(title, html, footButtons){
      $("modalTitle").textContent = title;
      $("modalBody").innerHTML = html;
      $("modalFoot").innerHTML = "";
      for(const b of footButtons){
        const btn = document.createElement("button");
        btn.className = b.className || "ghost";
        btn.textContent = b.text;
        btn.onclick = ()=> b.onClick?.();
        $("modalFoot").appendChild(btn);
      }
      $("modalWrap").classList.add("on");
    }
    function closeModal(){ $("modalWrap").classList.remove("on"); modalMode = null; }
    $("modalWrap").addEventListener("click",(e)=>{ if(e.target.id==="modalWrap") closeModal(); });

    function t(key){
      const lang = state.settings.lang || "en";
      return (I18N[lang] && I18N[lang][key]) || I18N.en[key] || key;
    }
    function getAppName(){
      return ($("appNameH")?.textContent || document.title || "App").trim();
    }
    function recipeByKey(k){ return RECIPES.find(r=>r.key===k); }

    /* ===== Ingredient classification ===== */
    function isWild(name){ return name==="Grocery Run"; }
    function isTortilla(name){ return name==="Corn Tortillas" || name==="Flour Tortillas"; }
    function isProtein(name){
      return ["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"].includes(name);
    }
    function isCheese(name){ return name==="Shredded yellow Cheese" || name==="Shredded white cheese"; }
    function isSauce(name){ return name==="Salsa Roja" || name==="Salsa Verde"; }
    function isWet(name){ return ["Salsa Roja","Salsa Verde","Queso","Guacamole"].includes(name); }
    function isDip(name){ return ["Salsa Roja","Salsa Verde","Guacamole","Queso"].includes(name); }
    function isTopping(name){
      return isWet(name) || ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Avocado","Shredded yellow Cheese","Shredded white cheese"].includes(name);
    }
    function isDryTopping(name){ return isTopping(name) && !isWet(name) && !isCheese(name); }

    function ingredientCategory(name){
      if(isWild(name)) return "wild";
      if(isTortilla(name)) return "tortilla";
      if(isProtein(name)) return "protein";
      if(isCheese(name)) return "cheese";
      if(isWet(name)) return "wet";
      if(isDryTopping(name)) return "drytop";
      return "other";
    }
    function categoryLabel(cat){
      return {
        tortilla:"Tortillas",
        protein:"Proteins",
        cheese:"Cheese",
        wet:"Wet Toppings",
        drytop:"Dry Toppings",
        wild:"Grocery Run",
        other:"Other"
      }[cat] || cat;
    }

    /* ===== Prep Window 8 slots (auto-placed) ===== */
    function slotDefsForRecipe(recipeKey){
      const r = recipeByKey(recipeKey);
      const S = (label, accept)=>({ label, accept });

      if(!r) return Array.from({length:8}).map((_,i)=>S(`Slot ${i+1}`, ()=>true));

      if(r.kind==="breakfast"){
        return [
          S("Tortilla", isTortilla),
          S("Egg", (n)=> n==="Egg"),
          S("Wet (opt)", (n)=> isWet(n)),
          S("Dry Top 1", isDryTopping),
          S("Dry Top 2", isDryTopping),
          S("Extra", ()=> true),
          S("Extra", ()=> true),
          S("Extra", ()=> true),
        ];
      }

      if(r.kind==="taco"){
        return [
          S("Tortilla", isTortilla),
          S("Protein",  isProtein),
          S("Cheese (opt)", isCheese),
          S("Wet (opt)", (n)=> isWet(n)),
          S("Dry Top 1", isDryTopping),
          S("Dry Top 2", isDryTopping),
          S("Dry Top 3", isDryTopping),
          S("Extra", ()=> true),
        ];
      }
      if(r.kind==="chipsDip"){
        return [
          S("Chips", (n)=> n==="Tortilla Chips"),
          S("Dip",   isDip),
          S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true),
        ];
      }
      if(r.kind==="pico"){
        return [
          S("Tomato",   (n)=> n==="Tomato"),
          S("Onion",    (n)=> n==="Onion"),
          S("Cilantro", (n)=> n==="Cilantro"),
          S("Lime",     (n)=> n==="Lime Juice"),
          S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true),
        ];
      }
      if(r.kind==="ench"){
        return [
          S("Tortillas", isTortilla),
          S("Protein",   isProtein),
          S("Sauce",     isSauce),
          S("Cheese",    isCheese),
          S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true),
        ];
      }
      if(r.kind==="chorizoTaco"){
        return [
          S("Tortilla",  isTortilla),
          S("Chorizo",   (n)=> n==="Chorizo"),
          S("Onion",     (n)=> n==="Onion"),
          S("Cilantro",  (n)=> n==="Cilantro"),
          S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true), S("Extra", ()=>true),
        ];
      }

      return Array.from({length:8}).map((_,i)=>S(`Slot ${i+1}`, ()=>true));
    }

    function assignToSlots(hand, selectedIds, recipeKey){
      const slots = slotDefsForRecipe(recipeKey);
      const chosen = selectedIds.map(id=> hand.find(t=>t.id===id)).filter(Boolean);

      const used = new Set();
      const slotFill = slots.map(()=> null);

      for(let si=0; si<slots.length; si++){
        const s = slots[si];
        const found = chosen.find(t => !used.has(t.id) && (isWild(t.name) || s.accept(t.name)));
        if(found){
          slotFill[si] = found;
          used.add(found.id);
        }
      }
      const leftovers = chosen.filter(t=> !used.has(t.id));
      for(let si=0; si<slots.length && leftovers.length; si++){
        if(slotFill[si]) continue;
        slotFill[si] = leftovers.shift();
      }
      return { slots, slotFill };
    }

    /* ===== Validation ===== */
    function validateDish(recipeKey, tileObjs, ctx){
      const r = recipeByKey(recipeKey);
      if(!r) return { ok:false, reason:"Unknown recipe." };

      const names = tileObjs.map(t=>t.name);
      const wildCount = names.filter(isWild).length;
      const nonWild = names.filter(n=>!isWild(n));
      const countName = (nm)=> nonWild.filter(x=>x===nm).length;

      function count(fn){ return nonWild.filter(fn).length; }
      function hasAny(fn){ return count(fn) > 0 || wildCount > 0; }

      if(r.kind==="breakfast"){
        const hasTort = nonWild.some(isTortilla) || (wildCount>0 && !nonWild.some(isTortilla));
        const hasEgg  = nonWild.includes("Egg") || (wildCount>0 && !nonWild.includes("Egg"));
        if(!hasTort) return { ok:false, reason:"Needs a tortilla." };
        if(!hasEgg)  return { ok:false, reason:"Needs egg." };

        if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          if(nonWild.some(isWet)) return { ok:false, reason:"Wet toppings locked until Kitchen Open." };
        }

        if(count(isTortilla) > 1) return { ok:false, reason:"Only 1 tortilla." };
        if(countName("Egg") > 1) return { ok:false, reason:"Only 1 egg." };

        const wets = nonWild.filter(isWet);
        const wetSet = new Set(wets);
        for(const w of wetSet){
          if(countName(w) > 1) return { ok:false, reason:`Only 1 ${w}.` };
        }

        const drys = nonWild.filter(isDryTopping);
        const drySet = new Set(drys);
        for(const dnm of drySet){
          if(countName(dnm) > 2) return { ok:false, reason:`Max double ${dnm}.` };
        }

        if(tileObjs.length < 2) return { ok:false, reason:"Needs at least tortilla + egg." };
        if(tileObjs.length > 7) return { ok:false, reason:"Max 7 tiles." };

        return { ok:true };
      }

      if(r.kind==="taco"){
        const hasReqTortilla = nonWild.includes(r.tortilla) || (wildCount>0 && !nonWild.some(isTortilla));
        if(!hasReqTortilla) return { ok:false, reason:`Use ${r.tortilla}.` };
        if(!hasAny(isProtein)) return { ok:false, reason:"Needs 1 protein." };

        if(RULES.wetLockedUntilKitchen && !ctx.kitchenOpen){
          if(nonWild.some(isWet)) return { ok:false, reason:"Wet toppings locked until Kitchen Open." };
        }

        const dryTopCount = nonWild.filter(isDryTopping).length;
        if(dryTopCount !== RULES.tacoDryToppingsRequired && wildCount < Math.max(0, RULES.tacoDryToppingsRequired - dryTopCount)){
          return { ok:false, reason:`Needs ${RULES.tacoDryToppingsRequired} dry toppings.` };
        }

        if(count(isTortilla) > 1) return { ok:false, reason:"Only 1 tortilla." };
        if(count(isProtein) > 1) return { ok:false, reason:"Only 1 protein." };
        if(count(isCheese) > 1) return { ok:false, reason:"Only 1 cheese." };
        if(nonWild.filter(isWet).length > 1) return { ok:false, reason:"Only 1 wet topping." };

        if(tileObjs.length < 5 || tileObjs.length > 7) return { ok:false, reason:"Use 5‚Äì7 tiles." };
        return { ok:true };
      }

      if(r.kind==="chorizoTaco"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Needs 4 tiles." };
        const hasTort = count(isTortilla) >= 1 || wildCount>=1;
        const hasChor = nonWild.includes("Chorizo") || wildCount>=1;
        const hasOnion = nonWild.includes("Onion") || wildCount>=1;
        const hasCil = nonWild.includes("Cilantro") || wildCount>=1;
        if(!hasTort) return { ok:false, reason:"Needs tortilla." };
        if(!hasChor) return { ok:false, reason:"Needs chorizo." };
        if(!hasOnion) return { ok:false, reason:"Needs onion." };
        if(!hasCil) return { ok:false, reason:"Needs cilantro." };
        return { ok:true };
      }

      if(r.kind==="chipsDip"){
        if(tileObjs.length !== 2) return { ok:false, reason:"Needs 2 tiles." };
        const hasChips = nonWild.includes("Tortilla Chips") || wildCount>=1;
        const hasDip = nonWild.filter(isDip).length >= 1 || wildCount>=1;
        if(!hasChips) return { ok:false, reason:"Needs Tortilla Chips." };
        if(!hasDip) return { ok:false, reason:"Needs a dip (salsa/queso/guac)." };
        return { ok:true };
      }

      if(r.kind==="pico"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Needs 4 tiles." };
        const okTom = nonWild.includes("Tomato") || wildCount>=1;
        const okOn  = nonWild.includes("Onion") || wildCount>=1;
        const okCil = nonWild.includes("Cilantro") || wildCount>=1;
        const okLim = nonWild.includes("Lime Juice") || wildCount>=1;
        if(!okTom || !okOn || !okCil || !okLim) return { ok:false, reason:"Needs Tomato, Onion, Cilantro, Lime." };
        return { ok:true };
      }

      if(r.kind==="ench"){
        if(tileObjs.length !== 4) return { ok:false, reason:"Needs 4 tiles." };
        const hasTort = nonWild.filter(isTortilla).length >= 1 || wildCount>=1;
        const hasProt = nonWild.filter(isProtein).length >= 1 || wildCount>=1;
        const hasChee = nonWild.filter(isCheese).length >= 1 || wildCount>=1;
        const hasSau  = nonWild.filter(isSauce).length >= 1 || wildCount>=1;
        if(!hasTort) return { ok:false, reason:"Needs tortillas." };
        if(!hasProt) return { ok:false, reason:"Needs protein." };
        if(!hasChee) return { ok:false, reason:"Needs shredded cheese." };
        if(!hasSau)  return { ok:false, reason:"Needs sauce." };
        return { ok:true };
      }

      return { ok:false, reason:"Unknown recipe." };
    }

    function detectDishKeyFromSelection(tileObjs, ctx){
      const order = ["breakfastTaco","pico","chipsDip","ench","chorizoTaco","hardTaco","softTaco"];
      for(const k of order){
        const v = validateDish(k, tileObjs, ctx);
        if(v.ok) return k;
      }
      return null;
    }

    /* ===== State ===== */
    function defaultState(){
      return {
        settings:{
          accent:"#00e5ff",
          lang:"en",
          mode:"standard",
          players:4,
          difficulty:"Easy",
          handsTotal:12,
          tilesPerPlayer:16,
          decks:2,
          autoPlate:true,
          autoRemix:false,
        },
        match: null,
        ui:{
          page:"gameplay",
          selectedIds: [],
          lastAutoPlateSig: "",
          tutorialSeen: false,
          tutorialAuto: true,
          pendingTutorialAfterDraw: false
        }
      };
    }

    function persist(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    function load(){
      try{ const raw = localStorage.getItem(LS_KEY); return raw ? JSON.parse(raw) : null; }
      catch{ return null; }
    }
    let state = load() || defaultState();

    function applyDifficultyDefaults(){
      const d = state.settings.difficulty || "Easy";
      state.settings.autoPlate = (d==="Beginner" || d==="Easy");
      state.settings.autoRemix = (d==="Difficult" || d==="Master Chef");
    }

    /* ===== Deck / Match ===== */
    function buildDeck(decks=2){
      const tiles = [];
      for(let d=0; d<decks; d++){
        for(const [name,count] of DECK_ING_COUNTS){
          for(let i=0;i<count;i++){
            tiles.push({ id: nowId("t"), name });
          }
        }
      }
      return shuffle(tiles);
    }

    function mkPlayer(id, name, isHuman, color){
      return {
        id, name, isHuman,
        color,
        score: 0,
        servedThisHand: 0,
        hand: [],
        starterPassUsed: false,
        didDrawThisTurn: false,
        logThisHand: [],
        remixGainThisHand: 0,
        remixLossThisHand: 0,
      };
    }

    function ensureUniqueCpuColors(){
      const used = new Set([state.settings.accent.toLowerCase()]);
      const pickPool = ACCENTS.map(a=>a.val.toLowerCase());
      const unique = [];
      for(const c of CPU_BASE_COLORS){
        let col = c.toLowerCase();
        if(used.has(col)){
          col = pickPool.find(x=>!used.has(x)) || col;
        }
        used.add(col);
        unique.push(col);
      }
      return unique;
    }

    function dealInitial(m){
      const tilesPer = state.settings.tilesPerPlayer;
      for(const pid of Object.keys(m.players)){
        m.players[pid].hand = [];
        for(let i=0;i<tilesPer;i++){
          const t = m.bag.pop();
          if(!t) break;
          m.players[pid].hand.push(t);
        }
      }
    }

    function newMatch(){
      const cpuCols = ensureUniqueCpuColors();
      const pCount = state.settings.players;

      const m = {
        id: nowId("m"),
        handIndex: 1,
        kitchenOpen: false,
        bag: buildDeck(state.settings.decks),
        publicLine: [],
        players: {},
        activePid: "P1",
        servedThisTurnPts: 0,
      };

      m.players["P1"] = mkPlayer("P1","You", true, state.settings.accent);
      if(pCount >= 2) m.players["P2"] = mkPlayer("P2","Chef Mike", false, cpuCols[0]);
      if(pCount >= 3) m.players["P3"] = mkPlayer("P3","Salsa Sam", false, cpuCols[1]);
      if(pCount >= 4) m.players["P4"] = mkPlayer("P4","Queso Queen", false, cpuCols[2]);

      dealInitial(m);

      state.match = m;
      state.ui.page = "gameplay";
      state.ui.selectedIds = [];
      state.ui.lastAutoPlateSig = "";
      beginTurn("P1");
      persist();
      render();
      toast("New match started.");
    }

    function beginTurn(pid){
      const m = state.match;
      const p = m.players[pid];
      if(!p) return;
      p.didDrawThisTurn = false;
      m.servedThisTurnPts = 0;
      if(pid==="P1"){
        state.ui.selectedIds = [];
        state.ui.lastAutoPlateSig = "";
      }
    }

    function p1(){ return state.match.players["P1"]; }

    /* ===== Serving (auto verification) ===== */
    function selectionTileObjs(pl){
      return state.ui.selectedIds.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
    }

    function serveSelection(pid, forcedKey=null){
      const m = state.match;
      const pl = m.players[pid];
      if(m.activePid !== pid) return { ok:false, msg:"Not your turn." };

      const tiles = (pid==="P1")
        ? selectionTileObjs(pl)
        : [];

      if(!tiles.length) return { ok:false, msg:"No ingredients loaded." };

      const ctx = { kitchenOpen: m.kitchenOpen };
      const key = forcedKey || detectDishKeyFromSelection(tiles, ctx);
      if(!key) return { ok:false, msg:"No qualifying dish." };

      const v = validateDish(key, tiles, ctx);
      if(!v.ok) return { ok:false, msg:v.reason };

      const r = recipeByKey(key);
      const pub = {
        id: nowId("pub"),
        owner: pid,
        ownerName: pl.name,
        recipeKey: key,
        name: r.name,
        points: r.pts,
        tiles: tiles.map(t=>({id:t.id, name:t.name})),
        isRemix: false,
        from: null
      };
      m.publicLine.push(pub);

      for(const t of tiles){
        const idx = pl.hand.findIndex(h=>h.id===t.id);
        if(idx>=0) pl.hand.splice(idx,1);
      }

      pl.score += r.pts;
      pl.servedThisHand += r.pts;
      pl.logThisHand.push({ type:"serve", name:r.name, points:r.pts });

      let nonStarterPts = 0;
      if(!m.kitchenOpen){
        if(key === RULES.starterPassDishKey && !pl.starterPassUsed){
          pl.starterPassUsed = true;
        }else{
          nonStarterPts += r.pts;
        }
      }else{
        nonStarterPts += r.pts;
      }

      m.servedThisTurnPts += nonStarterPts;
      if(!m.kitchenOpen && m.servedThisTurnPts >= 10){
        m.kitchenOpen = true;
        toast("üî• Kitchen Open!");
      }

      if(pid==="P1"){
        state.ui.selectedIds = [];
        state.ui.lastAutoPlateSig = "";
      }

      return { ok:true, msg:`Order up! (${r.name})` };
    }

    /* ===== One draw per turn ===== */
    function drawTile(pid){
      const m = state.match;
      const pl = m.players[pid];
      if(m.activePid !== pid) return { ok:false, msg:"Not your turn." };
      if(pl.didDrawThisTurn) return { ok:false, msg:"Only one draw per turn." };
      if(m.bag.length === 0) return { ok:false, msg:"No tiles left." };

      const idx = randInt(m.bag.length);
      const t0 = m.bag.splice(idx, 1)[0];
      pl.hand.push(t0);
      pl.didDrawThisTurn = true;
      return { ok:true, tile:t0 };
    }

    /* ===== End turn + CPU ===== */
    function endTurn(pid){
      const m = state.match;
      if(m.activePid !== pid) return;

      const order = Object.keys(m.players);
      const i = order.indexOf(pid);
      const next = order[(i+1)%order.length];
      m.activePid = next;
      beginTurn(next);

      persist();
      render();

      if(next !== "P1"){
        setTimeout(()=> cpuAct(next), cpuDelayMs());
      }else{
        toast("Your turn.");
      }
    }

    function cpuDelayMs(){
      const diff = state.settings.difficulty || "Easy";
      const base = DIFF_DELAY_MS[diff] ?? 2200;
      return Math.max(450, base + randInt(220));
    }

    function cpuTryRemix(pid){
      const m = state.match;
      const pl = m.players[pid];
      if(!state.settings.autoRemix) return false;
      if(!m.kitchenOpen) return false;
      if(m.publicLine.length === 0) return false;

      const wild = pl.hand.find(t=>t.name==="Grocery Run");
      if(!wild) return false;

      const target = m.publicLine[randInt(m.publicLine.length)];
      if(!target) return false;

      pl.hand = pl.hand.filter(t=>t.id!==wild.id);

      pl.score += target.points;
      pl.servedThisHand += target.points;
      pl.logThisHand.push({ type:"remix", name:`Remix: ${target.name}`, points:target.points, from: target.ownerName });
      pl.remixGainThisHand += target.points;

      m.publicLine.push({
        id: nowId("pub"),
        owner: pid,
        ownerName: pl.name,
        recipeKey: target.recipeKey,
        name: target.name,
        points: target.points,
        tiles: target.tiles.slice(),
        isRemix: true,
        from: target.owner
      });

      toast(`${pl.name}: Remix!`, 1200);
      return true;
    }

    function cpuAct(pid){
      const m = state.match;
      const pl = m.players[pid];
      if(!pl || pl.isHuman) return;

      if(cpuTryRemix(pid)){
        endTurn(pid);
        return;
      }

      const ctx = { kitchenOpen: m.kitchenOpen };
      const tryKeys = ["breakfastTaco","ench","pico","hardTaco","softTaco","chorizoTaco","chipsDip"];

      function pickOne(name){
        return pl.hand.find(x=>x.name===name)?.id || pl.hand.find(x=>x.name==="Grocery Run")?.id || null;
      }
      function anyFrom(names){
        for(const n of names){
          const id = pl.hand.find(x=>x.name===n)?.id;
          if(id) return id;
        }
        return pl.hand.find(x=>x.name==="Grocery Run")?.id || null;
      }

      let served = false;

      for(const rk of tryKeys){
        const r = recipeByKey(rk);
        let ids = [];

        if(r.kind==="breakfast"){
          const tort = anyFrom(["Flour Tortillas","Corn Tortillas"]);
          const egg  = pickOne("Egg");
          if(tort && egg) ids = [tort, egg];
        } else if(r.kind==="chipsDip"){
          const chips = pl.hand.find(x=>x.name==="Tortilla Chips")?.id || pickOne("Tortilla Chips");
          const dip = anyFrom(["Salsa Roja","Salsa Verde","Guacamole","Queso"]);
          if(chips && dip) ids = [chips,dip];
        } else if(r.kind==="pico"){
          const tom = pickOne("Tomato"), oni = pickOne("Onion"), cil = pickOne("Cilantro"), lim = pickOne("Lime Juice");
          if(tom && oni && cil && lim) ids = [tom,oni,cil,lim];
        } else if(r.kind==="ench"){
          const tort = anyFrom(["Flour Tortillas","Corn Tortillas"]);
          const prot = anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]);
          const chee = anyFrom(["Shredded yellow Cheese","Shredded white cheese"]);
          const sauc = anyFrom(["Salsa Roja","Salsa Verde"]);
          if(tort && prot && chee && sauc) ids = [tort,prot,chee,sauc];
        } else if(r.kind==="chorizoTaco"){
          const tort = anyFrom(["Flour Tortillas","Corn Tortillas"]);
          const chor = pickOne("Chorizo"), oni = pickOne("Onion"), cil = pickOne("Cilantro");
          if(tort && chor && oni && cil) ids = [tort,chor,oni,cil];
        } else if(r.kind==="taco"){
          const tort = pickOne(r.tortilla);
          const prot = anyFrom(["Fish","Ground Beef","Shredded Chicken","Carne Guisada","Al Pastor","Carnitas","Egg","Chicken Fajita","Chorizo"]);
          if(tort && prot){
            ids.push(tort,prot);
            const tops = ["Lettuce","Onion","Tomato","Cilantro","Jalapenos","Sour Cream","Avocado","Shredded yellow Cheese","Shredded white cheese"];
            for(const n of tops){
              if(ids.length>=5) break;
              const id = pl.hand.find(x=>x.name===n)?.id;
              if(id && !ids.includes(id)) ids.push(id);
            }
            while(ids.length<5){
              const w = pl.hand.find(x=>x.name==="Grocery Run")?.id;
              if(!w) break;
              ids.push(w);
            }
          }
        }

        if(ids.length){
          const tiles = ids.map(id=> pl.hand.find(t=>t.id===id)).filter(Boolean);
          const v = validateDish(rk, tiles, ctx);
          if(v.ok){
            const pub = {
              id: nowId("pub"),
              owner: pid,
              ownerName: pl.name,
              recipeKey: rk,
              name: r.name,
              points: r.pts,
              tiles: tiles.map(t=>({id:t.id, name:t.name})),
              isRemix: false,
              from: null
            };
            m.publicLine.push(pub);
            for(const t of tiles){
              const idx = pl.hand.findIndex(h=>h.id===t.id);
              if(idx>=0) pl.hand.splice(idx,1);
            }
            pl.score += r.pts;
            pl.servedThisHand += r.pts;
            pl.logThisHand.push({ type:"serve", name:r.name, points:r.pts });

            m.servedThisTurnPts += r.pts;
            if(!m.kitchenOpen && m.servedThisTurnPts >= 10){
              m.kitchenOpen = true;
              toast("üî• Kitchen Open!");
            }

            toast(`${pl.name}: ${r.name}`, 1200);
            served = true;
            break;
          }
        }
      }

      if(!served){
        if(!pl.didDrawThisTurn && m.bag.length){
          const res = drawTile(pid);
          if(res.ok) toast(`${pl.name} drew a tile.`, 1100);
        }
      }

      persist();
      render();
      endTurn(pid);
    }

    /* ===== Prep selection ===== */
    function toggleSelect(tileId){
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      const ids = state.ui.selectedIds;
      if(ids.includes(tileId)) state.ui.selectedIds = ids.filter(x=>x!==tileId);
      else{
        if(ids.length >= 8){ toast("Prep Window max 8."); return; }
        state.ui.selectedIds = [...ids, tileId];
      }
      persist();
      render();
      maybeAutoPlate();
    }

    function clearSelection(){
      state.ui.selectedIds = [];
      state.ui.lastAutoPlateSig = "";
      persist();
      render();
    }

    function maybeAutoPlate(){
      const m = state.match;
      if(m.activePid !== "P1") return;
      if(!state.settings.autoPlate) return;

      const pl = p1();
      const ctx = { kitchenOpen: m.kitchenOpen };
      const tiles = selectionTileObjs(pl);
      const key = detectDishKeyFromSelection(tiles, ctx);
      if(!key) return;

      const sig = key + "|" + tiles.map(t=>t.id).sort().join(",");
      if(sig === state.ui.lastAutoPlateSig) return;

      state.ui.lastAutoPlateSig = sig;
      persist();

      setTimeout(()=>{
        const pl2 = p1();
        const tiles2 = selectionTileObjs(pl2);
        const key2 = detectDishKeyFromSelection(tiles2, { kitchenOpen: state.match.kitchenOpen });
        const sig2 = (key2||"") + "|" + tiles2.map(t=>t.id).sort().join(",");
        if(sig2 !== sig) return;

        const res = serveSelection("P1", key);
        if(res.ok){
          persist();
          render();
          toast("Order up!");
        }
      }, 520);
    }

    /* ===== Tutorial (swipe pages) ===== */
    const TUT_TOTAL = 4;
    let tutIndex = 0;

    function tutSlidesHtml(){
      const app = escapeHtml(getAppName());
      return [
        `
          <h4>What‚Äôs next?</h4>
          <p>You just drew an ingredient. Your next move is to build an <b>entr√©e</b> or <b>appetizer</b> using the ingredients in front of you.</p>
          <div class="tutCallout">
            <p style="margin:0;">
              Go to <b>Prep</b> ‚Üí tap tiles in <b>Your Hand</b> to load the <b>Prep Window</b>.
              When a menu dish is detected, <b>Order Up!</b> becomes available.
            </p>
          </div>
          <p style="margin-top:10px;">Tip: the Prep Window auto-organizes your selection so it‚Äôs easy to see what you‚Äôre missing.</p>
        `,
        `
          <h4>Opening the Kitchen</h4>
          <p>The Kitchen starts closed. To open it, you must serve <b>10+ points in a single turn</b>.</p>
          <div class="tutCallout">
            <p style="margin:0;">
              While the Kitchen is closed, <b>wet ingredients</b> (like salsa, queso, guac) are locked.
              Once it‚Äôs open, wet ingredients are allowed.
            </p>
          </div>
          <p style="margin-top:10px;">Watch the badge on Gameplay: <b>Kitchen Closed</b> ‚Üí <b>Kitchen Open</b>.</p>
        `,
        `
          <h4>Remixing</h4>
          <p>After the Kitchen opens, Remixing can come into play. It‚Äôs a power move that lets a player leverage the existing Public Line.</p>
          <div class="tutCallout">
            <p style="margin:0;">
              In harder setups, CPUs can <b>Remix</b> using a <b>Grocery Run</b> tile‚Äîcreating a Remix dish in the window.
              (You‚Äôll see it labeled ‚ÄúRemix‚Äù.)
            </p>
          </div>
          <p style="margin-top:10px;">Think of it as ‚Äúre-using the line‚Äù to surge points when timing is right.</p>
        `,
        `
          <h4>Bonuses & future spice</h4>
          <p>Some builds will earn extra love‚Äîdepending on your mode, house rules, or future updates.</p>
          <div class="tutCallout">
            <p style="margin:0;">
              Examples: <b>extra toppings</b>, <b>double lettuce</b>, clean ‚Äúperfect builds,‚Äù seasonal specials, and more.
            </p>
          </div>
          <p style="margin-top:10px;">If you want, you can hide this tutorial after today and revisit it anytime in <b>Settings ‚Üí Help</b>.</p>
        `
      ];
    }

    function openTutorial(startAt=0){
      tutIndex = Math.max(0, Math.min(TUT_TOTAL-1, startAt));
      $("tutWrap").classList.add("on");
      $("tutWrap").setAttribute("aria-hidden","false");

      // inject slide content once per open
      const htmls = tutSlidesHtml();
      for(let i=0;i<TUT_TOTAL;i++){
        $("slide"+i).innerHTML = htmls[i];
      }

      // sync checkbox to current setting (auto show)
      $("chkTutHide").checked = !state.ui.tutorialAuto;

      renderTutorial();
      attachTutorialGestures();
    }

    function closeTutorial(){
      $("tutWrap").classList.remove("on");
      $("tutWrap").setAttribute("aria-hidden","true");
      detachTutorialGestures();
      // clearing pending, in case this was auto-launched
      state.ui.pendingTutorialAfterDraw = false;
      persist();
    }

    function renderTutorial(){
      $("tutTitle").textContent = "Tutorial";
      $("tutStage").textContent = `${tutIndex+1} / ${TUT_TOTAL}`;
      $("tutTrack").style.transform = `translateX(-${tutIndex*100}%)`;

      // dots
      $("tutDots").innerHTML = Array.from({length:TUT_TOTAL}).map((_,i)=>`
        <div class="dot ${i===tutIndex ? "on" : ""}"></div>
      `).join("");

      $("btnTutBack").disabled = (tutIndex===0);
      $("btnTutNext").textContent = (tutIndex===TUT_TOTAL-1) ? "Done" : "Next";

      // show hide option only on last page
      $("tutHideRow").style.visibility = (tutIndex===TUT_TOTAL-1) ? "visible" : "hidden";
    }

    function nextTutorial(){
      if(tutIndex < TUT_TOTAL-1){
        tutIndex++;
        renderTutorial();
        return;
      }

      // Done (last page)
      state.ui.tutorialSeen = true;

      // If checked: hide next time (turn off auto pop)
      state.ui.tutorialAuto = !$("chkTutHide").checked ? true : false;

      persist();
      closeTutorial();
      toast("Tutorial saved.");
    }

    function backTutorial(){
      if(tutIndex>0){
        tutIndex--;
        renderTutorial();
      }
    }

    $("btnTutClose").onclick = ()=>{
      // Close keeps preference as-is, but marks as seen so it doesn‚Äôt feel naggy
      state.ui.tutorialSeen = true;
      persist();
      closeTutorial();
    };
    $("btnTutNext").onclick = nextTutorial;
    $("btnTutBack").onclick = backTutorial;

    // swipe gestures
    let tutGesturesAttached = false;
    let tutStartX = 0;
    let tutStartY = 0;
    let tutDown = false;

    function onTutDown(e){
      const pt = (e.touches && e.touches[0]) ? e.touches[0] : e;
      tutDown = true;
      tutStartX = pt.clientX;
      tutStartY = pt.clientY;
    }
    function onTutUp(e){
      if(!tutDown) return;
      tutDown = false;
      const pt = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : e;
      const dx = pt.clientX - tutStartX;
      const dy = pt.clientY - tutStartY;

      // ignore mostly-vertical gestures
      if(Math.abs(dy) > Math.abs(dx)) return;

      if(dx <= -50) nextTutorial();
      else if(dx >= 50) backTutorial();
    }

    function attachTutorialGestures(){
      if(tutGesturesAttached) return;
      tutGesturesAttached = true;
      const vp = $("tutViewport");
      vp.addEventListener("touchstart", onTutDown, {passive:true});
      vp.addEventListener("touchend", onTutUp, {passive:true});
      // mouse
      vp.addEventListener("mousedown", onTutDown);
      window.addEventListener("mouseup", onTutUp);
    }
    function detachTutorialGestures(){
      if(!tutGesturesAttached) return;
      tutGesturesAttached = false;
      const vp = $("tutViewport");
      vp.removeEventListener("touchstart", onTutDown);
      vp.removeEventListener("touchend", onTutUp);
      vp.removeEventListener("mousedown", onTutDown);
      window.removeEventListener("mouseup", onTutUp);
    }

    function maybeLaunchTutorialAfterFirstDraw(){
      // show only if:
      // - tutorialAuto is on
      // - tutorial not already seen
      // - we explicitly queued it (after first draw reveal)
      if(!state.ui.tutorialAuto) return;
      if(state.ui.tutorialSeen) return;
      if(!state.ui.pendingTutorialAfterDraw) return;

      // reset queue + open
      state.ui.pendingTutorialAfterDraw = false;
      state.ui.tutorialSeen = true; // marks it as "already surfaced"
      persist();

      // small delay so it feels intentional after the draw modal closes
      setTimeout(()=> openTutorial(0), 260);
    }

    /* ===== Draw Tile Modal Grid ===== */
    let modalMode = null;
    function bestFitCols(n){
      if(n >= 25) return 5;
      const c = Math.ceil(Math.sqrt(n));
      return Math.max(1, Math.min(5, c));
    }

    function openDrawModal(){
      const m = state.match;
      const pl = p1();
      const myTurn = (m.activePid === "P1");

      if(!myTurn){ toast("Not your turn."); return; }
      if(pl.didDrawThisTurn){ toast("Only one draw per turn."); return; }

      const total = m.bag.length;
      if(total === 0){
        openModal(
          t("drawTile"),
          `<div class="muted">No more tiles to choose from.</div>`,
          [{ text: t("close"), className:"primary", onClick: closeModal }]
        );
        return;
      }

      const shown = Math.min(25, total);
      const cols = bestFitCols(shown);
      const appName = escapeHtml(getAppName());

      const meta = `
        <div class="drawMeta">
          <span class="pill">Tiles Remaining <span>${total}</span></span>
          ${total > 25 ? `<span class="pill muted">Showing 25</span>` : ``}
        </div>
        <div class="muted small">Pick a tile, any tile...</div>
      `;

      const grid = `
        <div class="drawGrid" id="drawGrid" style="grid-template-columns: repeat(${cols}, 1fr);">
          ${Array.from({length: shown}).map((_,i)=>`
            <div class="tileBack" data-draw-pick="${i}">
              <div class="tileFlip">
                <div class="face back">
                  <div class="tileBackBrand">${appName}</div>
                </div>
                <div class="face front">
                  <div class="tileFrontText" data-front-text>‚Äî</div>
                </div>
              </div>
            </div>
          `).join("")}
        </div>
      `;

      openModal(
        t("drawTile"),
        meta + grid,
        [{ text: t("cancel"), className:"ghost", onClick: closeModal }]
      );

      modalMode = "draw";

      $("modalBody").onclick = (e)=>{
        if(modalMode !== "draw") return;
        const pick = e.target.closest("[data-draw-pick]");
        if(!pick) return;

        const gridEl = $("drawGrid");
        if(gridEl) gridEl.classList.add("busy");
        pick.classList.add("tileBackSel");
        modalMode = "draw_busy";

        const res = drawTile("P1");
        if(!res.ok){
          toast(res.msg);
          closeModal();
          persist(); render();
          return;
        }

        // queue tutorial ONLY on first-ever draw (and only if auto is on)
        if(!state.ui.tutorialSeen && state.ui.tutorialAuto){
          state.ui.pendingTutorialAfterDraw = true;
          persist();
        }

        const front = pick.querySelector("[data-front-text]");
        if(front) front.textContent = res.tile.name;
        pick.classList.add("reveal");

        persist();
        render();

        setTimeout(()=>{
          closeModal();
          toast(`Drew: ${res.tile.name}`);
          maybeLaunchTutorialAfterFirstDraw(); // ‚úÖ tutorial pops AFTER draw modal closes
        }, 1050);
      };
    }

    /* ===== Pages / Nav ===== */
    function setPage(p){
      state.ui.page = p;
      persist();
      render();
    }
    function setNavActive(btnId){
      ["navGame","navPrep","navScores","navSettings"].forEach(id=>{
        $(id).classList.toggle("active", id===btnId);
      });
    }
    $("navGame").onclick = ()=> setPage("gameplay");
    $("navPrep").onclick = ()=> setPage("prep");
    $("navScores").onclick = ()=> setPage("scores");
    $("navSettings").onclick = ()=> setPage("settings");

    /* ===== Buttons ===== */
    $("btnNewMatchTop").onclick = ()=>{
      openModal(
        "New Match",
        "Start a fresh match? This overwrites current match state.",
        [
          { text:"Cancel", className:"ghost", onClick: closeModal },
          { text:"Start", className:"primary", onClick: ()=>{ closeModal(); newMatch(); } }
        ]
      );
    };

    $("btnPrep").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      setPage("prep");
    };

    function attemptOrderUp(){
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      const pl = p1();
      const ctx = { kitchenOpen: m.kitchenOpen };
      const tiles = selectionTileObjs(pl);
      const key = detectDishKeyFromSelection(tiles, ctx);
      if(!key){ toast("No qualifying dish."); return; }
      const res = serveSelection("P1", key);
      if(!res.ok){ toast(res.msg); return; }
      persist(); render();
      toast("Order up!");
      setPage("gameplay");
    }

    $("btnOrderUp").onclick = ()=>{
      if(state.ui.page !== "prep") setPage("prep");
      setTimeout(attemptOrderUp, 0);
    };

    $("btnEndTurn").onclick = ()=>{
      const m = state.match;
      if(m.activePid !== "P1"){ toast("Not your turn."); return; }
      endTurn("P1");
    };

    $("btnDraw").onclick = openDrawModal;
    $("btnOrderUpFromPrep").onclick = attemptOrderUp;
    $("btnClearSelection").onclick = clearSelection;

    /* ===== Settings fill + events ===== */
    function fillSettings(){
      $("verPill").textContent = VERSION;
      $("verBadge").textContent = VERSION.replace("v","");
      $("selDifficulty").innerHTML = DIFFS.map(d=> `<option value="${d}">${d}</option>`).join("");
      $("selDifficulty").value = state.settings.difficulty;

      $("selAccent").innerHTML = ACCENTS.map(a=> `<option value="${a.val}">${a.name} (${a.val})</option>`).join("");
      $("selAccent").value = state.settings.accent;

      $("selMode").value = state.settings.mode;
      $("selPlayers").value = String(state.settings.players);
      $("inpHands").value = state.settings.handsTotal;
      $("inpTilesPerPlayer").value = state.settings.tilesPerPlayer;
      $("selDecks").value = String(state.settings.decks);
      $("selLang").value = state.settings.lang;

      $("chkAutoPlate").checked = !!state.settings.autoPlate;
      $("chkAutoRemix").checked = !!state.settings.autoRemix;

      // tutorial settings
      $("chkTutAuto").checked = !!state.ui.tutorialAuto;
    }

    $("selMode").onchange = ()=>{ state.settings.mode = $("selMode").value; persist(); render(); };
    $("selPlayers").onchange = ()=>{ state.settings.players = parseInt($("selPlayers").value,10); persist(); render(); toast("Players updated."); };
    $("selDifficulty").onchange = ()=>{
      state.settings.difficulty = $("selDifficulty").value;
      applyDifficultyDefaults();
      persist(); render(); toast("Difficulty updated.");
    };
    $("inpHands").onchange = ()=>{ state.settings.handsTotal = Math.max(1, Math.min(12, parseInt($("inpHands").value,10) || 12)); persist(); render(); };
    $("inpTilesPerPlayer").onchange = ()=>{ state.settings.tilesPerPlayer = Math.max(8, Math.min(24, parseInt($("inpTilesPerPlayer").value,10) || 16)); persist(); render(); };
    $("selDecks").onchange = ()=>{ state.settings.decks = parseInt($("selDecks").value,10) || 2; persist(); render(); toast("Decks updated."); };
    $("selLang").onchange = ()=>{ state.settings.lang = $("selLang").value; persist(); render(); };

    $("chkAutoPlate").onchange = ()=>{ state.settings.autoPlate = $("chkAutoPlate").checked; state.ui.lastAutoPlateSig=""; persist(); render(); };
    $("chkAutoRemix").onchange = ()=>{ state.settings.autoRemix = $("chkAutoRemix").checked; persist(); render(); };

    $("selAccent").onchange = ()=>{
      state.settings.accent = $("selAccent").value;
      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      if(state.match){
        const cpuCols = ensureUniqueCpuColors();
        if(state.match.players["P2"]) state.match.players["P2"].color = cpuCols[0];
        if(state.match.players["P3"]) state.match.players["P3"].color = cpuCols[1];
        if(state.match.players["P4"]) state.match.players["P4"].color = cpuCols[2];
        state.match.players["P1"].color = state.settings.accent;
      }

      persist(); render();
    };

    // tutorial setting controls
    $("btnViewTutorial").onclick = ()=> openTutorial(0);
    $("chkTutAuto").onchange = ()=>{
      state.ui.tutorialAuto = $("chkTutAuto").checked;
      persist();
      toast(state.ui.tutorialAuto ? "Tutorial will auto-show after first draw." : "Tutorial auto-show disabled.");
      render();
    };
    $("btnResetTutorial").onclick = ()=>{
      state.ui.tutorialSeen = false;
      state.ui.pendingTutorialAfterDraw = false;
      persist();
      toast("Tutorial reset.");
      render();
    };

    function phaseText(){
      const m = state.match;
      if(m.kitchenOpen) return { title:"Kitchen Open", desc:"Remix is enabled. Wet toppings allowed." };
      if(m.publicLine.length > 0) return { title:"Appetizers Out", desc:"Build toward 10+ points in a single turn to open the kitchen." };
      return { title:"Not Seated Yet", desc:"Serve 10+ points in one turn to open the kitchen." };
    }
    function playerColor(pid){
      const m = state.match;
      return m.players[pid]?.color || "#ffffff";
    }

    function renderPublicLine(){
      const m = state.match;
      const el = $("publicLine");
      $("lineSummary").textContent = `${m.publicLine.length} dish${m.publicLine.length===1?"":"es"}`;

      if(!m.publicLine.length){
        el.innerHTML = `<div class="muted small">No dishes in the window yet.</div>`;
        return;
      }

      const groups = groupBy(m.publicLine, d=> d.name);
      el.innerHTML = Object.entries(groups).map(([menuItem, dishes])=>{
        const total = dishes.reduce((t,d)=>t+d.points,0);
        return `
          <div class="pubGroup">
            <div class="pubGroupTitle">
              <div>${escapeHtml(menuItem)}</div>
              <span class="badge">Total ${total}</span>
            </div>
            ${dishes.map(d=>{
              const col = playerColor(d.owner);
              const tintA = hexToRgba(col,.28);
              const tiles = d.tiles.map(ti=>{
                const cat = ingredientCategory(ti.name);
                const wet = isWet(ti.name) ? "wet" : "";
                const wild = isWild(ti.name) ? "wild" : "";
                return `<span class="tile ${wet} ${wild} cat-${cat}">${escapeHtml(ti.name)}</span>`;
              }).join("");
              return `
                <div class="pubDishRow" style="--tintA:${tintA};">
                  <div class="pubDishMeta">
                    <div>${escapeHtml(d.ownerName)}${d.isRemix ? " ‚Ä¢ Remix" : ""}</div>
                    <span class="badge">${d.points} pts</span>
                  </div>
                  <div class="tiles" style="margin-top:8px;">${tiles}</div>
                </div>
              `;
            }).join("")}
          </div>
        `;
      }).join("");
    }

    function renderPrep(){
      const m = state.match;
      const pl = p1();
      const myTurn = (m.activePid==="P1");

      $("prepTurnBadge").textContent = myTurn ? "Your Turn" : `${m.players[m.activePid].name}'s Turn`;
      $("handCountHint").textContent = `${pl.hand.length} tiles`;

      $("btnDraw").textContent = t("drawTile");
      $("btnDraw").disabled = !myTurn || pl.didDrawThisTurn || m.bag.length===0;
      if(!pl.didDrawThisTurn && myTurn && m.bag.length>0) $("btnDraw").classList.add("pulse");
      else $("btnDraw").classList.remove("pulse");

      const ctx = { kitchenOpen: m.kitchenOpen };
      const tiles = selectionTileObjs(pl);
      const key = detectDishKeyFromSelection(tiles, ctx);
      const canOrder = myTurn && !!key;

      $("btnOrderUpFromPrep").disabled = !canOrder;
      $("btnOrderUpFromPrep").classList.toggle("pulseOrder", canOrder);
      $("btnOrderUpFromPrep").textContent = t("orderUp");

      if(!tiles.length){
        $("prepLoadedHint").textContent = "Empty";
        $("prepHint").textContent = "Load ingredients to detect a dish.";
      } else if(!key){
        $("prepLoadedHint").textContent = `${tiles.length}/8 loaded`;
        $("prepHint").textContent = "No dish detected yet.";
      } else {
        const r = recipeByKey(key);
        $("prepLoadedHint").textContent = `${r.name} ‚Ä¢ ${r.pts} pts`;
        const v = validateDish(key, tiles, ctx);
        $("prepHint").textContent = v.ok ? "‚úÖ Ready for Order Up!" : `‚ö†Ô∏è ${v.reason}`;
      }

      const car = $("prepCarousel");
      const useKey = key || "breakfastTaco";
      const { slots, slotFill } = assignToSlots(pl.hand, state.ui.selectedIds, useKey);

      car.innerHTML = slots.map((s, i)=>{
        const tObj = slotFill[i];
        const filled = !!tObj;
        const cat = filled ? ingredientCategory(tObj.name) : "";
        const txt = filled ? escapeHtml(tObj.name) : "Empty";
        return `
          <div class="slotCard" data-slot-idx="${i}">
            <div class="slotLabel">${escapeHtml(s.label)}</div>
            <div class="slotValue ${filled ? "slotFilled" : "slotEmpty"} ${filled ? `cat-${cat}` : ""}">
              ${txt}
            </div>
          </div>
        `;
      }).join("");

      const grouped = groupBy(pl.hand, t => ingredientCategory(t.name));
      const order = ["tortilla","protein","cheese","wet","drytop","wild","other"];

      $("handTiles").innerHTML = `
        <div class="handGroups">
          ${order.filter(cat => (grouped[cat]||[]).length).map(cat=>{
            const arr = grouped[cat];
            return `
              <div class="handGroup">
                <div class="handGroupTitle">
                  <span>${escapeHtml(categoryLabel(cat))}</span>
                  <span class="count">${arr.length}</span>
                </div>
                <div class="tiles">
                  ${arr.map(ti=>{
                    const sel = state.ui.selectedIds.includes(ti.id);
                    const wet = isWet(ti.name) ? "wet" : "";
                    const wild = isWild(ti.name) ? "wild" : "";
                    return `
                      <span class="tile ${sel?"sel":""} ${wet} ${wild} cat-${cat}" data-htile="${escapeHtml(ti.id)}">
                        ${escapeHtml(ti.name)}
                      </span>
                    `;
                  }).join("")}
                </div>
              </div>
            `;
          }).join("")}
        </div>
      `;

      $("menuGuide").innerHTML = `
        <div class="hint" style="margin-top:6px;">
          Simple rule-of-thumb. If the Prep Window matches a dish, <b>Order Up!</b> lights up.
        </div>
        <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>

        <div class="row sp"><div style="font-weight:1000;">Breakfast Taco (3)</div></div>
        <div class="muted small">Requires: <b>tortilla</b> + <b>egg</b>. Dry toppings can be doubled. Wet toppings single each.</div>

        <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>

        <div class="row sp"><div style="font-weight:1000;">Hard Shell Taco (5)</div></div>
        <div class="muted small">Corn tortillas + 1 protein + 3 dry toppings (5‚Äì7 tiles).</div>

        <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>

        <div class="row sp"><div style="font-weight:1000;">Soft Taco (5)</div></div>
        <div class="muted small">Flour tortillas + 1 protein + 3 dry toppings (5‚Äì7 tiles).</div>

        <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>

        <div class="row sp"><div style="font-weight:1000;">Chorizo Taco (8)</div></div>
        <div class="muted small">Tortilla + chorizo + onion + cilantro.</div>

        <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>

        <div class="row sp"><div style="font-weight:1000;">Chips & Dip (5)</div></div>
        <div class="muted small">Tortilla chips + any dip (salsa/queso/guac).</div>

        <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>

        <div class="row sp"><div style="font-weight:1000;">Pico de Gallo (8)</div></div>
        <div class="muted small">Tomato + onion + cilantro + lime juice.</div>

        <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>

        <div class="row sp"><div style="font-weight:1000;">Enchiladas (10)</div></div>
        <div class="muted small">Tortillas + 1 protein + sauce + shredded cheese.</div>
      `;
    }

    function renderScores(){
      const m = state.match;
      const pl = p1();
      $("scoreModePill").textContent = state.settings.mode==="campaign" ? "Campaign" : "Standard";
      $("scoreCurrent").textContent = `Current: ${pl.score}`;
      $("scoreServedMuted").textContent = `Served this hand: ${pl.servedThisHand}`;

      const players = Object.values(m.players);
      $("scoreList").innerHTML = players.map(p=>{
        const net = (p.remixGainThisHand||0) - (p.remixLossThisHand||0);
        const netTxt = net === 0 ? "0" : (net > 0 ? `+${net}` : `${net}`);

        const dishLines = (p.logThisHand || []).map(ev=>{
          const extra = ev.type==="remix" ? ` <span class="muted2 small">(from ${escapeHtml(ev.from || "‚Äî")})</span>` : "";
          return `<div class="row sp" style="gap:12px; margin-top:8px;">
            <div style="font-weight:900;">${escapeHtml(ev.name)}${extra}</div>
            <span class="badge">${ev.points}</span>
          </div>`;
        }).join("") || `<div class="muted small">No dishes served yet this hand.</div>`;

        return `
          <details class="acc" style="margin-top:12px;">
            <summary>
              <span>${escapeHtml(p.name)}${p.id==="P1" ? " (You)" : ""}</span>
              <span class="badge">Score ${p.score}</span>
            </summary>
            <div class="accBody">
              <div class="row wrap" style="gap:10px; margin-top:6px;">
                <span class="pill">Served: ${p.servedThisHand}</span>
                <span class="pill">Remix Net: ${netTxt}</span>
              </div>
              <div style="height:1px; background: rgba(255,255,255,.06); margin: 12px 0;"></div>
              ${dishLines}
            </div>
          </details>
        `;
      }).join("");
    }

    function renderGameplay(){
      const m = state.match;
      const myTurn = (m.activePid==="P1");

      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      $("navGame").querySelector(".tx").textContent = t("gameplay");
      $("navPrep").querySelector(".tx").textContent = t("prep");
      $("navScores").querySelector(".tx").textContent = t("scores");
      $("navSettings").querySelector(".tx").textContent = t("settings");

      $("btnPrep").textContent = t("prepDish");
      $("btnEndTurn").textContent = t("endTurn");

      $("tilesRemainBadge").textContent = `Tiles Remaining ${m.bag.length}`;
      $("kitchenBadge").textContent = m.kitchenOpen ? "Kitchen Open" : "Kitchen Closed";
      $("handBadge").textContent = `Hand ${m.handIndex}/${state.settings.handsTotal}`;
      $("turnBadge").textContent = myTurn ? "Your Turn" : `${m.players[m.activePid].name}'s Turn`;

      const ph = phaseText();
      $("phaseTitle").textContent = ph.title;
      $("phaseDesc").textContent = ph.desc;

      const pl = p1();
      const ctx = { kitchenOpen: m.kitchenOpen };
      const tiles = selectionTileObjs(pl);
      const key = detectDishKeyFromSelection(tiles, ctx);
      const canOrder = myTurn && !!key;

      $("btnOrderUp").textContent = t("orderUp");
      $("btnOrderUp").disabled = !canOrder;
      $("btnOrderUp").classList.toggle("pulseOrder", canOrder);

      $("btnPrep").disabled = !myTurn;
      $("btnEndTurn").disabled = !myTurn;

      renderPublicLine();
    }

    function render(){
      if(!state.match) newMatch();

      ["pageGameplay","pagePrep","pageScores","pageSettings"].forEach(id=> $(id).classList.remove("on"));
      if(state.ui.page==="gameplay"){ $("pageGameplay").classList.add("on"); setNavActive("navGame"); }
      if(state.ui.page==="prep"){ $("pagePrep").classList.add("on"); setNavActive("navPrep"); }
      if(state.ui.page==="scores"){ $("pageScores").classList.add("on"); setNavActive("navScores"); }
      if(state.ui.page==="settings"){ $("pageSettings").classList.add("on"); setNavActive("navSettings"); }

      fillSettings();
      renderGameplay();
      renderPrep();
      renderScores();
    }

    /* ===== Hand click ===== */
    $("handTiles").addEventListener("click",(e)=>{
      const el = e.target.closest("[data-htile]");
      if(!el) return;
      toggleSelect(el.getAttribute("data-htile"));
    });

    /* ===== Boot ===== */
    function boot(){
      if(typeof state.settings.autoPlate !== "boolean" || typeof state.settings.autoRemix !== "boolean"){
        applyDifficultyDefaults();
      }
      if(typeof state.ui.tutorialAuto !== "boolean") state.ui.tutorialAuto = true;
      if(typeof state.ui.tutorialSeen !== "boolean") state.ui.tutorialSeen = false;
      if(typeof state.ui.pendingTutorialAfterDraw !== "boolean") state.ui.pendingTutorialAfterDraw = false;

      document.documentElement.style.setProperty("--accent", state.settings.accent);
      document.documentElement.style.setProperty("--accentSoft", hexToRgba(state.settings.accent, .14));

      if(state.match){
        state.match.players["P1"].color = state.settings.accent;
        const cpuCols = ensureUniqueCpuColors();
        if(state.match.players["P2"]) state.match.players["P2"].color = cpuCols[0];
        if(state.match.players["P3"]) state.match.players["P3"].color = cpuCols[1];
        if(state.match.players["P4"]) state.match.players["P4"].color = cpuCols[2];
      }
      render();
    }

    boot();
  </script>
</body>
</html>
